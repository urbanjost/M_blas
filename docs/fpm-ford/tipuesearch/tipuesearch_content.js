var tipuesearch = {"pages":[{"title":" M_blas ","text":"M_blas Name M_blas – BLAS routines in a Fortran module format The BLAS (Basic Linear Algebra Subprograms) are well-established routines\nthat provide standard building blocks for performing basic vector and\nmatrix operations. There are several versions of the library available; this is based off\nthe Public Domain FORTRAN reference implementation of BLAS Basic Linear Algebra Subprograms provided by the National Science Foundation. It has been converted to a free-format Fortran module and is in the\nprocess of being changed to use more recent Fortran features primarily\nfor investigating the significance of what benefits this can have, such\nas an automatic calling interface and name collision avoidance provided by being modularized, INTENT specifications , array syntax and so on. For compatibility purposes the wrapper file src/compatible.f90 is\nincluded, which allows for an old non-interface calling style so if\nyou are using a BLAS library compatible with the reference version\nyou should be able to use this library (and the accompanying module)\nas a drop-in replacement at the cost of loosing the strict interface\nthe module provides and the additional call overhead to the wrapper. If that works with your existing code, the next step is to then include\nUSE statements in the calling source and to remove src/compatible.f90\nand rebuild. If there are significant benefits the idea is to then proceed with\na similar transformation of LAPACK, but I am just beginning this and\nunless someone else is excited about it and wants to join in this is a\nrainy-day project at this point, and should not be considered stable . I would love to hear from anyone who tries this as a replacement for\ntheir current libblas.a or libregblas.a. Documentation A WIP (work in progress) All documents are contained in the docs/ directory including\narchive files of man(1) pages that can be installed on ULS\n(Unix-Like Systems). man-pages in HTML format amalgamated man-pages (requires Javascript) can easily be printed as a single document. ford(1) output doxygen(1) output real man-pages manpages.zip manpages.tgz Download and Build gmake bash\n       git clone https://github.com/urbanjost/M_blas.git\n       cd M_blas/src\n       # change Makefile compiler information as appropriate in Makefile\n       make # for gfortran This will compile the M_blas module and test programs. fpm Alternatively, download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_blas.git\n        cd M_blas\n        # currently the tests are run from a script because they need redirection\n        # and I want some timing information and to test multiple compilers. You\n        # will have to make your own run script or run the tests manually if you\n        # do not have bash(1).\n        #\n        # Take out or add the compilers from run.sh you wish to run then execute\n        # the run.sh(1) script, twice if you just want run-times:\n        bash run.sh\n        # or just run \"fpm build\". or just list it as a dependency in your fpm.toml project file. [dependencies] M_blas = { git = \"https://github.com/urbanjost/M_blas.git\" } References There is an fpm version of the reference BLAS library available. See the homepage for BLAS for more detailed information. CHANGELOG — Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"xerbla_interface – M_blas","text":"abstract interface public  subroutine xerbla_interface(srname, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(in) :: info","tags":"","loc":"interface/xerbla_interface.html"},{"title":"CDOTC – M_blas","text":"function CDOTC(N, CX, INCX, CY, INCY) Uses M_blas \\brief \\b CDOTC\n\\par Purpose: \\verbatim CDOTC forms the dot product of two complex vectors\n     CDOTC = X&#94;H * Y \\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim \\param[in] CY\n\\verbatim\n         CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of CY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack,  3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX complex :: CY (*) integer :: INCY Return Value complex Contents Source Code CDOTC Source Code COMPLEX FUNCTION CDOTC ( N , CX , INCX , CY , INCY ) ! COMMENT --file cdotc.3m_blas.man !> \\brief \\b CDOTC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX FUNCTION CDOTC(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CDOTC forms the dot product of two complex vectors !>      CDOTC = X&#94;H * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack,  3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : cdotc_ => CDOTC implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) cdotc = CDOTC_ ( N , CX , INCX , CY , INCY ) END FUNCTION CDOTC","tags":"","loc":"proc/cdotc.html"},{"title":"CDOTU – M_blas","text":"function CDOTU(N, CX, INCX, CY, INCY) Uses M_blas \\brief \\b CDOTU\n\\par Purpose: \\verbatim CDOTU forms the dot product of two complex vectors\n     CDOTU = X&#94;T * Y \\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim \\param[in] CY\n\\verbatim\n         CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of CY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX complex :: CY (*) integer :: INCY Return Value complex Contents Source Code CDOTU Source Code COMPLEX FUNCTION CDOTU ( N , CX , INCX , CY , INCY ) ! COMMENT --file cdotu.3m_blas.man !> \\brief \\b CDOTU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX FUNCTION CDOTU(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CDOTU forms the dot product of two complex vectors !>      CDOTU = X&#94;T * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : cdotu_ => CDOTU implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) cdotu = CDOTU_ ( N , CX , INCX , CY , INCY ) END FUNCTION CDOTU","tags":"","loc":"proc/cdotu.html"},{"title":"DASUM – M_blas","text":"function DASUM(N, DX, INCX) Uses M_blas \\brief \\b DASUM\n\\par Purpose: \\verbatim DASUM takes the sum of the absolute values.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX Return Value doubleprecision Contents Source Code DASUM Source Code DOUBLE PRECISION FUNCTION DASUM ( N , DX , INCX ) ! COMMENT --file dasum.3m_blas.man !> \\brief \\b DASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DASUM takes the sum of the absolute values. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dasum_ => DASUM implicit none INTEGER INCX , N DOUBLE PRECISION DX ( * ) dasum = DASUM_ ( N , DX , INCX ) END FUNCTION DASUM","tags":"","loc":"proc/dasum.html"},{"title":"DCABS1 – M_blas","text":"function DCABS1(Z) Uses M_blas \\brief \\b DCABS1\n\\par Purpose: \\verbatim DCABS1 computes |Re(.)| + |Im(.)| of a double complex number\n\\endverbatim\n\\param[in] Z\n\\verbatim\n         Z is COMPLEX*16\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1 Arguments Type Intent Optional Attributes Name complex(kind=16) :: Z Return Value doubleprecision Contents Source Code DCABS1 Source Code DOUBLE PRECISION FUNCTION DCABS1 ( Z ) ! COMMENT --file dcabs1.3m_blas.man !> \\brief \\b DCABS1 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DCABS1(Z) ! !       .. Scalar Arguments .. !       COMPLEX*16 Z !       .. !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DCABS1 computes |Re(.)| + |Im(.)| of a double complex number !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] Z !> \\verbatim !>          Z is COMPLEX*16 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. !  ===================================================================== ! !     .. Intrinsic Functions .. ! ! END use M_blas , only : dcabs1_ => DCABS1 implicit none COMPLEX * 16 Z dcabs1 = DCABS1_ ( Z ) END FUNCTION DCABS1","tags":"","loc":"proc/dcabs1.html"},{"title":"DDOT – M_blas","text":"function DDOT(N, DX, INCX, DY, INCY) Uses M_blas \\brief \\b DDOT\n\\par Purpose: \\verbatim DDOT forms the dot product of two vectors.\n   uses unrolled loops for increments equal to one.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[in] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY Return Value doubleprecision Contents Source Code DDOT Source Code DOUBLE PRECISION FUNCTION DDOT ( N , DX , INCX , DY , INCY ) ! COMMENT --file ddot.3m_blas.man !> \\brief \\b DDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DDOT forms the dot product of two vectors. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : ddot_ => DDOT implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) ddot = DDOT_ ( N , DX , INCX , DY , INCY ) END FUNCTION DDOT","tags":"","loc":"proc/ddot.html"},{"title":"DNRM2 – M_blas","text":"function DNRM2(N, X, INCX) Uses M_blas \\brief \\b DNRM2\n\\par Purpose: \\verbatim DNRM2 returns the euclidean norm of a vector via the function\nname, so that DNRM2 := sqrt( x’*x )\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim – This version written on 25-October-1982.\n    Modified on 14-October-1993 to inline the call to DLASSQ.\n    Sven Hammarling, Nag Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: X (*) integer :: INCX Return Value doubleprecision Contents Source Code DNRM2 Source Code DOUBLE PRECISION FUNCTION DNRM2 ( N , X , INCX ) ! COMMENT --file dnrm2.3m_blas.man !> \\brief \\b DNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    DNRM2 := sqrt( x'*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to DLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL DLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of DNRM2. ! ! END use M_blas , only : dnrm2_ => DNRM2 implicit none INTEGER INCX , N DOUBLE PRECISION X ( * ) dnrm2 = DNRM2_ ( N , X , INCX ) END FUNCTION DNRM2","tags":"","loc":"proc/dnrm2.html"},{"title":"DSDOT – M_blas","text":"function DSDOT(N, SX, INCX, SY, INCY) Uses M_blas \\brief \\b DSDOT\n\\par Purpose: \\verbatim Compute the inner product of two vectors with extended\nprecision accumulation and result. Returns D.P. dot product accumulated in D.P., for S.P. SX and SY\nDSDOT = sum for I = 0 to N-1 of  SX(LX+I INCX) * SY(LY+I INCY),\nwhere LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is\ndefined in a similar way using INCY.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension(N)\n        single precision vector with N elements\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n         storage spacing between elements of SX\n\\endverbatim \\param[in] SY\n\\verbatim\n         SY is REAL array, dimension(N)\n        single precision vector with N elements\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim \\result DSDOT\n\\verbatim\n         DSDOT is DOUBLE PRECISION\n        DSDOT  double precision dot product (zero if N.LE.0)\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim\n\\endverbatim\n\\par References: \\verbatim C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.\n Krogh, Basic linear algebra subprograms for Fortran\n usage, Algorithm No. 539, Transactions on Mathematical\n Software 5, 3 (September 1979), pp. 308-323. REVISION HISTORY  (YYMMDD) 791001  DATE WRITTEN\n 890831  Modified array declarations.  (WRB)\n 890831  REVISION DATE from Version 3.2\n 891214  Prologue converted to Version 4.0 format.  (BAB)\n 920310  Corrected definition of LX in DESCRIPTION.  (WRB)\n 920501  Reformatted the REFERENCES section.  (WRB)\n 070118  Reformat to LAPACK style (JL)\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Return Value doubleprecision Contents Source Code DSDOT Source Code DOUBLE PRECISION FUNCTION DSDOT ( N , SX , INCX , SY , INCY ) ! COMMENT --file dsdot.3m_blas.man !> \\brief \\b DSDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DSDOT(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! !    AUTHORS !    ======= !    Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !    Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> Compute the inner product of two vectors with extended !> precision accumulation and result. !> !> Returns D.P. dot product accumulated in D.P., for S.P. SX and SY !> DSDOT = sum for I = 0 to N-1 of  SX(LX+I*INCX) * SY(LY+I*INCY), !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !> defined in a similar way using INCY. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension(N) !>         single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>          storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension(N) !>         single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\result DSDOT !> \\verbatim !>          DSDOT is DOUBLE PRECISION !>         DSDOT  double precision dot product (zero if N.LE.0) !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> \\endverbatim ! !> \\par References: !  ================ !> !> \\verbatim !> !> !>  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !>  Krogh, Basic linear algebra subprograms for Fortran !>  usage, Algorithm No. 539, Transactions on Mathematical !>  Software 5, 3 (September 1979), pp. 308-323. !> !>  REVISION HISTORY  (YYMMDD) !> !>  791001  DATE WRITTEN !>  890831  Modified array declarations.  (WRB) !>  890831  REVISION DATE from Version 3.2 !>  891214  Prologue converted to Version 4.0 format.  (BAB) !>  920310  Corrected definition of LX in DESCRIPTION.  (WRB) !>  920501  Reformatted the REFERENCES section.  (WRB) !>  070118  Reformat to LAPACK style (JL) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  Authors: !  ======== !  Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !  Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Code for equal, positive, non-unit increments. ! ! !     Code for unequal or nonpositive increments. ! ! END use M_blas , only : dsdot_ => DSDOT implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) dsdot = DSDOT_ ( N , SX , INCX , SY , INCY ) END FUNCTION DSDOT","tags":"","loc":"proc/dsdot.html"},{"title":"DZASUM – M_blas","text":"function DZASUM(N, ZX, INCX) Uses M_blas \\brief \\b DZASUM\n\\par Purpose: \\verbatim DZASUM takes the sum of the (|Re(.)| + |Im(.)|)’s of a complex vector and\n   returns a double precision result.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX Return Value doubleprecision Contents Source Code DZASUM Source Code DOUBLE PRECISION FUNCTION DZASUM ( N , ZX , INCX ) ! COMMENT --file dzasum.3m_blas.man !> \\brief \\b DZASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DZASUM(N,ZX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !>    returns a double precision result. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dzasum_ => DZASUM implicit none INTEGER INCX , N COMPLEX * 16 ZX ( * ) dzasum = DZASUM_ ( N , ZX , INCX ) END FUNCTION DZASUM","tags":"","loc":"proc/dzasum.html"},{"title":"DZNRM2 – M_blas","text":"function DZNRM2(N, X, INCX) Uses M_blas \\brief \\b DZNRM2\n\\par Purpose: \\verbatim DZNRM2 returns the euclidean norm of a vector via the function\nname, so that DZNRM2 := sqrt( x* H x )\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX*16 array, dimension (N)\n        complex vector with N elements\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of X\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim – This version written on 25-October-1982.\n    Modified on 14-October-1993 to inline the call to ZLASSQ.\n    Sven Hammarling, Nag Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: X (*) integer :: INCX Return Value doubleprecision Contents Source Code DZNRM2 Source Code DOUBLE PRECISION FUNCTION DZNRM2 ( N , X , INCX ) ! COMMENT --file dznrm2.3m_blas.man !> \\brief \\b DZNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DZNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DZNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    DZNRM2 := sqrt( x**H*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension (N) !>         complex vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of X !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to ZLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL ZLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of DZNRM2. ! ! END use M_blas , only : dznrm2_ => DZNRM2 implicit none INTEGER INCX , N COMPLEX * 16 X ( * ) dznrm2 = DZNRM2_ ( N , X , INCX ) END FUNCTION DZNRM2","tags":"","loc":"proc/dznrm2.html"},{"title":"ICAMAX – M_blas","text":"function ICAMAX(N, CX, INCX) Uses M_blas \\brief \\b ICAMAX\n\\par Purpose: \\verbatim ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup aux_blas\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX Return Value integer Contents Source Code ICAMAX Source Code INTEGER FUNCTION ICAMAX ( N , CX , INCX ) ! COMMENT --file icamax.3m_blas.man !> \\brief \\b ICAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION ICAMAX(N,CX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : icamax_ => ICAMAX implicit none INTEGER INCX , N COMPLEX CX ( * ) icamax = ICAMAX_ ( N , CX , INCX ) END FUNCTION ICAMAX","tags":"","loc":"proc/icamax.html"},{"title":"IDAMAX – M_blas","text":"function IDAMAX(N, DX, INCX) Uses M_blas \\brief \\b IDAMAX\n\\par Purpose: \\verbatim IDAMAX finds the index of the first element having maximum absolute value.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup aux_blas\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX Return Value integer Contents Source Code IDAMAX Source Code INTEGER FUNCTION IDAMAX ( N , DX , INCX ) ! COMMENT --file idamax.3m_blas.man !> \\brief \\b IDAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION IDAMAX(N,DX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    IDAMAX finds the index of the first element having maximum absolute value. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : idamax_ => IDAMAX implicit none INTEGER INCX , N DOUBLE PRECISION DX ( * ) idamax = IDAMAX_ ( N , DX , INCX ) END FUNCTION IDAMAX","tags":"","loc":"proc/idamax.html"},{"title":"ISAMAX – M_blas","text":"function ISAMAX(N, SX, INCX) Uses M_blas \\brief \\b ISAMAX\n\\par Purpose: \\verbatim ISAMAX finds the index of the first element having maximum absolute value.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup aux_blas\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX Return Value integer Contents Source Code ISAMAX Source Code INTEGER FUNCTION ISAMAX ( N , SX , INCX ) ! COMMENT --file isamax.3m_blas.man !> \\brief \\b ISAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION ISAMAX(N,SX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ISAMAX finds the index of the first element having maximum absolute value. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : isamax_ => ISAMAX implicit none INTEGER INCX , N REAL SX ( * ) isamax = ISAMAX_ ( N , SX , INCX ) END FUNCTION ISAMAX","tags":"","loc":"proc/isamax.html"},{"title":"IZAMAX – M_blas","text":"function IZAMAX(N, ZX, INCX) Uses M_blas \\brief \\b IZAMAX\n\\par Purpose: \\verbatim IZAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup aux_blas\n\\par Further Details: \\verbatim jack dongarra , 1 / 15 / 85 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX Return Value integer Contents Source Code IZAMAX Source Code INTEGER FUNCTION IZAMAX ( N , ZX , INCX ) ! COMMENT --file izamax.3m_blas.man !> \\brief \\b IZAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION IZAMAX(N,ZX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    IZAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 1/15/85. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : izamax_ => IZAMAX implicit none INTEGER INCX , N COMPLEX * 16 ZX ( * ) izamax = IZAMAX_ ( N , ZX , INCX ) END FUNCTION IZAMAX","tags":"","loc":"proc/izamax.html"},{"title":"LSAME – M_blas","text":"function LSAME(CA, CB) Uses M_blas \\brief \\b LSAME\n\\par Purpose: \\verbatim LSAME returns .TRUE. if CA is the same letter as CB regardless of\ncase.\n\\endverbatim\n\\param[in] CA\n\\verbatim\n         CA is CHARACTER*1\n\\endverbatim \\param[in] CB\n\\verbatim\n         CB is CHARACTER*1\n         CA and CB specify the single characters to be compared.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup aux_blas Arguments Type Intent Optional Attributes Name character(len=1) :: CA character(len=1) :: CB Return Value logical Contents Source Code LSAME Source Code LOGICAL FUNCTION LSAME ( CA , CB ) ! COMMENT --file lsame.3m_blas.man !> \\brief \\b LSAME ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       LOGICAL FUNCTION LSAME(CA,CB) ! !       .. Scalar Arguments .. !       CHARACTER CA,CB !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> LSAME returns .TRUE. if CA is the same letter as CB regardless of !> case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] CA !> \\verbatim !>          CA is CHARACTER*1 !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is CHARACTER*1 !>          CA and CB specify the single characters to be compared. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. ! ! ===================================================================== ! !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. ! !     Test if the characters are equal ! ! !     Now test for equivalence if both characters are alphabetic. ! ! !     Use 'Z' rather than 'A' so that ASCII can be detected on Prime !     machines, on which ICHAR returns a value with bit 8 set. !     ICHAR('A') on Prime machines returns 193 which is the same as !     ICHAR('A') on an EBCDIC machine. ! ! ! !        ASCII is assumed - ZCODE is the ASCII code of either lower or !        upper case 'Z'. ! ! ! !        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or !        upper case 'Z'. ! ! ! !        ASCII is assumed, on Prime machines - ZCODE is the ASCII code !        plus 128 of either lower or upper case 'Z'. ! ! !     RETURN ! !     End of LSAME ! ! END use M_blas , only : lsame_ => LSAME implicit none CHARACTER CA , CB lsame = LSAME_ ( CA , CB ) END FUNCTION LSAME","tags":"","loc":"proc/lsame.html"},{"title":"SASUM – M_blas","text":"function SASUM(N, SX, INCX) Uses M_blas \\brief \\b SASUM\n\\par Purpose: \\verbatim SASUM takes the sum of the absolute values.\n   uses unrolled loops for increment equal to one.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX Return Value real Contents Source Code SASUM Source Code REAL FUNCTION SASUM ( N , SX , INCX ) ! COMMENT --file sasum.3m_blas.man !> \\brief \\b SASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SASUM(N,SX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SASUM takes the sum of the absolute values. !>    uses unrolled loops for increment equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : sasum_ => SASUM implicit none INTEGER INCX , N REAL SX ( * ) sasum = SASUM_ ( N , SX , INCX ) END FUNCTION SASUM","tags":"","loc":"proc/sasum.html"},{"title":"scabs1 – M_blas","text":"function scabs1(z) Uses M_blas \\brief \\b SCABS1\n\\par Purpose: \\verbatim SCABS1 computes |Re(.)| + |Im(.)| of a complex number\n\\endverbatim\n\\param[in] Z\n\\verbatim\n         Z is COMPLEX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1 Arguments Type Intent Optional Attributes Name complex, intent(in) :: z Return Value real Contents Source Code scabs1 Source Code real function scabs1 ( z ) ! COMMENT --file scabs1.3m_blas.man !> \\brief \\b SCABS1 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCABS1(Z) ! !       .. Scalar Arguments .. !       COMPLEX Z !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SCABS1 computes |Re(.)| + |Im(.)| of a complex number !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] Z !> \\verbatim !>          Z is COMPLEX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : scabs1_ => SCAbs1 implicit none complex , intent ( in ) :: z scabs1 = scabs1_ ( z ) end function scabs1","tags":"","loc":"proc/scabs1.html"},{"title":"SCASUM – M_blas","text":"function SCASUM(N, CX, INCX) Uses M_blas \\brief \\b SCASUM\n\\par Purpose: \\verbatim SCASUM takes the sum of the (|Re(.)| + |Im(.)|)’s of a complex vector and\n   returns a single precision result.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX Return Value real Contents Source Code SCASUM Source Code REAL FUNCTION SCASUM ( N , CX , INCX ) ! COMMENT --file scasum.3m_blas.man !> \\brief \\b SCASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCASUM(N,CX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !>    returns a single precision result. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : scasum_ => SCASUM implicit none INTEGER INCX , N COMPLEX CX ( * ) scasum = SCASUM_ ( N , CX , INCX ) END FUNCTION SCASUM","tags":"","loc":"proc/scasum.html"},{"title":"SCNRM2 – M_blas","text":"function SCNRM2(N, X, INCX) Uses M_blas \\brief \\b SCNRM2\n\\par Purpose: \\verbatim SCNRM2 returns the euclidean norm of a vector via the function\nname, so that SCNRM2 := sqrt( x* H x )\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension (N)\n        complex vector with N elements\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of X\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim – This version written on 25-October-1982.\n    Modified on 14-October-1993 to inline the call to CLASSQ.\n    Sven Hammarling, Nag Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: X (*) integer :: INCX Return Value real Contents Source Code SCNRM2 Source Code REAL FUNCTION SCNRM2 ( N , X , INCX ) ! COMMENT --file scnrm2.3m_blas.man !> \\brief \\b SCNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SCNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    SCNRM2 := sqrt( x**H*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension (N) !>         complex vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of X !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to CLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL CLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of SCNRM2. ! ! END use M_blas , only : scnrm2_ => SCNRM2 implicit none INTEGER INCX , N COMPLEX X ( * ) scnrm2 = SCNRM2_ ( N , X , INCX ) END FUNCTION SCNRM2","tags":"","loc":"proc/scnrm2.html"},{"title":"SDOT – M_blas","text":"function SDOT(N, SX, INCX, SY, INCY) Uses M_blas \\brief \\b SDOT\n\\par Purpose: \\verbatim SDOT forms the dot product of two vectors.\n   uses unrolled loops for increments equal to one.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[in] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Return Value real Contents Source Code SDOT Source Code REAL FUNCTION SDOT ( N , SX , INCX , SY , INCY ) ! COMMENT --file sdot.3m_blas.man !> \\brief \\b SDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SDOT(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SDOT forms the dot product of two vectors. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : sdot_ => SDOT implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) sdot = SDOT_ ( N , SX , INCX , SY , INCY ) END FUNCTION SDOT","tags":"","loc":"proc/sdot.html"},{"title":"SDSDOT – M_blas","text":"function SDSDOT(N, SB, SX, INCX, SY, INCY) Uses M_blas \\brief \\b SDSDOT\n\\par Purpose: \\verbatim Compute the inner product of two vectors with extended\n  precision accumulation. Returns S.P. result with dot product accumulated in D.P.\n  SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I INCX) SY(LY+I INCY),\n  where LX = 1 if INCX .GE. 0, else LX = 1+(1-N) INCX, and LY is\n  defined in a similar way using INCY.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n         number of elements in input vector(s)\n\\endverbatim \\param[in] SB\n\\verbatim\n         SB is REAL\n         single precision scalar to be added to inner product\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n         single precision vector with N elements\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n         storage spacing between elements of SX\n\\endverbatim \\param[in] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n         single precision vector with N elements\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n         storage spacing between elements of SY\n\\endverbatim\n\\author Lawson, C. L., (JPL), Hanson, R. J., (SNLA),\n\\author Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL)\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim REFERENCES C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.\n   Krogh, Basic linear algebra subprograms for Fortran\n   usage, Algorithm No. 539, Transactions on Mathematical\n   Software 5, 3 (September 1979), pp. 308-323. REVISION HISTORY  (YYMMDD) 791001  DATE WRITTEN\n   890531  Changed all specific intrinsics to generic.  (WRB)\n   890831  Modified array declarations.  (WRB)\n   890831  REVISION DATE from Version 3.2\n   891214  Prologue converted to Version 4.0 format.  (BAB)\n   920310  Corrected definition of LX in DESCRIPTION.  (WRB)\n   920501  Reformatted the REFERENCES section.  (WRB)\n   070118  Reformat to LAPACK coding style\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SB real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Return Value real Contents Source Code SDSDOT Source Code REAL FUNCTION SDSDOT ( N , SB , SX , INCX , SY , INCY ) ! COMMENT --file sdsdot.3m_blas.man !> \\brief \\b SDSDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SDSDOT(N,SB,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       REAL SB !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>   Compute the inner product of two vectors with extended !>   precision accumulation. !> !>   Returns S.P. result with dot product accumulated in D.P. !>   SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I*INCX)*SY(LY+I*INCY), !>   where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !>   defined in a similar way using INCY. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>          number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SB !> \\verbatim !>          SB is REAL !>          single precision scalar to be added to inner product !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !>          single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>          storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !>          single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>          storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !> \\author Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>    REFERENCES !> !>    C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !>    Krogh, Basic linear algebra subprograms for Fortran !>    usage, Algorithm No. 539, Transactions on Mathematical !>    Software 5, 3 (September 1979), pp. 308-323. !> !>    REVISION HISTORY  (YYMMDD) !> !>    791001  DATE WRITTEN !>    890531  Changed all specific intrinsics to generic.  (WRB) !>    890831  Modified array declarations.  (WRB) !>    890831  REVISION DATE from Version 3.2 !>    891214  Prologue converted to Version 4.0 format.  (BAB) !>    920310  Corrected definition of LX in DESCRIPTION.  (WRB) !>    920501  Reformatted the REFERENCES section.  (WRB) !>    070118  Reformat to LAPACK coding style !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Code for equal and positive increments. ! ! !     Code for unequal or nonpositive increments. ! ! END use M_blas , only : sdsdot_ => SDSDOT implicit none REAL SB INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) sdsdot = SDSDOT_ ( N , SB , SX , INCX , SY , INCY ) END FUNCTION SDSDOT","tags":"","loc":"proc/sdsdot.html"},{"title":"SNRM2 – M_blas","text":"function SNRM2(N, X, INCX) Uses M_blas \\brief \\b SNRM2\n\\par Purpose: \\verbatim SNRM2 returns the euclidean norm of a vector via the function\nname, so that SNRM2 := sqrt( x’*x ).\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim – This version written on 25-October-1982.\n    Modified on 14-October-1993 to inline the call to SLASSQ.\n    Sven Hammarling, Nag Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: X (*) integer :: INCX Return Value real Contents Source Code SNRM2 Source Code REAL FUNCTION SNRM2 ( N , X , INCX ) ! COMMENT --file snrm2.3m_blas.man !> \\brief \\b SNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    SNRM2 := sqrt( x'*x ). !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to SLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL SLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of SNRM2. ! ! END use M_blas , only : snrm2_ => SNRM2 implicit none INTEGER INCX , N REAL X ( * ) snrm2 = SNRM2_ ( N , X , INCX ) END FUNCTION SNRM2","tags":"","loc":"proc/snrm2.html"},{"title":"ZDOTC – M_blas","text":"function ZDOTC(N, ZX, INCX, ZY, INCY) Uses M_blas \\brief \\b ZDOTC\n\\par Purpose: \\verbatim ZDOTC forms the dot product of two complex vectors\n     ZDOTC = X&#94;H * Y \\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim \\param[in] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of ZY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY Return Value complex(kind=16) Contents Source Code ZDOTC Source Code COMPLEX * 16 FUNCTION ZDOTC ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zdotc.3m_blas.man !> \\brief \\b ZDOTC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX*16 FUNCTION ZDOTC(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZDOTC forms the dot product of two complex vectors !>      ZDOTC = X&#94;H * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zdotc_ => ZDOTC implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) zdotc = ZDOTC_ ( N , ZX , INCX , ZY , INCY ) END FUNCTION ZDOTC","tags":"","loc":"proc/zdotc.html"},{"title":"ZDOTU – M_blas","text":"function ZDOTU(N, ZX, INCX, ZY, INCY) Uses M_blas \\brief \\b ZDOTU\n\\par Purpose: \\verbatim ZDOTU forms the dot product of two complex vectors\n     ZDOTU = X&#94;T * Y \\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim \\param[in] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of ZY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY Return Value complex(kind=16) Contents Source Code ZDOTU Source Code COMPLEX * 16 FUNCTION ZDOTU ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zdotu.3m_blas.man !> \\brief \\b ZDOTU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX*16 FUNCTION ZDOTU(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZDOTU forms the dot product of two complex vectors !>      ZDOTU = X&#94;T * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zdotu_ => ZDOTU implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) zdotu = ZDOTU_ ( N , ZX , INCX , ZY , INCY ) END FUNCTION ZDOTU","tags":"","loc":"proc/zdotu.html"},{"title":"caxpy – M_blas","text":"subroutine caxpy(n, ca, cx, incx, cy, incy) Uses M_blas \\brief \\b CAXPY\n\\par Purpose: \\verbatim CAXPY constant times a vector plus a vector.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CA\n\\verbatim\n         CA is COMPLEX\n          On entry, CA specifies the scalar alpha.\n\\endverbatim \\param[in] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim \\param[in,out] CY\n\\verbatim\n         CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of CY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: n complex :: ca complex :: cx (*) integer :: incx complex :: cy (*) integer :: incy Contents Source Code caxpy Source Code subroutine caxpy ( n , ca , cx , incx , cy , incy ) ! COMMENT --file caxpy.3m_blas.man !> \\brief \\b CAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CAXPY(N,CA,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       COMPLEX CA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CAXPY constant times a vector plus a vector. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CA !> \\verbatim !>          CA is COMPLEX !>           On entry, CA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! ! END use m_blas , only : caxpy_ => caxpy implicit none complex :: ca integer :: incx , incy , n complex :: cx ( * ) complex :: cy ( * ) call caxpy_ ( n , ca , cx , incx , cy , incy ) end subroutine caxpy","tags":"","loc":"proc/caxpy.html"},{"title":"CCOPY – M_blas","text":"subroutine CCOPY(N, CX, INCX, CY, INCY) Uses M_blas \\brief \\b CCOPY\n\\par Purpose: \\verbatim CCOPY copies a vector x to a vector y.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim \\param[out] CY\n\\verbatim\n         CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of CY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX complex :: CY (*) integer :: INCY Contents Source Code CCOPY Source Code subroutine CCOPY ( N , CX , INCX , CY , INCY ) ! COMMENT --file ccopy.3m_blas.man !> \\brief \\b CCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CCOPY(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CCOPY copies a vector x to a vector y. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : ccopy_ => CCOPY implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) call CCOPY_ ( N , CX , INCX , CY , INCY ) end subroutine CCOPY","tags":"","loc":"proc/ccopy.html"},{"title":"CGBMV – M_blas","text":"subroutine CGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b CGBMV\n\\par Purpose: \\verbatim CGBMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y,   or y := alpha A H x + beta*y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n band matrix, with kl sub-diagonals and ku super-diagonals.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] KL\n\\verbatim\n         KL is INTEGER\n          On entry, KL specifies the number of sub-diagonals of the\n          matrix A. KL must satisfy  0 .le. KL.\n\\endverbatim \\param[in] KU\n\\verbatim\n         KU is INTEGER\n          On entry, KU specifies the number of super-diagonals of the\n          matrix A. KU must satisfy  0 .le. KU.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry, the leading ( kl + ku + 1 ) by n part of the\n          array A must contain the matrix of coefficients, supplied\n          column by column, with the leading diagonal of the matrix in\n          row ( ku + 1 ) of the array, the first super-diagonal\n          starting at position 2 in row ku, the first sub-diagonal\n          starting at position 1 in row ( ku + 2 ), and so on.\n          Elements in the array A that do not correspond to elements\n          in the band matrix (such as the top left ku by ku triangle)\n          are not referenced.\n          The following program segment will transfer a band matrix\n          from conventional full matrix storage to band storage: DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( kl + ku + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N integer :: KL integer :: KU complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX complex :: BETA complex :: Y (*) integer :: INCY Contents Source Code CGBMV Source Code subroutine CGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file cgbmv.3m_blas.man !> \\brief \\b CGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of CGBMV . ! ! END use M_blas , only : cgbmv_ => CGBMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CGBMV","tags":"","loc":"proc/cgbmv.html"},{"title":"CGEMM – M_blas","text":"subroutine CGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b CGEMM\n\\par Purpose: \\verbatim CGEMM  performs one of the matrix-matrix operations C := alpha op( A ) op( B ) + beta*C, where  op( X ) is one of op( X ) = X   or   op( X ) = X T   or   op( X ) = X H, alpha and beta are scalars, and A, B and C are matrices, with op( A )\nan m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n\\endverbatim\n\\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n',  op( A ) = A.\n\n         TRANSA = 'T' or 't',  op( A ) = A**T.\n\n         TRANSA = 'C' or 'c',  op( A ) = A**H. \\endverbatim \\param[in] TRANSB\n\\verbatim\n         TRANSB is CHARACTER*1\n          On entry, TRANSB specifies the form of op( B ) to be used in\n          the matrix multiplication as follows: TRANSB = 'N' or 'n',  op( B ) = B.\n\n         TRANSB = 'T' or 't',  op( B ) = B**T.\n\n         TRANSB = 'C' or 'c',  op( B ) = B**H. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies  the number  of rows  of the  matrix\n          op( A )  and of the  matrix  C.  M  must  be at least  zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N  specifies the number  of columns of the matrix\n          op( B ) and the number of columns of the matrix C. N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry,  K  specifies  the number of columns of the matrix\n          op( A ) and the number of rows of the matrix op( B ). K must\n          be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          k  when  TRANSA = ‘N’ or ‘n’,  and is  m  otherwise.\n          Before entry with  TRANSA = ‘N’ or ‘n’,  the leading  m by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by m  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. When  TRANSA = ‘N’ or ‘n’ then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, kb ), where kb is\n          n  when  TRANSB = ‘N’ or ‘n’,  and is  k  otherwise.\n          Before entry with  TRANSB = ‘N’ or ‘n’,  the leading  k by n\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  n by k  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in the calling (sub) program. When  TRANSB = ‘N’ or ‘n’ then\n          LDB must be at least  max( 1, k ), otherwise  LDB must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n  matrix\n          ( alpha op( A ) op( B ) + beta*C ).\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANSA character(len=1) :: TRANSB integer :: M integer :: N integer :: K complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB complex :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CGEMM Source Code subroutine CGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file cgemm.3m_blas.man !> \\brief \\b CGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**H. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**H. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and  NROWB  as the number of rows of  A  and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**H*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**H + beta*C. ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**H*B**H + beta*C. ! ! !           Form  C := alpha*A**H*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**H + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of CGEMM . ! ! END use M_blas , only : cgemm_ => CGEMM implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CGEMM","tags":"","loc":"proc/cgemm.html"},{"title":"CGEMV – M_blas","text":"subroutine CGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b CGEMV\n\\par Purpose: \\verbatim CGEMV performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y,   or y := alpha A H x + beta*y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry with BETA non-zero, the incremented array Y\n          must contain the vector y. On exit, Y is overwritten by the\n          updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX complex :: BETA complex :: Y (*) integer :: INCY Contents Source Code CGEMV Source Code subroutine CGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file cgemv.3m_blas.man !> \\brief \\b CGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGEMV performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of CGEMV . ! ! END use M_blas , only : cgemv_ => CGEMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CGEMV","tags":"","loc":"proc/cgemv.html"},{"title":"CGERC – M_blas","text":"subroutine CGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b CGERC\n\\par Purpose: \\verbatim CGERC  performs the rank 1 operation A := alpha x y**H + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( m - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N complex :: ALPHA complex :: X (*) integer :: INCX complex :: Y (*) integer :: INCY complex :: A (LDA,*) integer :: LDA Contents Source Code CGERC Source Code subroutine CGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cgerc.3m_blas.man !> \\brief \\b CGERC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGERC(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGERC  performs the rank 1 operation !> !>    A := alpha*x*y**H + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of CGERC . ! ! END use M_blas , only : cgerc_ => CGERC implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGERC_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CGERC","tags":"","loc":"proc/cgerc.html"},{"title":"CGERU – M_blas","text":"subroutine CGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b CGERU\n\\par Purpose: \\verbatim CGERU  performs the rank 1 operation A := alpha x y**T + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( m - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N complex :: ALPHA complex :: X (*) integer :: INCX complex :: Y (*) integer :: INCY complex :: A (LDA,*) integer :: LDA Contents Source Code CGERU Source Code subroutine CGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cgeru.3m_blas.man !> \\brief \\b CGERU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGERU(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGERU  performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of CGERU . ! ! END use M_blas , only : cgeru_ => CGERU implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGERU_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CGERU","tags":"","loc":"proc/cgeru.html"},{"title":"CHBMV – M_blas","text":"subroutine CHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b CHBMV\n\\par Purpose: \\verbatim CHBMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian band matrix, with k super-diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the band matrix A is being supplied as\n          follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             being supplied.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             being supplied. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry, K specifies the number of super-diagonals of the\n          matrix A. K must satisfy  0 .le. K.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the hermitian matrix, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer the upper\n          triangular part of a hermitian band matrix from conventional\n          full matrix storage to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that the imaginary parts of the diagonal elements need not be set and are assumed to be zero . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N integer :: K complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX complex :: BETA complex :: Y (*) integer :: INCY Contents Source Code CHBMV Source Code subroutine CHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file chbmv.3m_blas.man !> \\brief \\b CHBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of CHBMV . ! ! END use M_blas , only : chbmv_ => CHBMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CHBMV","tags":"","loc":"proc/chbmv.html"},{"title":"CHEMM – M_blas","text":"subroutine CHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b CHEMM\n\\par Purpose: \\verbatim CHEMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where alpha and beta are scalars, A is an hermitian matrix and  B and\nC are m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  hermitian matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  hermitian  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             hermitian matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             hermitian matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is n  otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  hermitian matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  hermitian matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  hermitian\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  hermitian matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  hermitian matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  hermitian\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Note that the imaginary parts  of the diagonal elements need\n          not be set, they are assumed to be zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the  calling (sub) program. When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB complex :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CHEMM Source Code subroutine CHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file chemm.3m_blas.man !> \\brief \\b CHEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHEMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars, A is an hermitian matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  hermitian matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  hermitian  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  hermitian matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  hermitian matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Note that the imaginary parts  of the diagonal elements need !>           not be set, they are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of CHEMM . ! ! END use M_blas , only : chemm_ => CHEMM implicit none COMPLEX ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CHEMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CHEMM","tags":"","loc":"proc/chemm.html"},{"title":"CHEMV – M_blas","text":"subroutine CHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b CHEMV\n\\par Purpose: \\verbatim CHEMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced.\n          Note that the imaginary parts of the diagonal elements need\n          not be set and are assumed to be zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX complex :: BETA complex :: Y (*) integer :: INCY Contents Source Code CHEMV Source Code subroutine CHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file chemv.3m_blas.man !> \\brief \\b CHEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHEMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHEMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of CHEMV . ! ! END use M_blas , only : chemv_ => CHEMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHEMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CHEMV","tags":"","loc":"proc/chemv.html"},{"title":"CHER2 – M_blas","text":"subroutine CHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b CHER2\n\\par Purpose: \\verbatim CHER2  performs the hermitian rank 2 operation A := alpha x y H + conjg( alpha ) y x H + A, where alpha is a scalar, x and y are n element vectors and A is an n\nby n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex :: ALPHA complex :: X (*) integer :: INCX complex :: Y (*) integer :: INCY complex :: A (LDA,*) integer :: LDA Contents Source Code CHER2 Source Code subroutine CHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cher2.3m_blas.man !> \\brief \\b CHER2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of CHER2 . ! ! END use M_blas , only : cher2_ => CHER2 implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHER2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CHER2","tags":"","loc":"proc/cher2.html"},{"title":"CHER2K – M_blas","text":"subroutine CHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b CHER2K\n\\par Purpose: \\verbatim CHER2K  performs one of the hermitian rank 2k operations C := alpha A B H + conjg( alpha ) B A H + beta*C, or C := alpha A H B + conjg( alpha ) B H A + beta*C, where  alpha and beta  are scalars with  beta  real,  C is an  n by n\nhermitian matrix and  A and B  are  n by k matrices in the first case\nand  k by n  matrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘C’ or ‘c’,  K  specifies  the number of rows of the\n          matrices  A and B.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  hermitian matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  hermitian matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set,  they are assumed to be zero,  and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.\n    Ed Anderson, Cray Research Inc.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB real :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CHER2K Source Code subroutine CHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file cher2k.3m_blas.man !> \\brief \\b CHER2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       REAL BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER2K  performs one of the hermitian rank 2k operations !> !>    C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !> !> where  alpha and beta  are scalars with  beta  real,  C is an  n by n !> hermitian matrix and  A and B  are  n by k matrices in the first case !> and  k by n  matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**H          + !>                                         conjg( alpha )*B*A**H + !>                                         beta*C. !> !>              TRANS = 'C' or 'c'    C := alpha*A**H*B          + !>                                         conjg( alpha )*B**H*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! ! ! !     End of CHER2K. ! ! END use M_blas , only : cher2k_ => CHER2K implicit none COMPLEX ALPHA REAL BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CHER2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CHER2K","tags":"","loc":"proc/cher2k.html"},{"title":"CHER – M_blas","text":"subroutine CHER(UPLO, N, ALPHA, X, INCX, A, LDA) Uses M_blas \\brief \\b CHER\n\\par Purpose: \\verbatim CHER   performs the hermitian rank 1 operation A := alpha x x**H + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA complex :: X (*) integer :: INCX complex :: A (LDA,*) integer :: LDA Contents Source Code CHER Source Code subroutine CHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file cher.3m_blas.man !> \\brief \\b CHER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER   performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of CHER  . ! ! END use M_blas , only : cher_ => CHER implicit none REAL ALPHA INTEGER INCX , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ) call CHER_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine CHER","tags":"","loc":"proc/cher.html"},{"title":"CHERK – M_blas","text":"subroutine CHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b CHERK\n\\par Purpose: \\verbatim CHERK  performs one of the hermitian rank k operations C := alpha A A* H + beta C, or C := alpha A H A + beta*C, where  alpha and beta  are  real scalars,  C is an  n by n  hermitian\nmatrix and  A  is an  n by k  matrix in the  first case and a  k by n\nmatrix in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘C’ or ‘c’,  K  specifies  the number of rows of the\n          matrix A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  hermitian matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  hermitian matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set,  they are assumed to be zero,  and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.\n    Ed Anderson, Cray Research Inc.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K real :: ALPHA complex :: A (LDA,*) integer :: LDA real :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CHERK Source Code subroutine CHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file cherk.3m_blas.man !> \\brief \\b CHERK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHERK  performs one of the hermitian rank k operations !> !>    C := alpha*A*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*A + beta*C, !> !> where  alpha and beta  are  real scalars,  C is an  n by n  hermitian !> matrix and  A  is an  n by k  matrix in the  first case and a  k by n !> matrix in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**H + beta*C. ! ! !        Form  C := alpha*A**H*A + beta*C. ! ! ! !     End of CHERK . ! ! END use M_blas , only : cherk_ => CHERK implicit none REAL ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), C ( LDC , * ) call CHERK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine CHERK","tags":"","loc":"proc/cherk.html"},{"title":"CHPMV – M_blas","text":"subroutine CHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b CHPMV\n\\par Purpose: \\verbatim CHPMV  performs the matrix-vector operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on.\n          Note that the imaginary parts of the diagonal elements need\n          not be set and are assumed to be zero.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex :: ALPHA complex :: AP (*) complex :: X (*) integer :: INCX complex :: BETA complex :: Y (*) integer :: INCY Contents Source Code CHPMV Source Code subroutine CHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file chpmv.3m_blas.man !> \\brief \\b CHPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of CHPMV . ! ! END use M_blas , only : chpmv_ => CHPMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ), Y ( * ) call CHPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine CHPMV","tags":"","loc":"proc/chpmv.html"},{"title":"CHPR2 – M_blas","text":"subroutine CHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Uses M_blas \\brief \\b CHPR2\n\\par Purpose: \\verbatim CHPR2  performs the hermitian rank 2 operation A := alpha x y H + conjg( alpha ) y x H + A, where alpha is a scalar, x and y are n element vectors and A is an\nn by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is COMPLEX array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex :: ALPHA complex :: X (*) integer :: INCX complex :: Y (*) integer :: INCY complex :: AP (*) Contents Source Code CHPR2 Source Code subroutine CHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file chpr2.3m_blas.man !> \\brief \\b CHPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPR2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of CHPR2 . ! ! END use M_blas , only : chpr2_ => CHPR2 implicit none COMPLEX ALPHA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ), Y ( * ) call CHPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine CHPR2","tags":"","loc":"proc/chpr2.html"},{"title":"CHPR – M_blas","text":"subroutine CHPR(UPLO, N, ALPHA, X, INCX, AP) Uses M_blas \\brief \\b CHPR\n\\par Purpose: \\verbatim CHPR    performs the hermitian rank 1 operation A := alpha x x**H + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is COMPLEX array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA complex :: X (*) integer :: INCX complex :: AP (*) Contents Source Code CHPR Source Code subroutine CHPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file chpr.3m_blas.man !> \\brief \\b CHPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPR    performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of CHPR  . ! ! END use M_blas , only : chpr_ => CHPR implicit none REAL ALPHA INTEGER INCX , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ) call CHPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine CHPR","tags":"","loc":"proc/chpr.html"},{"title":"CROTG – M_blas","text":"subroutine CROTG(CA, CB, C, S) Uses M_blas \\brief \\b CROTG\n\\par Purpose: \\verbatim CROTG determines a complex Givens rotation.\n\\endverbatim\n\\param[in,out] CA\n\\verbatim\n         CA is COMPLEX\n\\endverbatim \\param[in] CB\n\\verbatim\n         CB is COMPLEX\n\\endverbatim \\param[out] C\n\\verbatim\n         C is REAL\n\\endverbatim \\param[out] S\n\\verbatim\n         S is COMPLEX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1 Arguments Type Intent Optional Attributes Name complex :: CA complex :: CB real :: C complex :: S Contents Source Code CROTG Source Code subroutine CROTG ( CA , CB , C , S ) ! COMMENT --file crotg.3m_blas.man !> \\brief \\b CROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CROTG(CA,CB,C,S) ! !       .. Scalar Arguments .. !       COMPLEX CA,CB,S !       REAL C !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CROTG determines a complex Givens rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] CA !> \\verbatim !>          CA is COMPLEX !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is COMPLEX !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is COMPLEX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : crotg_ => CROTG implicit none COMPLEX CA , CB , S REAL C call CROTG_ ( CA , CB , C , S ) end subroutine CROTG","tags":"","loc":"proc/crotg.html"},{"title":"CSCAL – M_blas","text":"subroutine CSCAL(N, CA, CX, INCX) Uses M_blas \\brief \\b CSCAL\n\\par Purpose: \\verbatim CSCAL scales a vector by a constant.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] CA\n\\verbatim\n         CA is COMPLEX\n          On entry, CA specifies the scalar alpha.\n\\endverbatim \\param[in,out] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CA complex :: CX (*) integer :: INCX Contents Source Code CSCAL Source Code subroutine CSCAL ( N , CA , CX , INCX ) ! COMMENT --file cscal.3m_blas.man !> \\brief \\b CSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSCAL(N,CA,CX,INCX) ! !       .. Scalar Arguments .. !       COMPLEX CA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CA !> \\verbatim !>          CA is COMPLEX !>           On entry, CA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack,  3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : cscal_ => CSCAL implicit none COMPLEX CA INTEGER INCX , N COMPLEX CX ( * ) call CSCAL_ ( N , CA , CX , INCX ) end subroutine CSCAL","tags":"","loc":"proc/cscal.html"},{"title":"CSROT – M_blas","text":"subroutine CSROT(N, CX, INCX, CY, INCY, C, S) Uses M_blas \\brief \\b CSROT\n\\par Purpose: \\verbatim CSROT applies a plane rotation, where the cos and sin (c and s) are real\nand the vectors cx and cy are complex.\njack dongarra, linpack, 3/11/78.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the vectors cx and cy.\n          N must be at least zero.\n\\endverbatim \\param[in,out] CX\n\\verbatim\n         CX is COMPLEX array, dimension at least\n          ( 1 + ( N - 1 )*abs( INCX ) ).\n          Before entry, the incremented array CX must contain the n\n          element vector cx. On exit, CX is overwritten by the updated\n          vector cx.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          CX. INCX must not be zero.\n\\endverbatim \\param[in,out] CY\n\\verbatim\n         CY is COMPLEX array, dimension at least\n          ( 1 + ( N - 1 )*abs( INCY ) ).\n          Before entry, the incremented array CY must contain the n\n          element vector cy. On exit, CY is overwritten by the updated\n          vector cy.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          CY. INCY must not be zero.\n\\endverbatim \\param[in] C\n\\verbatim\n         C is REAL\n          On entry, C specifies the cosine, cos.\n\\endverbatim \\param[in] S\n\\verbatim\n         S is REAL\n          On entry, S specifies the sine, sin.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level1 Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX complex :: CY (*) integer :: INCY real :: C real :: S Contents Source Code CSROT Source Code subroutine CSROT ( N , CX , INCX , CY , INCY , C , S ) ! COMMENT --file csrot.3m_blas.man !> \\brief \\b CSROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSROT( N, CX, INCX, CY, INCY, C, S ) ! !       .. Scalar Arguments .. !       INTEGER           INCX, INCY, N !       REAL              C, S !       .. !       .. Array Arguments .. !       COMPLEX           CX( * ), CY( * ) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSROT applies a plane rotation, where the cos and sin (c and s) are real !> and the vectors cx and cy are complex. !> jack dongarra, linpack, 3/11/78. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the vectors cx and cy. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCX ) ). !>           Before entry, the incremented array CX must contain the n !>           element vector cx. On exit, CX is overwritten by the updated !>           vector cx. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           CX. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCY ) ). !>           Before entry, the incremented array CY must contain the n !>           element vector cy. On exit, CY is overwritten by the updated !>           vector cy. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           CY. INCY must not be zero. !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is REAL !>           On entry, C specifies the cosine, cos. !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is REAL !>           On entry, S specifies the sine, sin. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Executable Statements .. ! ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments not equal !          to 1 ! ! END use M_blas , only : csrot_ => CSROT implicit none INTEGER INCX , INCY , N REAL C , S COMPLEX CX ( * ), CY ( * ) call CSROT_ ( N , CX , INCX , CY , INCY , C , S ) end subroutine CSROT","tags":"","loc":"proc/csrot.html"},{"title":"CSSCAL – M_blas","text":"subroutine CSSCAL(N, SA, CX, INCX) Uses M_blas \\brief \\b CSSCAL\n\\par Purpose: \\verbatim CSSCAL scales a complex vector by a real constant.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SA\n\\verbatim\n         SA is REAL\n          On entry, SA specifies the scalar alpha.\n\\endverbatim \\param[in,out] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SA complex :: CX (*) integer :: INCX Contents Source Code CSSCAL Source Code subroutine CSSCAL ( N , SA , CX , INCX ) ! COMMENT --file csscal.3m_blas.man !> \\brief \\b CSSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSSCAL(N,SA,CX,INCX) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CSSCAL scales a complex vector by a real constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : csscal_ => CSSCAL implicit none REAL SA INTEGER INCX , N COMPLEX CX ( * ) call CSSCAL_ ( N , SA , CX , INCX ) end subroutine CSSCAL","tags":"","loc":"proc/csscal.html"},{"title":"CSWAP – M_blas","text":"subroutine CSWAP(N, CX, INCX, CY, INCY) Uses M_blas \\brief \\b CSWAP\n\\par Purpose: \\verbatim CSWAP interchanges two vectors.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] CX\n\\verbatim\n         CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of CX\n\\endverbatim \\param[in,out] CY\n\\verbatim\n         CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of CY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex :: CX (*) integer :: INCX complex :: CY (*) integer :: INCY Contents Source Code CSWAP Source Code subroutine CSWAP ( N , CX , INCX , CY , INCY ) ! COMMENT --file cswap.3m_blas.man !> \\brief \\b CSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSWAP(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>   CSWAP interchanges two vectors. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : cswap_ => CSWAP implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) call CSWAP_ ( N , CX , INCX , CY , INCY ) end subroutine CSWAP","tags":"","loc":"proc/cswap.html"},{"title":"CSYMM – M_blas","text":"subroutine CSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b CSYMM\n\\par Purpose: \\verbatim CSYMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where  alpha and beta are scalars, A is a symmetric matrix and  B and\nC are m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  symmetric matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  symmetric  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             symmetric matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             symmetric matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is n  otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the  calling (sub) program. When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB complex :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CSYMM Source Code subroutine CSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file csymm.3m_blas.man !> \\brief \\b CSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where  alpha and beta are scalars, A is a symmetric matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of CSYMM . ! ! END use M_blas , only : csymm_ => CSYMM implicit none COMPLEX ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CSYMM","tags":"","loc":"proc/csymm.html"},{"title":"CSYR2K – M_blas","text":"subroutine CSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b CSYR2K\n\\par Purpose: \\verbatim CSYR2K  performs one of the symmetric rank 2k operations C := alpha A B T + alpha B A T + beta*C, or C := alpha A T B + alpha B T A + beta*C, where  alpha and beta  are scalars,  C is an  n by n symmetric matrix\nand  A and B  are  n by k  matrices  in the  first  case  and  k by n\nmatrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘T’ or ‘t’,  K  specifies  the number of rows of the\n          matrices  A and B.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB complex :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CSYR2K Source Code subroutine CSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file csyr2k.3m_blas.man !> \\brief \\b CSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !>                                         beta*C. !> !>              TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of CSYR2K. ! ! END use M_blas , only : csyr2k_ => CSYR2K implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CSYR2K","tags":"","loc":"proc/csyr2k.html"},{"title":"CSYRK – M_blas","text":"subroutine CSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b CSYRK\n\\par Purpose: \\verbatim CSYRK  performs one of the symmetric rank k operations C := alpha A A* T + beta C, or C := alpha A T A + beta*C, where  alpha and beta  are scalars,  C is an  n by n symmetric matrix\nand  A  is an  n by k  matrix in the first case and a  k by n  matrix\nin the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘T’ or ‘t’,  K  specifies  the number of rows of the\n          matrix A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: BETA complex :: C (LDC,*) integer :: LDC Contents Source Code CSYRK Source Code subroutine CSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file csyrk.3m_blas.man !> \\brief \\b CSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of CSYRK . ! ! END use M_blas , only : csyrk_ => CSYRK implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), C ( LDC , * ) call CSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine CSYRK","tags":"","loc":"proc/csyrk.html"},{"title":"CTBMV – M_blas","text":"subroutine CTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b CTBMV\n\\par Purpose: \\verbatim CTBMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular band matrix, with ( k + 1 ) diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N ).\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX Contents Source Code CTBMV Source Code subroutine CTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ctbmv.3m_blas.man !> \\brief \\b CTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ). !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTBMV . ! ! END use M_blas , only : ctbmv_ => CTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine CTBMV","tags":"","loc":"proc/ctbmv.html"},{"title":"CTBSV – M_blas","text":"subroutine CTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b CTBSV\n\\par Purpose: \\verbatim CTBSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular band matrix, with ( k + 1 )\ndiagonals. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX Contents Source Code CTBSV Source Code subroutine CTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ctbsv.3m_blas.man !> \\brief \\b CTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTBSV . ! ! END use M_blas , only : ctbsv_ => CTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine CTBSV","tags":"","loc":"proc/ctbsv.html"},{"title":"CTPMV – M_blas","text":"subroutine CTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b CTPMV\n\\par Purpose: \\verbatim CTPMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex :: AP (*) complex :: X (*) integer :: INCX Contents Source Code CTPMV Source Code subroutine CTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ctpmv.3m_blas.man !> \\brief \\b CTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTPMV . ! ! END use M_blas , only : ctpmv_ => CTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX AP ( * ), X ( * ) call CTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine CTPMV","tags":"","loc":"proc/ctpmv.html"},{"title":"CTPSV – M_blas","text":"subroutine CTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b CTPSV\n\\par Purpose: \\verbatim CTPSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex :: AP (*) complex :: X (*) integer :: INCX Contents Source Code CTPSV Source Code subroutine CTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ctpsv.3m_blas.man !> \\brief \\b CTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTPSV . ! ! END use M_blas , only : ctpsv_ => CTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX AP ( * ), X ( * ) call CTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine CTPSV","tags":"","loc":"proc/ctpsv.html"},{"title":"CTRMM – M_blas","text":"subroutine CTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b CTRMM\n\\par Purpose: \\verbatim CTRMM  performs one of the matrix-matrix operations B := alpha op( A ) B,   or   B := alpha B op( A ) where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A T   or   op( A ) = A H.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE specifies whether  op( A ) multiplies B from\n          the left or right as follows: SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**H. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, k ), where k is m\n          when  SIDE = ‘L’ or ‘l’  and is  n  when  SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, N ).\n          Before entry,  the leading  m by n part of the array  B must\n          contain the matrix  B,  and  on exit  is overwritten  by the\n          transformed matrix.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB Contents Source Code CTRMM Source Code subroutine CTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ctrmm.3m_blas.man !> \\brief \\b CTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ). !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! ! ! !     End of CTRMM . ! ! END use M_blas , only : ctrmm_ => CTRMM implicit none COMPLEX ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ) call CTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine CTRMM","tags":"","loc":"proc/ctrmm.html"},{"title":"CTRMV – M_blas","text":"subroutine CTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b CTRMV\n\\par Purpose: \\verbatim CTRMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX Contents Source Code CTRMV Source Code subroutine CTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ctrmv.3m_blas.man !> \\brief \\b CTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ). !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTRMV . ! ! END use M_blas , only : ctrmv_ => CTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine CTRMV","tags":"","loc":"proc/ctrmv.html"},{"title":"CTRSM – M_blas","text":"subroutine CTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b CTRSM\n\\par Purpose: \\verbatim CTRSM  solves one of the matrix equations op( A ) X = alpha B,   or   X op( A ) = alpha B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A T   or   op( A ) = A H. The matrix X is overwritten on B.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry, SIDE specifies whether op( A ) appears on the left\n          or right of X as follows: SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n         SIDE = 'R' or 'r'   X*op( A ) = alpha*B. \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**H. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, k ),\n          where k is m when SIDE = ‘L’ or ‘l’\n            and k is n when SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is COMPLEX array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain  the  right-hand  side  matrix  B,  and  on exit  is\n          overwritten by the solution matrix  X.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N complex :: ALPHA complex :: A (LDA,*) integer :: LDA complex :: B (LDB,*) integer :: LDB Contents Source Code CTRSM Source Code subroutine CTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ctrsm.3m_blas.man !> \\brief \\b CTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! ! ! !     End of CTRSM . ! ! END use M_blas , only : ctrsm_ => CTRSM implicit none COMPLEX ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ) call CTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine CTRSM","tags":"","loc":"proc/ctrsm.html"},{"title":"CTRSV – M_blas","text":"subroutine CTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b CTRSV\n\\par Purpose: \\verbatim CTRSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex :: A (LDA,*) integer :: LDA complex :: X (*) integer :: INCX Contents Source Code CTRSV Source Code subroutine CTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ctrsv.3m_blas.man !> \\brief \\b CTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTRSV . ! ! END use M_blas , only : ctrsv_ => CTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine CTRSV","tags":"","loc":"proc/ctrsv.html"},{"title":"DAXPY – M_blas","text":"subroutine DAXPY(N, DA, DX, INCX, DY, INCY) Uses M_blas \\brief \\b DAXPY\n\\par Purpose: \\verbatim DAXPY constant times a vector plus a vector.\n   uses unrolled loops for increments equal to one.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DA\n\\verbatim\n         DA is DOUBLE PRECISION\n          On entry, DA specifies the scalar alpha.\n\\endverbatim \\param[in] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[in,out] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DA double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY Contents Source Code DAXPY Source Code subroutine DAXPY ( N , DA , DX , INCX , DY , INCY ) ! COMMENT --file daxpy.3m_blas.man !> \\brief \\b DAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DAXPY constant times a vector plus a vector. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : daxpy_ => DAXPY implicit none DOUBLE PRECISION DA INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DAXPY_ ( N , DA , DX , INCX , DY , INCY ) end subroutine DAXPY","tags":"","loc":"proc/daxpy.html"},{"title":"DCOPY – M_blas","text":"subroutine DCOPY(N, DX, INCX, DY, INCY) Uses M_blas \\brief \\b DCOPY\n\\par Purpose: \\verbatim DCOPY copies a vector, x, to a vector, y.\n   uses unrolled loops for increments equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[out] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY Contents Source Code DCOPY Source Code subroutine DCOPY ( N , DX , INCX , DY , INCY ) ! COMMENT --file dcopy.3m_blas.man !> \\brief \\b DCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DCOPY(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DCOPY copies a vector, x, to a vector, y. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : dcopy_ => DCOPY implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DCOPY_ ( N , DX , INCX , DY , INCY ) end subroutine DCOPY","tags":"","loc":"proc/dcopy.html"},{"title":"DGBMV – M_blas","text":"subroutine DGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b DGBMV\n\\par Purpose: \\verbatim DGBMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n band matrix, with kl sub-diagonals and ku super-diagonals.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] KL\n\\verbatim\n         KL is INTEGER\n          On entry, KL specifies the number of sub-diagonals of the\n          matrix A. KL must satisfy  0 .le. KL.\n\\endverbatim \\param[in] KU\n\\verbatim\n         KU is INTEGER\n          On entry, KU specifies the number of super-diagonals of the\n          matrix A. KU must satisfy  0 .le. KU.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry, the leading ( kl + ku + 1 ) by n part of the\n          array A must contain the matrix of coefficients, supplied\n          column by column, with the leading diagonal of the matrix in\n          row ( ku + 1 ) of the array, the first super-diagonal\n          starting at position 2 in row ku, the first sub-diagonal\n          starting at position 1 in row ( ku + 2 ), and so on.\n          Elements in the array A that do not correspond to elements\n          in the band matrix (such as the top left ku by ku triangle)\n          are not referenced.\n          The following program segment will transfer a band matrix\n          from conventional full matrix storage to band storage: DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( kl + ku + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N integer :: KL integer :: KU double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX double precision :: BETA double precision :: Y (*) integer :: INCY Contents Source Code DGBMV Source Code subroutine DGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dgbmv.3m_blas.man !> \\brief \\b DGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of DGBMV . ! ! END use M_blas , only : dgbmv_ => DGBMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) END SUBROUTINE DGBMV","tags":"","loc":"proc/dgbmv.html"},{"title":"DGEMM – M_blas","text":"subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b DGEMM\n\\par Purpose: \\verbatim DGEMM  performs one of the matrix-matrix operations C := alpha op( A ) op( B ) + beta*C, where  op( X ) is one of op( X ) = X   or   op( X ) = X**T, alpha and beta are scalars, and A, B and C are matrices, with op( A )\nan m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n\\endverbatim\n\\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n',  op( A ) = A.\n\n         TRANSA = 'T' or 't',  op( A ) = A**T.\n\n         TRANSA = 'C' or 'c',  op( A ) = A**T. \\endverbatim \\param[in] TRANSB\n\\verbatim\n         TRANSB is CHARACTER*1\n          On entry, TRANSB specifies the form of op( B ) to be used in\n          the matrix multiplication as follows: TRANSB = 'N' or 'n',  op( B ) = B.\n\n         TRANSB = 'T' or 't',  op( B ) = B**T.\n\n         TRANSB = 'C' or 'c',  op( B ) = B**T. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies  the number  of rows  of the  matrix\n          op( A )  and of the  matrix  C.  M  must  be at least  zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N  specifies the number  of columns of the matrix\n          op( B ) and the number of columns of the matrix C. N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry,  K  specifies  the number of columns of the matrix\n          op( A ) and the number of rows of the matrix op( B ). K must\n          be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n          k  when  TRANSA = ‘N’ or ‘n’,  and is  m  otherwise.\n          Before entry with  TRANSA = ‘N’ or ‘n’,  the leading  m by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by m  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. When  TRANSA = ‘N’ or ‘n’ then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is\n          n  when  TRANSB = ‘N’ or ‘n’,  and is  k  otherwise.\n          Before entry with  TRANSB = ‘N’ or ‘n’,  the leading  k by n\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  n by k  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in the calling (sub) program. When  TRANSB = ‘N’ or ‘n’ then\n          LDB must be at least  max( 1, k ), otherwise  LDB must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is DOUBLE PRECISION array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n  matrix\n          ( alpha op( A ) op( B ) + beta*C ).\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANSA character(len=1) :: TRANSB integer :: M integer :: N integer :: K double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: B (LDB,*) integer :: LDB double precision :: BETA double precision :: C (LDC,*) integer :: LDC Contents Source Code DGEMM Source Code subroutine DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dgemm.3m_blas.man !> \\brief \\b DGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**T. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**T. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And if  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of DGEMM . ! ! END use M_blas , only : dgemm_ => DGEMM implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DGEMM","tags":"","loc":"proc/dgemm.html"},{"title":"DGEMV – M_blas","text":"subroutine DGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b DGEMV\n\\par Purpose: \\verbatim DGEMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry with BETA non-zero, the incremented array Y\n          must contain the vector y. On exit, Y is overwritten by the\n          updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX double precision :: BETA double precision :: Y (*) integer :: INCY Contents Source Code DGEMV Source Code subroutine DGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dgemv.3m_blas.man !> \\brief \\b DGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of DGEMV . ! ! END use M_blas , only : dgemv_ => DGEMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DGEMV","tags":"","loc":"proc/dgemv.html"},{"title":"DGER – M_blas","text":"subroutine DGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b DGER\n\\par Purpose: \\verbatim DGER   performs the rank 1 operation A := alpha x y**T + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( m - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N double precision :: ALPHA double precision :: X (*) integer :: INCX double precision :: Y (*) integer :: INCY double precision :: A (LDA,*) integer :: LDA Contents Source Code DGER Source Code subroutine DGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file dger.3m_blas.man !> \\brief \\b DGER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGER   performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of DGER  . ! ! END use M_blas , only : dger_ => DGER implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , LDA , M , N DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGER_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine DGER","tags":"","loc":"proc/dger.html"},{"title":"DROT – M_blas","text":"subroutine DROT(N, DX, INCX, DY, INCY, C, S) Uses M_blas \\brief \\b DROT\n\\par Purpose: \\verbatim DROT applies a plane rotation.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[in,out] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim \\param[in] C\n\\verbatim\n         C is DOUBLE PRECISION\n\\endverbatim \\param[in] S\n\\verbatim\n         S is DOUBLE PRECISION\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY double precision :: C double precision :: S Contents Source Code DROT Source Code subroutine DROT ( N , DX , INCX , DY , INCY , C , S ) ! COMMENT --file drot.3m_blas.man !> \\brief \\b DROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION C,S !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DROT applies a plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is DOUBLE PRECISION !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : drot_ => DROT implicit none DOUBLE PRECISION C , S INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DROT_ ( N , DX , INCX , DY , INCY , C , S ) end subroutine DROT","tags":"","loc":"proc/drot.html"},{"title":"DROTG – M_blas","text":"subroutine DROTG(DA, DB, C, S) Uses M_blas \\brief \\b DROTG\n\\par Purpose: \\verbatim DROTG construct givens plane rotation.\n\\endverbatim\n\\param[in,out] DA\n\\verbatim\n         DA is DOUBLE PRECISION\n\\endverbatim \\param[in,out] DB\n\\verbatim\n         DB is DOUBLE PRECISION\n\\endverbatim \\param[out] C\n\\verbatim\n         C is DOUBLE PRECISION\n\\endverbatim \\param[out] S\n\\verbatim\n         S is DOUBLE PRECISION\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78. \\endverbatim Arguments Type Intent Optional Attributes Name double precision :: DA double precision :: DB double precision :: C double precision :: S Contents Source Code DROTG Source Code subroutine DROTG ( DA , DB , C , S ) ! COMMENT --file drotg.3m_blas.man !> \\brief \\b DROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTG(DA,DB,C,S) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION C,DA,DB,S !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DROTG construct givens plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] DA !> \\verbatim !>          DA is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DB !> \\verbatim !>          DB is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is DOUBLE PRECISION !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : drotg_ => DROTG implicit none DOUBLE PRECISION C , DA , DB , S call DROTG_ ( DA , DB , C , S ) end subroutine DROTG","tags":"","loc":"proc/drotg.html"},{"title":"DROTM – M_blas","text":"subroutine DROTM(N, DX, INCX, DY, INCY, DPARAM) Uses M_blas \\brief \\b DROTM\n\\par Purpose: \\verbatim APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX (DX T) , WHERE T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN\n   (DY**T) DX(LX+I INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE\n   LX = (-INCX) N, AND SIMILARLY FOR SY USING LY AND INCY.\n   WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) H=(          )    (          )    (          )    (          )\n     (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).\n   SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[in,out] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim \\param[in] DPARAM\n\\verbatim\n         DPARAM is DOUBLE PRECISION array, dimension (5)\n    DPARAM(1)=DFLAG\n    DPARAM(2)=DH11\n    DPARAM(3)=DH21\n    DPARAM(4)=DH12\n    DPARAM(5)=DH22\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1 Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY double precision :: DPARAM (5) Contents Source Code DROTM Source Code subroutine DROTM ( N , DX , INCX , DY , INCY , DPARAM ) ! COMMENT --file drotm.3m_blas.man !> \\brief \\b DROTM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTM(N,DX,INCX,DY,INCY,DPARAM) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DPARAM(5),DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX !> !>    (DX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN !>    (DY**T) !> !>    DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE !>    LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY. !>    WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !> !>      (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !>    H=(          )    (          )    (          )    (          ) !>      (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !>    SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim !> !> \\param[in] DPARAM !> \\verbatim !>          DPARAM is DOUBLE PRECISION array, dimension (5) !>     DPARAM(1)=DFLAG !>     DPARAM(2)=DH11 !>     DPARAM(3)=DH21 !>     DPARAM(4)=DH12 !>     DPARAM(5)=DH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Data statements .. !     .. ! ! ! ! END use M_blas , only : drotm_ => DROTM implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DPARAM ( 5 ), DX ( * ), DY ( * ) call DROTM_ ( N , DX , INCX , DY , INCY , DPARAM ) end subroutine DROTM","tags":"","loc":"proc/drotm.html"},{"title":"DROTMG – M_blas","text":"subroutine DROTMG(DD1, DD2, DX1, DY1, DPARAM) Uses M_blas \\brief \\b DROTMG\n\\par Purpose: \\verbatim CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS\n   THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1) DX1,DSQRT(DD2) >    DY2)**T.\n   WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) H=(          )    (          )    (          )    (          )\n     (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).\n   LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22\n   RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE\n   VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.) THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE\n   INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE\n   OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. \\endverbatim\n\\param[in,out] DD1\n\\verbatim\n         DD1 is DOUBLE PRECISION\n\\endverbatim \\param[in,out] DD2\n\\verbatim\n         DD2 is DOUBLE PRECISION\n\\endverbatim \\param[in,out] DX1\n\\verbatim\n         DX1 is DOUBLE PRECISION\n\\endverbatim \\param[in] DY1\n\\verbatim\n         DY1 is DOUBLE PRECISION\n\\endverbatim \\param[out] DPARAM\n\\verbatim\n         DPARAM is DOUBLE PRECISION array, dimension (5)\n    DPARAM(1)=DFLAG\n    DPARAM(2)=DH11\n    DPARAM(3)=DH21\n    DPARAM(4)=DH12\n    DPARAM(5)=DH22\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1 Arguments Type Intent Optional Attributes Name double precision :: DD1 double precision :: DD2 double precision :: DX1 double precision :: DY1 double precision :: DPARAM (5) Contents Source Code DROTMG Source Code subroutine DROTMG ( DD1 , DD2 , DX1 , DY1 , DPARAM ) ! COMMENT --file drotmg.3m_blas.man !> \\brief \\b DROTMG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTMG(DD1,DD2,DX1,DY1,DPARAM) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DD1,DD2,DX1,DY1 !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DPARAM(5) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS !>    THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*>    DY2)**T. !>    WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !> !>      (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !>    H=(          )    (          )    (          )    (          ) !>      (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !>    LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22 !>    RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE !>    VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.) !> !>    THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE !>    INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE !>    OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] DD1 !> \\verbatim !>          DD1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DD2 !> \\verbatim !>          DD2 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DX1 !> \\verbatim !>          DX1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in] DY1 !> \\verbatim !>          DY1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] DPARAM !> \\verbatim !>          DPARAM is DOUBLE PRECISION array, dimension (5) !>     DPARAM(1)=DFLAG !>     DPARAM(2)=DH11 !>     DPARAM(3)=DH21 !>     DPARAM(4)=DH12 !>     DPARAM(5)=DH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Data statements .. ! !     .. !        GO ZERO-H-D-AND-DX1.. ! !        CASE-DD1-NONNEGATIVE !        REGULAR-CASE.. ! ! ! !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 ! !              GO ZERO-H-D-AND-DX1.. ! !     PROCEDURE..SCALE-CHECK ! END use M_blas , only : drotmg_ => DROTMG implicit none DOUBLE PRECISION DD1 , DD2 , DX1 , DY1 DOUBLE PRECISION DPARAM ( 5 ) call DROTMG_ ( DD1 , DD2 , DX1 , DY1 , DPARAM ) end subroutine DROTMG","tags":"","loc":"proc/drotmg.html"},{"title":"DSBMV – M_blas","text":"subroutine DSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b DSBMV\n\\par Purpose: \\verbatim DSBMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric band matrix, with k super-diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the band matrix A is being supplied as\n          follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             being supplied.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             being supplied. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry, K specifies the number of super-diagonals of the\n          matrix A. K must satisfy  0 .le. K.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the symmetric matrix, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer the upper\n          triangular part of a symmetric band matrix from conventional\n          full matrix storage to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a symmetric band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N integer :: K double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX double precision :: BETA double precision :: Y (*) integer :: INCY Contents Source Code DSBMV Source Code subroutine DSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dsbmv.3m_blas.man !> \\brief \\b DSBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of DSBMV . ! ! END use M_blas , only : dsbmv_ => DSBMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DSBMV","tags":"","loc":"proc/dsbmv.html"},{"title":"DSCAL – M_blas","text":"subroutine DSCAL(N, DA, DX, INCX) Uses M_blas \\brief \\b DSCAL\n\\par Purpose: \\verbatim DSCAL scales a vector by a constant.\n   uses unrolled loops for increment equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DA\n\\verbatim\n         DA is DOUBLE PRECISION\n          On entry, DA specifies the scalar alpha.\n\\endverbatim \\param[in,out] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DA double precision :: DX (*) integer :: INCX Contents Source Code DSCAL Source Code subroutine DSCAL ( N , DA , DX , INCX ) ! COMMENT --file dscal.3m_blas.man !> \\brief \\b DSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSCAL(N,DA,DX,INCX) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DSCAL scales a vector by a constant. !>    uses unrolled loops for increment equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dscal_ => DSCAL implicit none DOUBLE PRECISION DA INTEGER INCX , N DOUBLE PRECISION DX ( * ) call DSCAL_ ( N , DA , DX , INCX ) end subroutine DSCAL","tags":"","loc":"proc/dscal.html"},{"title":"DSPMV – M_blas","text":"subroutine DSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b DSPMV\n\\par Purpose: \\verbatim DSPMV  performs the matrix-vector operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is DOUBLE PRECISION array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: AP (*) double precision :: X (*) integer :: INCX double precision :: BETA double precision :: Y (*) integer :: INCY Contents Source Code DSPMV Source Code subroutine DSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file dspmv.3m_blas.man !> \\brief \\b DSPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of DSPMV . ! ! END use M_blas , only : dspmv_ => DSPMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ), Y ( * ) call DSPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine DSPMV","tags":"","loc":"proc/dspmv.html"},{"title":"DSPR2 – M_blas","text":"subroutine DSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Uses M_blas \\brief \\b DSPR2\n\\par Purpose: \\verbatim DSPR2  performs the symmetric rank 2 operation A := alpha x y T + alpha y x T + A, where alpha is a scalar, x and y are n element vectors and A is an\nn by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is DOUBLE PRECISION array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: X (*) integer :: INCX double precision :: Y (*) integer :: INCY double precision :: AP (*) Contents Source Code DSPR2 Source Code subroutine DSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file dspr2.3m_blas.man !> \\brief \\b DSPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of DSPR2 . ! ! END use M_blas , only : dspr2_ => DSPR2 implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ), Y ( * ) call DSPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine DSPR2","tags":"","loc":"proc/dspr2.html"},{"title":"DSPR – M_blas","text":"subroutine DSPR(UPLO, N, ALPHA, X, INCX, AP) Uses M_blas \\brief \\b DSPR\n\\par Purpose: \\verbatim DSPR    performs the symmetric rank 1 operation A := alpha x x**T + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is DOUBLE PRECISION array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: X (*) integer :: INCX double precision :: AP (*) Contents Source Code DSPR Source Code subroutine DSPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file dspr.3m_blas.man !> \\brief \\b DSPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPR    performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of DSPR  . ! ! END use M_blas , only : dspr_ => DSPR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DSPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine DSPR","tags":"","loc":"proc/dspr.html"},{"title":"DSWAP – M_blas","text":"subroutine DSWAP(N, DX, INCX, DY, INCY) Uses M_blas \\brief \\b DSWAP\n\\par Purpose: \\verbatim DSWAP interchanges two vectors.\n   uses unrolled loops for increments equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] DX\n\\verbatim\n         DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of DX\n\\endverbatim \\param[in,out] DY\n\\verbatim\n         DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of DY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup double_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DX (*) integer :: INCX double precision :: DY (*) integer :: INCY Contents Source Code DSWAP Source Code subroutine DSWAP ( N , DX , INCX , DY , INCY ) ! COMMENT --file dswap.3m_blas.man !> \\brief \\b DSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSWAP(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DSWAP interchanges two vectors. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !       code for both increments equal to 1 ! ! !       clean-up loop ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : dswap_ => DSWAP implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DSWAP_ ( N , DX , INCX , DY , INCY ) end subroutine DSWAP","tags":"","loc":"proc/dswap.html"},{"title":"DSYMM – M_blas","text":"subroutine DSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b DSYMM\n\\par Purpose: \\verbatim DSYMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where alpha and beta are scalars,  A is a symmetric matrix and  B and\nC are  m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  symmetric matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  symmetric  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             symmetric matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             symmetric matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is  n otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is DOUBLE PRECISION array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is DOUBLE PRECISION array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: B (LDB,*) integer :: LDB double precision :: BETA double precision :: C (LDC,*) integer :: LDC Contents Source Code DSYMM Source Code subroutine DSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dsymm.3m_blas.man !> \\brief \\b DSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars,  A is a symmetric matrix and  B and !> C are  m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is  n otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of DSYMM . ! ! END use M_blas , only : dsymm_ => DSYMM implicit none DOUBLE PRECISION ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DSYMM","tags":"","loc":"proc/dsymm.html"},{"title":"DSYMV – M_blas","text":"subroutine DSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b DSYMV\n\\par Purpose: \\verbatim DSYMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX double precision :: BETA double precision :: Y (*) integer :: INCY Contents Source Code DSYMV Source Code subroutine DSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dsymv.3m_blas.man !> \\brief \\b DSYMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of DSYMV . ! ! END use M_blas , only : dsymv_ => DSYMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSYMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DSYMV","tags":"","loc":"proc/dsymv.html"},{"title":"DSYR2 – M_blas","text":"subroutine DSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b DSYR2\n\\par Purpose: \\verbatim DSYR2  performs the symmetric rank 2 operation A := alpha x y T + alpha y x T + A, where alpha is a scalar, x and y are n element vectors and A is an n\nby n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: X (*) integer :: INCX double precision :: Y (*) integer :: INCY double precision :: A (LDA,*) integer :: LDA Contents Source Code DSYR2 Source Code subroutine DSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file dsyr2.3m_blas.man !> \\brief \\b DSYR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of DSYR2 . ! ! END use M_blas , only : dsyr2_ => DSYR2 implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSYR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine DSYR2","tags":"","loc":"proc/dsyr2.html"},{"title":"DSYR2K – M_blas","text":"subroutine DSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b DSYR2K\n\\par Purpose: \\verbatim DSYR2K  performs one of the symmetric rank 2k operations C := alpha A B T + alpha B A T + beta*C, or C := alpha A T B + alpha B T A + beta*C, where  alpha and beta  are scalars, C is an  n by n  symmetric matrix\nand  A and B  are  n by k  matrices  in the  first  case  and  k by n\nmatrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘T’ or ‘t’ or ‘C’ or ‘c’,  K  specifies  the  number\n          of rows of the matrices  A and B.  K must be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is DOUBLE PRECISION array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: B (LDB,*) integer :: LDB double precision :: BETA double precision :: C (LDC,*) integer :: LDC Contents Source Code DSYR2K Source Code subroutine DSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dsyr2k.3m_blas.man !> \\brief \\b DSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !>                                        beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrices  A and B.  K must be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of DSYR2K. ! ! END use M_blas , only : dsyr2k_ => DSYR2K implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DSYR2K","tags":"","loc":"proc/dsyr2k.html"},{"title":"DSYR – M_blas","text":"subroutine DSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Uses M_blas \\brief \\b DSYR\n\\par Purpose: \\verbatim DSYR   performs the symmetric rank 1 operation A := alpha x x**T + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA double precision :: X (*) integer :: INCX double precision :: A (LDA,*) integer :: LDA Contents Source Code DSYR Source Code subroutine DSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file dsyr.3m_blas.man !> \\brief \\b DSYR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR   performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of DSYR  . ! ! END use M_blas , only : dsyr_ => DSYR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DSYR_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine DSYR","tags":"","loc":"proc/dsyr.html"},{"title":"DSYRK – M_blas","text":"subroutine DSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b DSYRK\n\\par Purpose: \\verbatim DSYRK  performs one of the symmetric rank k operations C := alpha A A* T + beta C, or C := alpha A T A + beta*C, where  alpha and beta  are scalars, C is an  n by n  symmetric matrix\nand  A  is an  n by k  matrix in the first case and a  k by n  matrix\nin the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘T’ or ‘t’ or ‘C’ or ‘c’,  K  specifies  the  number\n          of rows of the matrix  A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is DOUBLE PRECISION array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: BETA double precision :: C (LDC,*) integer :: LDC Contents Source Code DSYRK Source Code subroutine DSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file dsyrk.3m_blas.man !> \\brief \\b DSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrix  A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of DSYRK . ! ! END use M_blas , only : dsyrk_ => DSYRK implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), C ( LDC , * ) call DSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine DSYRK","tags":"","loc":"proc/dsyrk.html"},{"title":"DTBMV – M_blas","text":"subroutine DTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b DTBMV\n\\par Purpose: \\verbatim DTBMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular band matrix, with ( k + 1 ) diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX Contents Source Code DTBMV Source Code subroutine DTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file dtbmv.3m_blas.man !> \\brief \\b DTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTBMV . ! ! END use M_blas , only : dtbmv_ => DTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine DTBMV","tags":"","loc":"proc/dtbmv.html"},{"title":"DTBSV – M_blas","text":"subroutine DTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b DTBSV\n\\par Purpose: \\verbatim DTBSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular band matrix, with ( k + 1 )\ndiagonals. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX Contents Source Code DTBSV Source Code subroutine DTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file dtbsv.3m_blas.man !> \\brief \\b DTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T)*x. ! ! ! !     End of DTBSV . ! ! END use M_blas , only : dtbsv_ => DTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine DTBSV","tags":"","loc":"proc/dtbsv.html"},{"title":"DTPMV – M_blas","text":"subroutine DTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b DTPMV\n\\par Purpose: \\verbatim DTPMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is DOUBLE PRECISION array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N double precision :: AP (*) double precision :: X (*) integer :: INCX Contents Source Code DTPMV Source Code subroutine DTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file dtpmv.3m_blas.man !> \\brief \\b DTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTPMV . ! ! END use M_blas , only : dtpmv_ => DTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine DTPMV","tags":"","loc":"proc/dtpmv.html"},{"title":"DTPSV – M_blas","text":"subroutine DTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b DTPSV\n\\par Purpose: \\verbatim DTPSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is DOUBLE PRECISION array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N double precision :: AP (*) double precision :: X (*) integer :: INCX Contents Source Code DTPSV Source Code subroutine DTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file dtpsv.3m_blas.man !> \\brief \\b DTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of DTPSV . ! ! END use M_blas , only : dtpsv_ => DTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine DTPSV","tags":"","loc":"proc/dtpsv.html"},{"title":"DTRMM – M_blas","text":"subroutine DTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b DTRMM\n\\par Purpose: \\verbatim DTRMM  performs one of the matrix-matrix operations B := alpha op( A ) B,   or   B := alpha B op( A ), where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A* T.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER 1\n          On entry,  SIDE specifies whether  op( A ) multiplies B from\n          the left or right as follows: SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**T. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n          A is DOUBLE PRECISION array, dimension ( LDA, k ), where k is m\n          when  SIDE = ‘L’ or ‘l’  and is  n  when  SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is DOUBLE PRECISION array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain the matrix  B,  and  on exit  is overwritten  by the\n          transformed matrix.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: B (LDB,*) integer :: LDB Contents Source Code DTRMM Source Code subroutine DTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file dtrmm.3m_blas.man !> \\brief \\b DTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>           A is DOUBLE PRECISION array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T. ! ! ! !     End of DTRMM . ! ! END use M_blas , only : dtrmm_ => DTRMM implicit none DOUBLE PRECISION ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ) call DTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine DTRMM","tags":"","loc":"proc/dtrmm.html"},{"title":"DTRMV – M_blas","text":"subroutine DTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b DTRMV\n\\par Purpose: \\verbatim DTRMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX Contents Source Code DTRMV Source Code subroutine DTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file dtrmv.3m_blas.man !> \\brief \\b DTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTRMV . ! ! END use M_blas , only : dtrmv_ => DTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine DTRMV","tags":"","loc":"proc/dtrmv.html"},{"title":"DTRSM – M_blas","text":"subroutine DTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b DTRSM\n\\par Purpose: \\verbatim DTRSM  solves one of the matrix equations op( A ) X = alpha B,   or   X op( A ) = alpha B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A**T. The matrix X is overwritten on B.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry, SIDE specifies whether op( A ) appears on the left\n          or right of X as follows: SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n         SIDE = 'R' or 'r'   X*op( A ) = alpha*B. \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**T. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, k ),\n          where k is m when SIDE = ‘L’ or ‘l’\n            and k is n when SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is DOUBLE PRECISION array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain  the  right-hand  side  matrix  B,  and  on exit  is\n          overwritten by the solution matrix  X.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N double precision :: ALPHA double precision :: A (LDA,*) integer :: LDA double precision :: B (LDB,*) integer :: LDB Contents Source Code DTRSM Source Code subroutine DTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file dtrsm.3m_blas.man !> \\brief \\b DTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ). ! ! ! !     End of DTRSM . ! ! END use M_blas , only : dtrsm_ => DTRSM implicit none DOUBLE PRECISION ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ) call DTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine DTRSM","tags":"","loc":"proc/dtrsm.html"},{"title":"DTRSV – M_blas","text":"subroutine DTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b DTRSV\n\\par Purpose: \\verbatim DTRSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is DOUBLE PRECISION array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is DOUBLE PRECISION array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero. Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup double_blas_level1 Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N double precision :: A (LDA,*) integer :: LDA double precision :: X (*) integer :: INCX Contents Source Code DTRSV Source Code subroutine DTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file dtrsv.3m_blas.man !> \\brief \\b DTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of DTRSV . ! ! END use M_blas , only : dtrsv_ => DTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine DTRSV","tags":"","loc":"proc/dtrsv.html"},{"title":"SAXPY – M_blas","text":"subroutine SAXPY(N, SA, SX, INCX, SY, INCY) Uses M_blas \\brief \\b SAXPY\n\\par Purpose: \\verbatim SAXPY constant times a vector plus a vector.\n   uses unrolled loops for increments equal to one.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SA\n\\verbatim\n         SA is REAL\n          On entry, SA specifies the scalar alpha.\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[in,out] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SA real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Contents Source Code SAXPY Source Code subroutine SAXPY ( N , SA , SX , INCX , SY , INCY ) ! COMMENT --file saxpy.3m_blas.man !> \\brief \\b SAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SAXPY constant times a vector plus a vector. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : saxpy_ => SAXPY implicit none REAL SA INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SAXPY_ ( N , SA , SX , INCX , SY , INCY ) end subroutine SAXPY","tags":"","loc":"proc/saxpy.html"},{"title":"SCOPY – M_blas","text":"subroutine SCOPY(N, SX, INCX, SY, INCY) Uses M_blas \\brief \\b SCOPY\n\\par Purpose: \\verbatim SCOPY copies a vector, x, to a vector, y.\n   uses unrolled loops for increments equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[out] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Contents Source Code SCOPY Source Code subroutine SCOPY ( N , SX , INCX , SY , INCY ) ! COMMENT --file scopy.3m_blas.man !> \\brief \\b SCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SCOPY(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SCOPY copies a vector, x, to a vector, y. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : scopy_ => SCOPY implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SCOPY_ ( N , SX , INCX , SY , INCY ) end subroutine SCOPY","tags":"","loc":"proc/scopy.html"},{"title":"SGBMV – M_blas","text":"subroutine SGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b SGBMV\n\\par Purpose: \\verbatim SGBMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n band matrix, with kl sub-diagonals and ku super-diagonals.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] KL\n\\verbatim\n         KL is INTEGER\n          On entry, KL specifies the number of sub-diagonals of the\n          matrix A. KL must satisfy  0 .le. KL.\n\\endverbatim \\param[in] KU\n\\verbatim\n         KU is INTEGER\n          On entry, KU specifies the number of super-diagonals of the\n          matrix A. KU must satisfy  0 .le. KU.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry, the leading ( kl + ku + 1 ) by n part of the\n          array A must contain the matrix of coefficients, supplied\n          column by column, with the leading diagonal of the matrix in\n          row ( ku + 1 ) of the array, the first super-diagonal\n          starting at position 2 in row ku, the first sub-diagonal\n          starting at position 1 in row ( ku + 2 ), and so on.\n          Elements in the array A that do not correspond to elements\n          in the band matrix (such as the top left ku by ku triangle)\n          are not referenced.\n          The following program segment will transfer a band matrix\n          from conventional full matrix storage to band storage: DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( kl + ku + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer :: M integer :: N integer :: KL integer :: KU real :: ALPHA real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX real :: BETA real :: Y (*) integer :: INCY Contents Source Code SGBMV Source Code subroutine SGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file sgbmv.3m_blas.man !> \\brief \\b SGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of SGBMV . ! ! END use M_blas , only : sgbmv_ => SGBMV implicit none CHARACTER ( len = 1 ), intent ( in ) :: TRANS REAL ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N REAL A ( LDA , * ), X ( * ), Y ( * ) call SGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SGBMV","tags":"","loc":"proc/sgbmv.html"},{"title":"SGEMM – M_blas","text":"subroutine SGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b SGEMM\n\\par Purpose: \\verbatim SGEMM  performs one of the matrix-matrix operations C := alpha op( A ) op( B ) + beta*C, where  op( X ) is one of op( X ) = X   or   op( X ) = X**T, alpha and beta are scalars, and A, B and C are matrices, with op( A )\nan m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n\\endverbatim\n\\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n',  op( A ) = A.\n\n         TRANSA = 'T' or 't',  op( A ) = A**T.\n\n         TRANSA = 'C' or 'c',  op( A ) = A**T. \\endverbatim \\param[in] TRANSB\n\\verbatim\n         TRANSB is CHARACTER*1\n          On entry, TRANSB specifies the form of op( B ) to be used in\n          the matrix multiplication as follows: TRANSB = 'N' or 'n',  op( B ) = B.\n\n         TRANSB = 'T' or 't',  op( B ) = B**T.\n\n         TRANSB = 'C' or 'c',  op( B ) = B**T. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies  the number  of rows  of the  matrix\n          op( A )  and of the  matrix  C.  M  must  be at least  zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N  specifies the number  of columns of the matrix\n          op( B ) and the number of columns of the matrix C. N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry,  K  specifies  the number of columns of the matrix\n          op( A ) and the number of rows of the matrix op( B ). K must\n          be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, ka ), where ka is\n          k  when  TRANSA = ‘N’ or ‘n’,  and is  m  otherwise.\n          Before entry with  TRANSA = ‘N’ or ‘n’,  the leading  m by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by m  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. When  TRANSA = ‘N’ or ‘n’ then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is REAL array, dimension ( LDB, kb ), where kb is\n          n  when  TRANSB = ‘N’ or ‘n’,  and is  k  otherwise.\n          Before entry with  TRANSB = ‘N’ or ‘n’,  the leading  k by n\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  n by k  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in the calling (sub) program. When  TRANSB = ‘N’ or ‘n’ then\n          LDB must be at least  max( 1, k ), otherwise  LDB must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is REAL array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n  matrix\n          ( alpha op( A ) op( B ) + beta*C ).\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANSA character(len=1) :: TRANSB integer :: M integer :: N integer :: K real :: ALPHA real :: A (LDA,*) integer :: LDA real :: B (LDB,*) integer :: LDB real :: BETA real :: C (LDC,*) integer :: LDC Contents Source Code SGEMM Source Code subroutine SGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file sgemm.3m_blas.man !> \\brief \\b SGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**T. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**T. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And if  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of SGEMM . ! ! END use M_blas , only : sgemm_ => SGEMM implicit none REAL ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SGEMM","tags":"","loc":"proc/sgemm.html"},{"title":"SGEMV – M_blas","text":"subroutine SGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b SGEMV\n\\par Purpose: \\verbatim SGEMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n          Before entry with BETA non-zero, the incremented array Y\n          must contain the vector y. On exit, Y is overwritten by the\n          updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N real :: ALPHA real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX real :: BETA real :: Y (*) integer :: INCY Contents Source Code SGEMV Source Code subroutine SGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file sgemv.3m_blas.man !> \\brief \\b SGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of SGEMV . ! ! END use M_blas , only : sgemv_ => SGEMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS REAL A ( LDA , * ), X ( * ), Y ( * ) call SGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SGEMV","tags":"","loc":"proc/sgemv.html"},{"title":"SGER – M_blas","text":"subroutine SGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b SGER\n\\par Purpose: \\verbatim SGER   performs the rank 1 operation A := alpha x y**T + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( m - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N real :: ALPHA real :: X (*) integer :: INCX real :: Y (*) integer :: INCY real :: A (LDA,*) integer :: LDA Contents Source Code SGER Source Code subroutine SGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file sger.3m_blas.man !> \\brief \\b SGER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGER   performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of SGER  . ! ! END use M_blas , only : sger_ => SGER implicit none REAL ALPHA INTEGER INCX , INCY , LDA , M , N REAL A ( LDA , * ), X ( * ), Y ( * ) call SGER_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine SGER","tags":"","loc":"proc/sger.html"},{"title":"SROT – M_blas","text":"subroutine SROT(N, SX, INCX, SY, INCY, C, S) Uses M_blas \\brief \\b SROT\n\\par Purpose: \\verbatim applies a plane rotation.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[in,out] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim \\param[in] C\n\\verbatim\n         C is REAL\n\\endverbatim \\param[in] S\n\\verbatim\n         S is REAL\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY real :: C real :: S Contents Source Code SROT Source Code subroutine SROT ( N , SX , INCX , SY , INCY , C , S ) ! COMMENT --file srot.3m_blas.man !> \\brief \\b SROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROT(N,SX,INCX,SY,INCY,C,S) ! !       .. Scalar Arguments .. !       REAL C,S !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    applies a plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is REAL !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : srot_ => SROT implicit none REAL C , S INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SROT_ ( N , SX , INCX , SY , INCY , C , S ) end subroutine SROT","tags":"","loc":"proc/srot.html"},{"title":"SROTG – M_blas","text":"subroutine SROTG(SA, SB, C, S) Uses M_blas \\brief \\b SROTG\n\\par Purpose: \\verbatim SROTG construct givens plane rotation.\n\\endverbatim\n\\param[in,out] SA\n\\verbatim\n         SA is REAL\n\\endverbatim \\param[in,out] SB\n\\verbatim\n         SB is REAL\n\\endverbatim \\param[out] C\n\\verbatim\n         C is REAL\n\\endverbatim \\param[out] S\n\\verbatim\n         S is REAL\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78. \\endverbatim Arguments Type Intent Optional Attributes Name real :: SA real :: SB real :: C real :: S Contents Source Code SROTG Source Code subroutine SROTG ( SA , SB , C , S ) ! COMMENT --file srotg.3m_blas.man !> \\brief \\b SROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTG(SA,SB,C,S) ! !       .. Scalar Arguments .. !       REAL C,S,SA,SB !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SROTG construct givens plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] SA !> \\verbatim !>          SA is REAL !> \\endverbatim !> !> \\param[in,out] SB !> \\verbatim !>          SB is REAL !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is REAL !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : srotg_ => SROTG implicit none REAL C , S , SA , SB call SROTG_ ( SA , SB , C , S ) end subroutine SROTG","tags":"","loc":"proc/srotg.html"},{"title":"SROTM – M_blas","text":"subroutine SROTM(N, SX, INCX, SY, INCY, SPARAM) Uses M_blas \\brief \\b SROTM\n\\par Purpose: \\verbatim APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX (SX T) , WHERE T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN\n   (SX**T) SX(LX+I INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE\n   LX = (-INCX) N, AND SIMILARLY FOR SY USING USING LY AND INCY.\n   WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) H=(          )    (          )    (          )    (          )\n     (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0).\n   SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM. \\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[in,out] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim \\param[in] SPARAM\n\\verbatim\n         SPARAM is REAL array, dimension (5)\n    SPARAM(1)=SFLAG\n    SPARAM(2)=SH11\n    SPARAM(3)=SH21\n    SPARAM(4)=SH12\n    SPARAM(5)=SH22\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1 Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY real :: SPARAM (5) Contents Source Code SROTM Source Code subroutine SROTM ( N , SX , INCX , SY , INCY , SPARAM ) ! COMMENT --file srotm.3m_blas.man !> \\brief \\b SROTM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTM(N,SX,INCX,SY,INCY,SPARAM) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SPARAM(5),SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX !> !>    (SX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN !>    (SX**T) !> !>    SX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE !>    LX = (-INCX)*N, AND SIMILARLY FOR SY USING USING LY AND INCY. !>    WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !> !>      (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !>    H=(          )    (          )    (          )    (          ) !>      (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !>    SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\param[in] SPARAM !> \\verbatim !>          SPARAM is REAL array, dimension (5) !>     SPARAM(1)=SFLAG !>     SPARAM(2)=SH11 !>     SPARAM(3)=SH21 !>     SPARAM(4)=SH12 !>     SPARAM(5)=SH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Data statements .. !     .. ! ! ! ! END use M_blas , only : srotm_ => SROTM implicit none INTEGER INCX , INCY , N REAL SPARAM ( 5 ), SX ( * ), SY ( * ) call SROTM_ ( N , SX , INCX , SY , INCY , SPARAM ) end subroutine SROTM","tags":"","loc":"proc/srotm.html"},{"title":"SROTMG – M_blas","text":"subroutine SROTMG(SD1, SD2, SX1, SY1, SPARAM) Uses M_blas \\brief \\b SROTMG\n\\par Purpose: \\verbatim CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS\n   THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(SD1) SX1,SQRT(SD2) >    SY2)**T.\n   WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) H=(          )    (          )    (          )    (          )\n     (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0).\n   LOCATIONS 2-4 OF SPARAM CONTAIN SH11,SH21,SH12, AND SH22\n   RESPECTIVELY. (VALUES OF 1.E0, -1.E0, OR 0.E0 IMPLIED BY THE\n   VALUE OF SPARAM(1) ARE NOT STORED IN SPARAM.) THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE\n   INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE\n   OF SD1 AND SD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. \\endverbatim\n\\param[in,out] SD1\n\\verbatim\n         SD1 is REAL\n\\endverbatim \\param[in,out] SD2\n\\verbatim\n         SD2 is REAL\n\\endverbatim \\param[in,out] SX1\n\\verbatim\n         SX1 is REAL\n\\endverbatim \\param[in] SY1\n\\verbatim\n         SY1 is REAL\n\\endverbatim \\param[out] SPARAM\n\\verbatim\n         SPARAM is REAL array, dimension (5)\n    SPARAM(1)=SFLAG\n    SPARAM(2)=SH11\n    SPARAM(3)=SH21\n    SPARAM(4)=SH12\n    SPARAM(5)=SH22\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1 Arguments Type Intent Optional Attributes Name real :: SD1 real :: SD2 real :: SX1 real :: SY1 real :: SPARAM (5) Contents Source Code SROTMG Source Code subroutine SROTMG ( SD1 , SD2 , SX1 , SY1 , SPARAM ) ! COMMENT --file srotmg.3m_blas.man !> \\brief \\b SROTMG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTMG(SD1,SD2,SX1,SY1,SPARAM) ! !       .. Scalar Arguments .. !       REAL SD1,SD2,SX1,SY1 !       .. !       .. Array Arguments .. !       REAL SPARAM(5) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS !>    THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(SD1)*SX1,SQRT(SD2)*>    SY2)**T. !>    WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !> !>      (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !>    H=(          )    (          )    (          )    (          ) !>      (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !>    LOCATIONS 2-4 OF SPARAM CONTAIN SH11,SH21,SH12, AND SH22 !>    RESPECTIVELY. (VALUES OF 1.E0, -1.E0, OR 0.E0 IMPLIED BY THE !>    VALUE OF SPARAM(1) ARE NOT STORED IN SPARAM.) !> !>    THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE !>    INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE !>    OF SD1 AND SD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] SD1 !> \\verbatim !>          SD1 is REAL !> \\endverbatim !> !> \\param[in,out] SD2 !> \\verbatim !>          SD2 is REAL !> \\endverbatim !> !> \\param[in,out] SX1 !> \\verbatim !>          SX1 is REAL !> \\endverbatim !> !> \\param[in] SY1 !> \\verbatim !>          SY1 is REAL !> \\endverbatim !> !> \\param[out] SPARAM !> \\verbatim !>          SPARAM is REAL array, dimension (5) !>     SPARAM(1)=SFLAG !>     SPARAM(2)=SH11 !>     SPARAM(3)=SH21 !>     SPARAM(4)=SH12 !>     SPARAM(5)=SH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Data statements .. ! !     .. !        GO ZERO-H-D-AND-SX1.. ! !        CASE-SD1-NONNEGATIVE !        REGULAR-CASE.. ! ! ! !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 ! !              GO ZERO-H-D-AND-SX1.. ! !     PROCEDURE..SCALE-CHECK ! END use M_blas , only : srotmg_ => SROTMG implicit none REAL SD1 , SD2 , SX1 , SY1 REAL SPARAM ( 5 ) call SROTMG_ ( SD1 , SD2 , SX1 , SY1 , SPARAM ) end subroutine SROTMG","tags":"","loc":"proc/srotmg.html"},{"title":"SSBMV – M_blas","text":"subroutine SSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b SSBMV\n\\par Purpose: \\verbatim SSBMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric band matrix, with k super-diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the band matrix A is being supplied as\n          follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             being supplied.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             being supplied. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry, K specifies the number of super-diagonals of the\n          matrix A. K must satisfy  0 .le. K.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the symmetric matrix, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer the upper\n          triangular part of a symmetric band matrix from conventional\n          full matrix storage to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a symmetric band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N integer :: K real :: ALPHA real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX real :: BETA real :: Y (*) integer :: INCY Contents Source Code SSBMV Source Code subroutine SSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file ssbmv.3m_blas.man !> \\brief \\b SSBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of SSBMV . ! ! END use M_blas , only : ssbmv_ => SSBMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SSBMV","tags":"","loc":"proc/ssbmv.html"},{"title":"SSCAL – M_blas","text":"subroutine SSCAL(N, SA, SX, INCX) Uses M_blas \\brief \\b SSCAL\n\\par Purpose: \\verbatim SSCAL scales a vector by a constant.\n   uses unrolled loops for increment equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] SA\n\\verbatim\n         SA is REAL\n          On entry, SA specifies the scalar alpha.\n\\endverbatim \\param[in,out] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SA real :: SX (*) integer :: INCX Contents Source Code SSCAL Source Code subroutine SSCAL ( N , SA , SX , INCX ) ! COMMENT --file sscal.3m_blas.man !> \\brief \\b SSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSCAL(N,SA,SX,INCX) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SSCAL scales a vector by a constant. !>    uses unrolled loops for increment equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : sscal_ => SSCAL implicit none REAL SA INTEGER INCX , N REAL SX ( * ) call SSCAL_ ( N , SA , SX , INCX ) end subroutine SSCAL","tags":"","loc":"proc/sscal.html"},{"title":"SSPMV – M_blas","text":"subroutine SSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b SSPMV\n\\par Purpose: \\verbatim SSPMV  performs the matrix-vector operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is REAL array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: AP (*) real :: X (*) integer :: INCX real :: BETA real :: Y (*) integer :: INCY Contents Source Code SSPMV Source Code subroutine SSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file sspmv.3m_blas.man !> \\brief \\b SSPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of SSPMV . ! ! END use M_blas , only : sspmv_ => SSPMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO REAL AP ( * ), X ( * ), Y ( * ) call SSPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine SSPMV","tags":"","loc":"proc/sspmv.html"},{"title":"SSPR2 – M_blas","text":"subroutine SSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Uses M_blas \\brief \\b SSPR2\n\\par Purpose: \\verbatim SSPR2  performs the symmetric rank 2 operation A := alpha x y T + alpha y x T + A, where alpha is a scalar, x and y are n element vectors and A is an\nn by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is REAL array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: X (*) integer :: INCX real :: Y (*) integer :: INCY real :: AP (*) Contents Source Code SSPR2 Source Code subroutine SSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file sspr2.3m_blas.man !> \\brief \\b SSPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of SSPR2 . ! ! END use M_blas , only : sspr2_ => SSPR2 implicit none REAL ALPHA INTEGER INCX , INCY , N CHARACTER UPLO REAL AP ( * ), X ( * ), Y ( * ) call SSPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine SSPR2","tags":"","loc":"proc/sspr2.html"},{"title":"SSPR – M_blas","text":"subroutine SSPR(UPLO, N, ALPHA, X, INCX, AP) Uses M_blas \\brief \\b SSPR\n\\par Purpose: \\verbatim SSPR    performs the symmetric rank 1 operation A := alpha x x**T + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n symmetric matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is REAL array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the symmetric matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: X (*) integer :: INCX real :: AP (*) Contents Source Code SSPR Source Code subroutine SSPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file sspr.3m_blas.man !> \\brief \\b SSPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPR    performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of SSPR  . ! ! END use M_blas , only : sspr_ => SSPR implicit none REAL ALPHA INTEGER INCX , N CHARACTER UPLO REAL AP ( * ), X ( * ) call SSPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine SSPR","tags":"","loc":"proc/sspr.html"},{"title":"SSWAP – M_blas","text":"subroutine SSWAP(N, SX, INCX, SY, INCY) Uses M_blas \\brief \\b SSWAP\n\\par Purpose: \\verbatim SSWAP interchanges two vectors.\n   uses unrolled loops for increments equal to 1.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] SX\n\\verbatim\n         SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of SX\n\\endverbatim \\param[in,out] SY\n\\verbatim\n         SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of SY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup single_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N real :: SX (*) integer :: INCX real :: SY (*) integer :: INCY Contents Source Code SSWAP Source Code subroutine SSWAP ( N , SX , INCX , SY , INCY ) ! COMMENT --file sswap.3m_blas.man !> \\brief \\b SSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSWAP(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SSWAP interchanges two vectors. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !       code for both increments equal to 1 ! ! !       clean-up loop ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : sswap_ => SSWAP implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SSWAP_ ( N , SX , INCX , SY , INCY ) end subroutine SSWAP","tags":"","loc":"proc/sswap.html"},{"title":"SSYMM – M_blas","text":"subroutine SSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b SSYMM\n\\par Purpose: \\verbatim SSYMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where alpha and beta are scalars,  A is a symmetric matrix and  B and\nC are  m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  symmetric matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  symmetric  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             symmetric matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             symmetric matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is  n otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is REAL array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is REAL array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N real :: ALPHA real :: A (LDA,*) integer :: LDA real :: B (LDB,*) integer :: LDB real :: BETA real :: C (LDC,*) integer :: LDC Contents Source Code SSYMM Source Code subroutine SSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file ssymm.3m_blas.man !> \\brief \\b SSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars,  A is a symmetric matrix and  B and !> C are  m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is  n otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of SSYMM . ! ! END use M_blas , only : ssymm_ => SSYMM implicit none REAL ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SSYMM","tags":"","loc":"proc/ssymm.html"},{"title":"SSYMV – M_blas","text":"subroutine SSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b SSYMV\n\\par Purpose: \\verbatim SSYMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX real :: BETA real :: Y (*) integer :: INCY Contents Source Code SSYMV Source Code subroutine SSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file ssymv.3m_blas.man !> \\brief \\b SSYMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of SSYMV . ! ! END use M_blas , only : ssymv_ => SSYMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSYMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SSYMV","tags":"","loc":"proc/ssymv.html"},{"title":"SSYR2 – M_blas","text":"subroutine SSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b SSYR2\n\\par Purpose: \\verbatim SSYR2  performs the symmetric rank 2 operation A := alpha x y T + alpha y x T + A, where alpha is a scalar, x and y are n element vectors and A is an n\nby n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: X (*) integer :: INCX real :: Y (*) integer :: INCY real :: A (LDA,*) integer :: LDA Contents Source Code SSYR2 Source Code subroutine SSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file ssyr2.3m_blas.man !> \\brief \\b SSYR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of SSYR2 . ! ! END use M_blas , only : ssyr2_ => SSYR2 implicit none REAL ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSYR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine SSYR2","tags":"","loc":"proc/ssyr2.html"},{"title":"SSYR2K – M_blas","text":"subroutine SSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b SSYR2K\n\\par Purpose: \\verbatim SSYR2K  performs one of the symmetric rank 2k operations C := alpha A B T + alpha B A T + beta*C, or C := alpha A T B + alpha B T A + beta*C, where  alpha and beta  are scalars, C is an  n by n  symmetric matrix\nand  A and B  are  n by k  matrices  in the  first  case  and  k by n\nmatrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘T’ or ‘t’ or ‘C’ or ‘c’,  K  specifies  the  number\n          of rows of the matrices  A and B.  K must be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is REAL array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is REAL array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K real :: ALPHA real :: A (LDA,*) integer :: LDA real :: B (LDB,*) integer :: LDB real :: BETA real :: C (LDC,*) integer :: LDC Contents Source Code SSYR2K Source Code subroutine SSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file ssyr2k.3m_blas.man !> \\brief \\b SSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !>                                        beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrices  A and B.  K must be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of SSYR2K. ! ! END use M_blas , only : ssyr2k_ => SSYR2K implicit none REAL ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SSYR2K","tags":"","loc":"proc/ssyr2k.html"},{"title":"SSYR – M_blas","text":"subroutine SSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Uses M_blas \\brief \\b SSYR\n\\par Purpose: \\verbatim SSYR   performs the symmetric rank 1 operation A := alpha x x**T + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n symmetric matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the symmetric matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the symmetric matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N real :: ALPHA real :: X (*) integer :: INCX real :: A (LDA,*) integer :: LDA Contents Source Code SSYR Source Code subroutine SSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file ssyr.3m_blas.man !> \\brief \\b SSYR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR   performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of SSYR  . ! ! END use M_blas , only : ssyr_ => SSYR implicit none REAL ALPHA INTEGER INCX , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ) call SSYR_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine SSYR","tags":"","loc":"proc/ssyr.html"},{"title":"SSYRK – M_blas","text":"subroutine SSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b SSYRK\n\\par Purpose: \\verbatim SSYRK  performs one of the symmetric rank k operations C := alpha A A* T + beta C, or C := alpha A T A + beta*C, where  alpha and beta  are scalars, C is an  n by n  symmetric matrix\nand  A  is an  n by k  matrix in the first case and a  k by n  matrix\nin the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘T’ or ‘t’ or ‘C’ or ‘c’,  K  specifies  the  number\n          of rows of the matrix  A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is REAL\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is REAL array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K real :: ALPHA real :: A (LDA,*) integer :: LDA real :: BETA real :: C (LDC,*) integer :: LDC Contents Source Code SSYRK Source Code subroutine SSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file ssyrk.3m_blas.man !> \\brief \\b SSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrix  A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of SSYRK . ! ! END use M_blas , only : ssyrk_ => SSYRK implicit none REAL ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO REAL A ( LDA , * ), C ( LDC , * ) call SSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine SSYRK","tags":"","loc":"proc/ssyrk.html"},{"title":"STBMV – M_blas","text":"subroutine STBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b STBMV\n\\par Purpose: \\verbatim STBMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular band matrix, with ( k + 1 ) diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX Contents Source Code STBMV Source Code subroutine STBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file stbmv.3m_blas.man !> \\brief \\b STBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STBMV . ! ! END use M_blas , only : stbmv_ => STBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine STBMV","tags":"","loc":"proc/stbmv.html"},{"title":"STBSV – M_blas","text":"subroutine STBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b STBSV\n\\par Purpose: \\verbatim STBSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular band matrix, with ( k + 1 )\ndiagonals. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX Contents Source Code STBSV Source Code subroutine STBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file stbsv.3m_blas.man !> \\brief \\b STBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T)*x. ! ! ! !     End of STBSV . ! ! END use M_blas , only : stbsv_ => STBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine STBSV","tags":"","loc":"proc/stbsv.html"},{"title":"STPMV – M_blas","text":"subroutine STPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b STPMV\n\\par Purpose: \\verbatim STPMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is REAL array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N real :: AP (*) real :: X (*) integer :: INCX Contents Source Code STPMV Source Code subroutine STPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file stpmv.3m_blas.man !> \\brief \\b STPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STPMV . ! ! END use M_blas , only : stpmv_ => STPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO REAL AP ( * ), X ( * ) call STPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine STPMV","tags":"","loc":"proc/stpmv.html"},{"title":"STPSV – M_blas","text":"subroutine STPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b STPSV\n\\par Purpose: \\verbatim STPSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is REAL array, dimension at least\n          ( ( n*( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N real :: AP (*) real :: X (*) integer :: INCX Contents Source Code STPSV Source Code subroutine STPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file stpsv.3m_blas.man !> \\brief \\b STPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of STPSV . ! ! END use M_blas , only : stpsv_ => STPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO REAL AP ( * ), X ( * ) call STPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine STPSV","tags":"","loc":"proc/stpsv.html"},{"title":"STRMM – M_blas","text":"subroutine STRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b STRMM\n\\par Purpose: \\verbatim STRMM  performs one of the matrix-matrix operations B := alpha op( A ) B,   or   B := alpha B op( A ), where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A* T.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER 1\n          On entry,  SIDE specifies whether  op( A ) multiplies B from\n          the left or right as follows: SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**T. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, k ), where k is m\n          when  SIDE = ‘L’ or ‘l’  and is  n  when  SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is REAL array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain the matrix  B,  and  on exit  is overwritten  by the\n          transformed matrix.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N real :: ALPHA real :: A (LDA,*) integer :: LDA real :: B (LDB,*) integer :: LDB Contents Source Code STRMM Source Code subroutine STRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file strmm.3m_blas.man !> \\brief \\b STRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T. ! ! ! !     End of STRMM . ! ! END use M_blas , only : strmm_ => STRMM implicit none REAL ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO REAL A ( LDA , * ), B ( LDB , * ) call STRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine STRMM","tags":"","loc":"proc/strmm.html"},{"title":"STRMV – M_blas","text":"subroutine STRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b STRMV\n\\par Purpose: \\verbatim STRMV  performs one of the matrix-vector operations x := A x,   or   x := A T x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX Contents Source Code STRMV Source Code subroutine STRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file strmv.3m_blas.man !> \\brief \\b STRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STRMV . ! ! END use M_blas , only : strmv_ => STRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine STRMV","tags":"","loc":"proc/strmv.html"},{"title":"STRSM – M_blas","text":"subroutine STRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b STRSM\n\\par Purpose: \\verbatim STRSM  solves one of the matrix equations op( A ) X = alpha B,   or   X op( A ) = alpha B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A**T. The matrix X is overwritten on B.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry, SIDE specifies whether op( A ) appears on the left\n          or right of X as follows: SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n         SIDE = 'R' or 'r'   X*op( A ) = alpha*B. \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**T. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is REAL\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, k ),\n          where k is m when SIDE = ‘L’ or ‘l’\n            and k is n when SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is REAL array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain  the  right-hand  side  matrix  B,  and  on exit  is\n          overwritten by the solution matrix  X.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N real :: ALPHA real :: A (LDA,*) integer :: LDA real :: B (LDB,*) integer :: LDB Contents Source Code STRSM Source Code subroutine STRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file strsm.3m_blas.man !> \\brief \\b STRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ). ! ! ! !     End of STRSM . ! ! END use M_blas , only : strsm_ => STRSM implicit none REAL ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO REAL A ( LDA , * ), B ( LDB , * ) call STRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine STRSM","tags":"","loc":"proc/strsm.html"},{"title":"STRSV – M_blas","text":"subroutine STRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b STRSV\n\\par Purpose: \\verbatim STRSV  solves one of the systems of equations A x = b,   or   A T x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**T*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is REAL array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is REAL array, dimension at least\n          ( 1 + ( n - 1 )*abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup single_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N real :: A (LDA,*) integer :: LDA real :: X (*) integer :: INCX Contents Source Code STRSV Source Code subroutine STRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file strsv.3m_blas.man !> \\brief \\b STRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of STRSV . ! ! END use M_blas , only : strsv_ => STRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine STRSV","tags":"","loc":"proc/strsv.html"},{"title":"XERBLA_ARRAY – M_blas","text":"subroutine XERBLA_ARRAY(SRNAME_ARRAY, SRNAME_LEN, INFO) Uses M_blas \\brief \\b XERBLA_ARRAY\n\\par Purpose: \\verbatim XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK\nand BLAS error handler.  Rather than taking a Fortran string argument\nas the function’s name, XERBLA_ARRAY takes an array of single\ncharacters along with the array’s length.  XERBLA_ARRAY then copies\nup to 32 characters of that array into a Fortran string and passes\nthat to XERBLA.  If called with a non-positive SRNAME_LEN,\nXERBLA_ARRAY will call XERBLA with a string of all blank characters. Say some macro or other device makes XERBLA_ARRAY available to C99\nby a name lapack_xerbla and with a common Fortran calling convention.\nThen a C99 program could invoke XERBLA via:\n   {\n     int flen = strlen( func );\n     lapack_xerbla( func , &flen, &info);\n   } Providing XERBLA_ARRAY is not necessary for intercepting LAPACK\nerrors.  XERBLA_ARRAY calls XERBLA.\n\\endverbatim\n\\param[in] SRNAME_ARRAY\n\\verbatim\n         SRNAME_ARRAY is CHARACTER(*) array, dimension (SRNAME_LEN)\n         The name of the routine which called XERBLA_ARRAY.\n\\endverbatim \\param[in] SRNAME_LEN\n\\verbatim\n         SRNAME_LEN is INTEGER\n         The length of the name in SRNAME_ARRAY.\n\\endverbatim \\param[in] INFO\n\\verbatim\n         INFO is INTEGER\n         The position of the invalid parameter in the parameter list\n         of the calling routine.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup aux_blas Arguments Type Intent Optional Attributes Name character(len=1) :: SRNAME_ARRAY (SRNAME_LEN) integer :: SRNAME_LEN integer :: INFO Contents Source Code XERBLA_ARRAY Source Code subroutine XERBLA_ARRAY ( SRNAME_ARRAY , SRNAME_LEN , INFO ) ! COMMENT --file xerbla_array.3m_blas.man !> \\brief \\b XERBLA_ARRAY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE XERBLA_ARRAY(SRNAME_ARRAY, SRNAME_LEN, INFO) ! !       .. Scalar Arguments .. !       INTEGER SRNAME_LEN, INFO !       .. !       .. Array Arguments .. !       CHARACTER(*) SRNAME_ARRAY(SRNAME_LEN) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK !> and BLAS error handler.  Rather than taking a Fortran string argument !> as the function's name, XERBLA_ARRAY takes an array of single !> characters along with the array's length.  XERBLA_ARRAY then copies !> up to 32 characters of that array into a Fortran string and passes !> that to XERBLA.  If called with a non-positive SRNAME_LEN, !> XERBLA_ARRAY will call XERBLA with a string of all blank characters. !> !> Say some macro or other device makes XERBLA_ARRAY available to C99 !> by a name lapack_xerbla and with a common Fortran calling convention. !> Then a C99 program could invoke XERBLA via: !>    { !>      int flen = strlen(__func__); !>      lapack_xerbla(__func__, &flen, &info); !>    } !> !> Providing XERBLA_ARRAY is not necessary for intercepting LAPACK !> errors.  XERBLA_ARRAY calls XERBLA. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SRNAME_ARRAY !> \\verbatim !>          SRNAME_ARRAY is CHARACTER(*) array, dimension (SRNAME_LEN) !>          The name of the routine which called XERBLA_ARRAY. !> \\endverbatim !> !> \\param[in] SRNAME_LEN !> \\verbatim !>          SRNAME_LEN is INTEGER !>          The length of the name in SRNAME_ARRAY. !> \\endverbatim !> !> \\param[in] INFO !> \\verbatim !>          INFO is INTEGER !>          The position of the invalid parameter in the parameter list !>          of the calling routine. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! ! ===================================================================== ! !     .. !     .. Local Scalars .. !     .. !     .. Local Arrays .. !     .. !     .. Intrinsic Functions .. !     .. !     .. External Functions .. !     .. !     .. Executable Statements .. ! END use M_blas , only : xerbla_array_ => XERBLA_ARRAY implicit none INTEGER SRNAME_LEN , INFO CHARACTER ( len = 1 ) SRNAME_ARRAY ( SRNAME_LEN ) call XERBLA_ARRAY_ ( SRNAME_ARRAY , SRNAME_LEN , INFO ) end subroutine XERBLA_ARRAY","tags":"","loc":"proc/xerbla_array.html"},{"title":"XERBLA – M_blas","text":"subroutine XERBLA(SRNAME, INFO) Uses M_blas \\brief \\b XERBLA\n\\par Purpose: \\verbatim XERBLA  is an error handler for the LAPACK routines.\nIt is called by an LAPACK routine if an input parameter has an\ninvalid value.  A message is printed and execution stops. Installers may consider modifying the STOP statement in order to\ncall system-specific exception-handling facilities.\n\\endverbatim\n\\param[in] SRNAME\n\\verbatim\n         SRNAME is CHARACTER ( )\n         The name of the routine which called XERBLA.\n\\endverbatim \\param[in] INFO\n\\verbatim\n         INFO is INTEGER\n         The position of the invalid parameter in the parameter list\n         of the calling routine.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup aux_blas Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: SRNAME integer, intent(in) :: INFO Contents Source Code XERBLA Source Code subroutine XERBLA ( SRNAME , INFO ) ! COMMENT --file xerbla.3m_blas.man !> \\brief \\b XERBLA ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE XERBLA( SRNAME, INFO ) ! !       .. Scalar Arguments .. !       CHARACTER*(*)      SRNAME !       INTEGER            INFO !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> XERBLA  is an error handler for the LAPACK routines. !> It is called by an LAPACK routine if an input parameter has an !> invalid value.  A message is printed and execution stops. !> !> Installers may consider modifying the STOP statement in order to !> call system-specific exception-handling facilities. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SRNAME !> \\verbatim !>          SRNAME is CHARACTER*(*) !>          The name of the routine which called XERBLA. !> \\endverbatim !> !> \\param[in] INFO !> \\verbatim !>          INFO is INTEGER !>          The position of the invalid parameter in the parameter list !>          of the calling routine. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. ! ! ===================================================================== ! !     .. Intrinsic Functions .. !     .. !     .. Executable Statements .. ! ! ! ! !     End of XERBLA ! ! END use M_blas , only : xerbla_ => XERBLA implicit none CHARACTER ( len =* ), intent ( in ) :: SRNAME INTEGER , intent ( in ) :: INFO call XERBLA_ ( SRNAME , INFO ) END SUBROUTINE XERBLA","tags":"","loc":"proc/xerbla.html"},{"title":"ZAXPY – M_blas","text":"subroutine ZAXPY(N, ZA, ZX, INCX, ZY, INCY) Uses M_blas \\brief \\b ZAXPY\n\\par Purpose: \\verbatim ZAXPY constant times a vector plus a vector.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZA\n\\verbatim\n         ZA is COMPLEX*16\n          On entry, ZA specifies the scalar alpha.\n\\endverbatim \\param[in] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim \\param[in,out] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of ZY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZA complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY Contents Source Code ZAXPY Source Code subroutine ZAXPY ( N , ZA , ZX , INCX , ZY , INCY ) ! COMMENT --file zaxpy.3m_blas.man !> \\brief \\b ZAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZAXPY(N,ZA,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ZA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZAXPY constant times a vector plus a vector. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZA !> \\verbatim !>          ZA is COMPLEX*16 !>           On entry, ZA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! ! END use M_blas , only : zaxpy_ => ZAXPY implicit none COMPLEX * 16 ZA INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZAXPY_ ( N , ZA , ZX , INCX , ZY , INCY ) end subroutine ZAXPY","tags":"","loc":"proc/zaxpy.html"},{"title":"ZCOPY – M_blas","text":"subroutine ZCOPY(N, ZX, INCX, ZY, INCY) Uses M_blas \\brief \\b ZCOPY\n\\par Purpose: \\verbatim ZCOPY copies a vector, x, to a vector, y.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim \\param[out] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of ZY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra, linpack, 4/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY Contents Source Code ZCOPY Source Code subroutine ZCOPY ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zcopy.3m_blas.man !> \\brief \\b ZCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZCOPY(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZCOPY copies a vector, x, to a vector, y. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 4/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zcopy_ => ZCOPY implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZCOPY_ ( N , ZX , INCX , ZY , INCY ) end subroutine ZCOPY","tags":"","loc":"proc/zcopy.html"},{"title":"ZDROT – M_blas","text":"subroutine ZDROT(N, ZX, INCX, ZY, INCY, C, S) Uses M_blas \\brief \\b ZDROT\n\\par Purpose: \\verbatim Applies a plane rotation, where the cos and sin (c and s) are real\nand the vectors cx and cy are complex.\njack dongarra, linpack, 3/11/78.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the vectors cx and cy.\n          N must be at least zero.\n\\endverbatim \\param[in,out] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension at least\n          ( 1 + ( N - 1 ) abs( INCX ) ).\n          Before entry, the incremented array ZX must contain the n\n          element vector cx. On exit, ZX is overwritten by the updated\n          vector cx.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          ZX. INCX must not be zero.\n\\endverbatim \\param[in,out] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension at least\n          ( 1 + ( N - 1 ) abs( INCY ) ).\n          Before entry, the incremented array ZY must contain the n\n          element vector cy. On exit, ZY is overwritten by the updated\n          vector cy.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          ZY. INCY must not be zero.\n\\endverbatim \\param[in] C\n\\verbatim\n         C is DOUBLE PRECISION\n          On entry, C specifies the cosine, cos.\n\\endverbatim \\param[in] S\n\\verbatim\n         S is DOUBLE PRECISION\n          On entry, S specifies the sine, sin.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level1 Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY double precision :: C double precision :: S Contents Source Code ZDROT Source Code subroutine ZDROT ( N , ZX , INCX , ZY , INCY , C , S ) ! COMMENT --file zdrot.3m_blas.man !> \\brief \\b ZDROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZDROT( N, ZX, INCX, ZY, INCY, C, S ) ! !       .. Scalar Arguments .. !       INTEGER            INCX, INCY, N !       DOUBLE PRECISION   C, S !       .. !       .. Array Arguments .. !       COMPLEX*16         ZX( * ), ZY( * ) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> Applies a plane rotation, where the cos and sin (c and s) are real !> and the vectors cx and cy are complex. !> jack dongarra, linpack, 3/11/78. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the vectors cx and cy. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCX ) ). !>           Before entry, the incremented array ZX must contain the n !>           element vector cx. On exit, ZX is overwritten by the updated !>           vector cx. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           ZX. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCY ) ). !>           Before entry, the incremented array ZY must contain the n !>           element vector cy. On exit, ZY is overwritten by the updated !>           vector cy. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           ZY. INCY must not be zero. !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is DOUBLE PRECISION !>           On entry, C specifies the cosine, cos. !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is DOUBLE PRECISION !>           On entry, S specifies the sine, sin. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! ! ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Executable Statements .. ! ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments not equal !          to 1 ! ! END use M_blas , only : zdrot_ => ZDROT implicit none INTEGER INCX , INCY , N DOUBLE PRECISION C , S COMPLEX * 16 ZX ( * ), ZY ( * ) call ZDROT_ ( N , ZX , INCX , ZY , INCY , C , S ) end subroutine ZDROT","tags":"","loc":"proc/zdrot.html"},{"title":"ZDSCAL – M_blas","text":"subroutine ZDSCAL(N, DA, ZX, INCX) Uses M_blas \\brief \\b ZDSCAL\n\\par Purpose: \\verbatim ZDSCAL scales a vector by a constant.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] DA\n\\verbatim\n         DA is DOUBLE PRECISION\n          On entry, DA specifies the scalar alpha.\n\\endverbatim \\param[in,out] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N double precision :: DA complex(kind=16) :: ZX (*) integer :: INCX Contents Source Code ZDSCAL Source Code subroutine ZDSCAL ( N , DA , ZX , INCX ) ! COMMENT --file zdscal.3m_blas.man !> \\brief \\b ZDSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZDSCAL(N,DA,ZX,INCX) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZDSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : zdscal_ => ZDSCAL implicit none DOUBLE PRECISION DA INTEGER INCX , N COMPLEX * 16 ZX ( * ) call ZDSCAL_ ( N , DA , ZX , INCX ) end subroutine ZDSCAL","tags":"","loc":"proc/zdscal.html"},{"title":"ZGBMV – M_blas","text":"subroutine ZGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b ZGBMV\n\\par Purpose: \\verbatim ZGBMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y,   or y := alpha A H x + beta*y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n band matrix, with kl sub-diagonals and ku super-diagonals.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] KL\n\\verbatim\n         KL is INTEGER\n          On entry, KL specifies the number of sub-diagonals of the\n          matrix A. KL must satisfy  0 .le. KL.\n\\endverbatim \\param[in] KU\n\\verbatim\n         KU is INTEGER\n          On entry, KU specifies the number of super-diagonals of the\n          matrix A. KU must satisfy  0 .le. KU.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry, the leading ( kl + ku + 1 ) by n part of the\n          array A must contain the matrix of coefficients, supplied\n          column by column, with the leading diagonal of the matrix in\n          row ( ku + 1 ) of the array, the first super-diagonal\n          starting at position 2 in row ku, the first sub-diagonal\n          starting at position 1 in row ( ku + 2 ), and so on.\n          Elements in the array A that do not correspond to elements\n          in the band matrix (such as the top left ku by ku triangle)\n          are not referenced.\n          The following program segment will transfer a band matrix\n          from conventional full matrix storage to band storage: DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( kl + ku + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N integer :: KL integer :: KU complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: BETA complex(kind=16) :: Y (*) integer :: INCY Contents Source Code ZGBMV Source Code subroutine ZGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zgbmv.3m_blas.man !> \\brief \\b ZGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of ZGBMV . ! ! END use M_blas , only : zgbmv_ => ZGBMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZGBMV","tags":"","loc":"proc/zgbmv.html"},{"title":"ZGEMM – M_blas","text":"subroutine ZGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b ZGEMM\n\\par Purpose: \\verbatim ZGEMM  performs one of the matrix-matrix operations C := alpha op( A ) op( B ) + beta*C, where  op( X ) is one of op( X ) = X   or   op( X ) = X T   or   op( X ) = X H, alpha and beta are scalars, and A, B and C are matrices, with op( A )\nan m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n\\endverbatim\n\\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n',  op( A ) = A.\n\n         TRANSA = 'T' or 't',  op( A ) = A**T.\n\n         TRANSA = 'C' or 'c',  op( A ) = A**H. \\endverbatim \\param[in] TRANSB\n\\verbatim\n         TRANSB is CHARACTER*1\n          On entry, TRANSB specifies the form of op( B ) to be used in\n          the matrix multiplication as follows: TRANSB = 'N' or 'n',  op( B ) = B.\n\n         TRANSB = 'T' or 't',  op( B ) = B**T.\n\n         TRANSB = 'C' or 'c',  op( B ) = B**H. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies  the number  of rows  of the  matrix\n          op( A )  and of the  matrix  C.  M  must  be at least  zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N  specifies the number  of columns of the matrix\n          op( B ) and the number of columns of the matrix C. N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry,  K  specifies  the number of columns of the matrix\n          op( A ) and the number of rows of the matrix op( B ). K must\n          be at least  zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          k  when  TRANSA = ‘N’ or ‘n’,  and is  m  otherwise.\n          Before entry with  TRANSA = ‘N’ or ‘n’,  the leading  m by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by m  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. When  TRANSA = ‘N’ or ‘n’ then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is\n          n  when  TRANSB = ‘N’ or ‘n’,  and is  k  otherwise.\n          Before entry with  TRANSB = ‘N’ or ‘n’,  the leading  k by n\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  n by k  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in the calling (sub) program. When  TRANSB = ‘N’ or ‘n’ then\n          LDB must be at least  max( 1, k ), otherwise  LDB must be at\n          least  max( 1, n ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX 16 array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n  matrix\n          ( alpha op( A ) op( B ) + beta C ).\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANSA character(len=1) :: TRANSB integer :: M integer :: N integer :: K complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB complex(kind=16) :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZGEMM Source Code subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zgemm.3m_blas.man !> \\brief \\b ZGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**H. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**H. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and NROWB  as the number of rows  of  A  and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**H*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**H + beta*C. ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**H*B**H + beta*C. ! ! !           Form  C := alpha*A**H*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**H + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of ZGEMM . ! ! END use M_blas , only : zgemm_ => ZGEMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZGEMM","tags":"","loc":"proc/zgemm.html"},{"title":"ZGEMV – M_blas","text":"subroutine ZGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b ZGEMV\n\\par Purpose: \\verbatim ZGEMV  performs one of the matrix-vector operations y := alpha A x + beta y,   or   y := alpha A T x + beta y,   or y := alpha A H x + beta*y, where alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\\endverbatim\n\\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n          and at least\n          ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.\n          Before entry with BETA non-zero, the incremented array Y\n          must contain the vector y. On exit, Y is overwritten by the\n          updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: TRANS integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: BETA complex(kind=16) :: Y (*) integer :: INCY Contents Source Code ZGEMV Source Code subroutine ZGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zgemv.3m_blas.man !> \\brief \\b ZGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of ZGEMV . ! ! END use M_blas , only : zgemv_ => ZGEMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZGEMV","tags":"","loc":"proc/zgemv.html"},{"title":"ZGERC – M_blas","text":"subroutine ZGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b ZGERC\n\\par Purpose: \\verbatim ZGERC  performs the rank 1 operation A := alpha x y**H + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: Y (*) integer :: INCY complex(kind=16) :: A (LDA,*) integer :: LDA Contents Source Code ZGERC Source Code subroutine ZGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zgerc.3m_blas.man !> \\brief \\b ZGERC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGERC(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGERC  performs the rank 1 operation !> !>    A := alpha*x*y**H + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of ZGERC . ! ! END use M_blas , only : zgerc_ => ZGERC implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGERC_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZGERC","tags":"","loc":"proc/zgerc.html"},{"title":"ZGERU – M_blas","text":"subroutine ZGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b ZGERU\n\\par Purpose: \\verbatim ZGERU  performs the rank 1 operation A := alpha x y**T + A, where alpha is a scalar, x is an m element vector, y is an n element\nvector and A is an m by n matrix.\n\\endverbatim\n\\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of the matrix A.\n          M must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( m - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the m\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry, the leading m by n part of the array A must\n          contain the matrix of coefficients. On exit, A is\n          overwritten by the updated matrix.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: Y (*) integer :: INCY complex(kind=16) :: A (LDA,*) integer :: LDA Contents Source Code ZGERU Source Code subroutine ZGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zgeru.3m_blas.man !> \\brief \\b ZGERU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGERU(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGERU  performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of ZGERU . ! ! END use M_blas , only : zgeru_ => ZGERU implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGERU_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZGERU","tags":"","loc":"proc/zgeru.html"},{"title":"ZHBMV – M_blas","text":"subroutine ZHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b ZHBMV\n\\par Purpose: \\verbatim ZHBMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian band matrix, with k super-diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the band matrix A is being supplied as\n          follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             being supplied.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             being supplied. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry, K specifies the number of super-diagonals of the\n          matrix A. K must satisfy  0 .le. K.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the hermitian matrix, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer the upper\n          triangular part of a hermitian band matrix from conventional\n          full matrix storage to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that the imaginary parts of the diagonal elements need not be set and are assumed to be zero . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the\n          vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the\n          vector y. On exit, Y is overwritten by the updated vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N integer :: K complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: BETA complex(kind=16) :: Y (*) integer :: INCY Contents Source Code ZHBMV Source Code subroutine ZHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhbmv.3m_blas.man !> \\brief \\b ZHBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of ZHBMV . ! ! END use M_blas , only : zhbmv_ => ZHBMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZHBMV","tags":"","loc":"proc/zhbmv.html"},{"title":"ZHEMM – M_blas","text":"subroutine ZHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b ZHEMM\n\\par Purpose: \\verbatim ZHEMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where alpha and beta are scalars, A is an hermitian matrix and  B and\nC are m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  hermitian matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  hermitian  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             hermitian matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             hermitian matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is n  otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  hermitian matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  hermitian matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  hermitian\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  hermitian matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  hermitian matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  hermitian\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Note that the imaginary parts  of the diagonal elements need\n          not be set, they are assumed to be zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the  calling (sub) program. When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB complex(kind=16) :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZHEMM Source Code subroutine ZHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zhemm.3m_blas.man !> \\brief \\b ZHEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHEMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars, A is an hermitian matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  hermitian matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  hermitian  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  hermitian matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  hermitian matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Note that the imaginary parts  of the diagonal elements need !>           not be set, they are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of ZHEMM . ! ! END use M_blas , only : zhemm_ => ZHEMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZHEMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZHEMM","tags":"","loc":"proc/zhemm.html"},{"title":"ZHEMV – M_blas","text":"subroutine ZHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b ZHEMV\n\\par Purpose: \\verbatim ZHEMV  performs the matrix-vector  operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced.\n          Note that the imaginary parts of the diagonal elements need\n          not be set and are assumed to be zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: BETA complex(kind=16) :: Y (*) integer :: INCY Contents Source Code ZHEMV Source Code subroutine ZHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhemv.3m_blas.man !> \\brief \\b ZHEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHEMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHEMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of ZHEMV . ! ! END use M_blas , only : zhemv_ => ZHEMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHEMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZHEMV","tags":"","loc":"proc/zhemv.html"},{"title":"ZHER2 – M_blas","text":"subroutine ZHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Uses M_blas \\brief \\b ZHER2\n\\par Purpose: \\verbatim ZHER2  performs the hermitian rank 2 operation A := alpha x y H + conjg( alpha ) y x H + A, where alpha is a scalar, x and y are n element vectors and A is an n\nby n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: Y (*) integer :: INCY complex(kind=16) :: A (LDA,*) integer :: LDA Contents Source Code ZHER2 Source Code subroutine ZHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zher2.3m_blas.man !> \\brief \\b ZHER2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of ZHER2 . ! ! END use M_blas , only : zher2_ => ZHER2 implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHER2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZHER2","tags":"","loc":"proc/zher2.html"},{"title":"ZHER2K – M_blas","text":"subroutine ZHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b ZHER2K\n\\par Purpose: \\verbatim ZHER2K  performs one of the hermitian rank 2k operations C := alpha A B H + conjg( alpha ) B A H + beta*C, or C := alpha A H B + conjg( alpha ) B H A + beta*C, where  alpha and beta  are scalars with  beta  real,  C is an  n by n\nhermitian matrix and  A and B  are  n by k matrices in the first case\nand  k by n  matrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘C’ or ‘c’,  K  specifies  the number of rows of the\n          matrices  A and B.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16 .\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n          Unchanged on exit.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION .\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  hermitian matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  hermitian matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set,  they are assumed to be zero,  and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.\n    Ed Anderson, Cray Research Inc.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB double precision :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZHER2K Source Code subroutine ZHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zher2k.3m_blas.man !> \\brief \\b ZHER2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       DOUBLE PRECISION BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER2K  performs one of the hermitian rank 2k operations !> !>    C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !> !> where  alpha and beta  are scalars with  beta  real,  C is an  n by n !> hermitian matrix and  A and B  are  n by k matrices in the first case !> and  k by n  matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**H          + !>                                         conjg( alpha )*B*A**H + !>                                         beta*C. !> !>              TRANS = 'C' or 'c'    C := alpha*A**H*B          + !>                                         conjg( alpha )*B**H*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 . !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !>           Unchanged on exit. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION . !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! ! ! !     End of ZHER2K. ! ! END use M_blas , only : zher2k_ => ZHER2K implicit none COMPLEX * 16 ALPHA DOUBLE PRECISION BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZHER2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZHER2K","tags":"","loc":"proc/zher2k.html"},{"title":"ZHER – M_blas","text":"subroutine ZHER(UPLO, N, ALPHA, X, INCX, A, LDA) Uses M_blas \\brief \\b ZHER\n\\par Purpose: \\verbatim ZHER   performs the hermitian rank 1 operation A := alpha x x**H + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n hermitian matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the array A is to be referenced as\n          follows: UPLO = 'U' or 'u'   Only the upper triangular part of A\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of A\n                             is to be referenced. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular part of the hermitian matrix and the strictly\n          lower triangular part of A is not referenced. On exit, the\n          upper triangular part of the array A is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular part of the hermitian matrix and the strictly\n          upper triangular part of A is not referenced. On exit, the\n          lower triangular part of the array A is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: A (LDA,*) integer :: LDA Contents Source Code ZHER Source Code subroutine ZHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file zher.3m_blas.man !> \\brief \\b ZHER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER   performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of ZHER  . ! ! END use M_blas , only : zher_ => ZHER implicit none DOUBLE PRECISION ALPHA INTEGER INCX , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZHER_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine ZHER","tags":"","loc":"proc/zher.html"},{"title":"ZHERK – M_blas","text":"subroutine ZHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b ZHERK\n\\par Purpose: \\verbatim ZHERK  performs one of the hermitian rank k operations C := alpha A A* H + beta C, or C := alpha A H A + beta*C, where  alpha and beta  are  real scalars,  C is an  n by n  hermitian\nmatrix and  A  is an  n by k  matrix in the  first case and a  k by n\nmatrix in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘C’ or ‘c’,  K  specifies  the number of rows of the\n          matrix A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION .\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is DOUBLE PRECISION.\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  hermitian matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  hermitian matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set,  they are assumed to be zero,  and on exit they\n          are set to zero.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.\n    Ed Anderson, Cray Research Inc.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K double precision :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA double precision :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZHERK Source Code subroutine ZHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file zherk.3m_blas.man !> \\brief \\b ZHERK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHERK  performs one of the hermitian rank k operations !> !>    C := alpha*A*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*A + beta*C, !> !> where  alpha and beta  are  real scalars,  C is an  n by n  hermitian !> matrix and  A  is an  n by k  matrix in the  first case and a  k by n !> matrix in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION . !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**H + beta*C. ! ! !        Form  C := alpha*A**H*A + beta*C. ! ! ! !     End of ZHERK . ! ! END use M_blas , only : zherk_ => ZHERK implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), C ( LDC , * ) call ZHERK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine ZHERK","tags":"","loc":"proc/zherk.html"},{"title":"ZHPMV – M_blas","text":"subroutine ZHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Uses M_blas \\brief \\b ZHPMV\n\\par Purpose: \\verbatim ZHPMV  performs the matrix-vector operation y := alpha A x + beta*y, where alpha and beta are scalars, x and y are n element vectors and\nA is an n by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX 16 array, dimension at least\n          ( ( n ( n + 1 ) )/2 ).\n          Before entry with UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on.\n          Note that the imaginary parts of the diagonal elements need\n          not be set and are assumed to be zero.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta. When BETA is\n          supplied as zero then Y need not be set on input.\n\\endverbatim \\param[in,out] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y. On exit, Y is overwritten by the updated\n          vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: AP (*) complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: BETA complex(kind=16) :: Y (*) integer :: INCY Contents Source Code ZHPMV Source Code subroutine ZHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhpmv.3m_blas.man !> \\brief \\b ZHPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of ZHPMV . ! ! END use M_blas , only : zhpmv_ => ZHPMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ), Y ( * ) call ZHPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine ZHPMV","tags":"","loc":"proc/zhpmv.html"},{"title":"ZHPR2 – M_blas","text":"subroutine ZHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Uses M_blas \\brief \\b ZHPR2\n\\par Purpose: \\verbatim ZHPR2  performs the hermitian rank 2 operation A := alpha x y H + conjg( alpha ) y x H + A, where alpha is a scalar, x and y are n element vectors and A is an\nn by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in] Y\n\\verbatim\n         Y is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCY ) ).\n          Before entry, the incremented array Y must contain the n\n          element vector y.\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n          On entry, INCY specifies the increment for the elements of\n          Y. INCY must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is COMPLEX 16 array, dimension at least\n          ( ( n ( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: Y (*) integer :: INCY complex(kind=16) :: AP (*) Contents Source Code ZHPR2 Source Code subroutine ZHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file zhpr2.3m_blas.man !> \\brief \\b ZHPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPR2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of ZHPR2 . ! ! END use M_blas , only : zhpr2_ => ZHPR2 implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ), Y ( * ) call ZHPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine ZHPR2","tags":"","loc":"proc/zhpr2.html"},{"title":"ZHPR – M_blas","text":"subroutine ZHPR(UPLO, N, ALPHA, X, INCX, AP) Uses M_blas \\brief \\b ZHPR\n\\par Purpose: \\verbatim ZHPR    performs the hermitian rank 1 operation A := alpha x x**H + A, where alpha is a real scalar, x is an n element vector and A is an\nn by n hermitian matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the upper or lower\n          triangular part of the matrix A is supplied in the packed\n          array AP as follows: UPLO = 'U' or 'u'   The upper triangular part of A is\n                             supplied in AP.\n\n         UPLO = 'L' or 'l'   The lower triangular part of A is\n                             supplied in AP. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is DOUBLE PRECISION.\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim \\param[in,out] AP\n\\verbatim\n         AP is COMPLEX 16 array, dimension at least\n          ( ( n ( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n          and a( 2, 2 ) respectively, and so on. On exit, the array\n          AP is overwritten by the upper triangular part of the\n          updated matrix.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular part of the hermitian matrix\n          packed sequentially, column by column, so that AP( 1 )\n          contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n          and a( 3, 1 ) respectively, and so on. On exit, the array\n          AP is overwritten by the lower triangular part of the\n          updated matrix.\n          Note that the imaginary parts of the diagonal elements need\n          not be set, they are assumed to be zero, and on exit they\n          are set to zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO integer :: N double precision :: ALPHA complex(kind=16) :: X (*) integer :: INCX complex(kind=16) :: AP (*) Contents Source Code ZHPR Source Code subroutine ZHPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file zhpr.3m_blas.man !> \\brief \\b ZHPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPR    performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of ZHPR  . ! ! END use M_blas , only : zhpr_ => ZHPR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZHPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine ZHPR","tags":"","loc":"proc/zhpr.html"},{"title":"ZROTG – M_blas","text":"subroutine ZROTG(CA, CB, C, S) Uses M_blas \\brief \\b ZROTG\n\\par Purpose: \\verbatim ZROTG determines a double complex Givens rotation.\n\\endverbatim\n\\param[in,out] CA\n\\verbatim\n         CA is COMPLEX*16\n\\endverbatim \\param[in] CB\n\\verbatim\n         CB is COMPLEX*16\n\\endverbatim \\param[out] C\n\\verbatim\n         C is DOUBLE PRECISION\n\\endverbatim \\param[out] S\n\\verbatim\n         S is COMPLEX*16\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1 Arguments Type Intent Optional Attributes Name complex(kind=16) :: CA complex(kind=16) :: CB double precision :: C complex(kind=16) :: S Contents Source Code ZROTG Source Code subroutine ZROTG ( CA , CB , C , S ) ! COMMENT --file zrotg.3m_blas.man !> \\brief \\b ZROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZROTG(CA,CB,C,S) ! !       .. Scalar Arguments .. !       COMPLEX*16 CA,CB,S !       DOUBLE PRECISION C !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZROTG determines a double complex Givens rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] CA !> \\verbatim !>          CA is COMPLEX*16 !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is COMPLEX*16 !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is COMPLEX*16 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : zrotg_ => ZROTG implicit none COMPLEX * 16 CA , CB , S DOUBLE PRECISION C call ZROTG_ ( CA , CB , C , S ) end subroutine ZROTG","tags":"","loc":"proc/zrotg.html"},{"title":"ZSCAL – M_blas","text":"subroutine ZSCAL(N, ZA, ZX, INCX) Uses M_blas \\brief \\b ZSCAL\n\\par Purpose: \\verbatim ZSCAL scales a vector by a constant.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in] ZA\n\\verbatim\n         ZA is COMPLEX*16\n          On entry, ZA specifies the scalar alpha.\n\\endverbatim \\param[in,out] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZA complex(kind=16) :: ZX (*) integer :: INCX Contents Source Code ZSCAL Source Code subroutine ZSCAL ( N , ZA , ZX , INCX ) ! COMMENT --file zscal.3m_blas.man !> \\brief \\b ZSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSCAL(N,ZA,ZX,INCX) ! !       .. Scalar Arguments .. !       COMPLEX*16 ZA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZA !> \\verbatim !>          ZA is COMPLEX*16 !>           On entry, ZA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : zscal_ => ZSCAL implicit none COMPLEX * 16 ZA INTEGER INCX , N COMPLEX * 16 ZX ( * ) call ZSCAL_ ( N , ZA , ZX , INCX ) end subroutine ZSCAL","tags":"","loc":"proc/zscal.html"},{"title":"ZSWAP – M_blas","text":"subroutine ZSWAP(N, ZX, INCX, ZY, INCY) Uses M_blas \\brief \\b ZSWAP\n\\par Purpose: \\verbatim ZSWAP interchanges two vectors.\n\\endverbatim\n\\param[in] N\n\\verbatim\n         N is INTEGER\n        number of elements in input vector(s)\n\\endverbatim \\param[in,out] ZX\n\\verbatim\n         ZX is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n        storage spacing between elements of ZX\n\\endverbatim \\param[in,out] ZY\n\\verbatim\n         ZY is COMPLEX 16 array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n\\endverbatim \\param[in] INCY\n\\verbatim\n         INCY is INTEGER\n        storage spacing between elements of ZY\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date November 2017\n\\ingroup complex16_blas_level1\n\\par Further Details: \\verbatim jack dongarra, 3/11/78.\nmodified 12/3/93, array(1) declarations changed to array(*) \\endverbatim Arguments Type Intent Optional Attributes Name integer :: N complex(kind=16) :: ZX (*) integer :: INCX complex(kind=16) :: ZY (*) integer :: INCY Contents Source Code ZSWAP Source Code subroutine ZSWAP ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zswap.3m_blas.man !> \\brief \\b ZSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSWAP(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZSWAP interchanges two vectors. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : zswap_ => ZSWAP implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZSWAP_ ( N , ZX , INCX , ZY , INCY ) end subroutine ZSWAP","tags":"","loc":"proc/zswap.html"},{"title":"ZSYMM – M_blas","text":"subroutine ZSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b ZSYMM\n\\par Purpose: \\verbatim ZSYMM  performs one of the matrix-matrix operations C := alpha A B + beta*C, or C := alpha B A + beta*C, where  alpha and beta are scalars, A is a symmetric matrix and  B and\nC are m by n matrices.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE  specifies whether  the  symmetric matrix  A\n          appears on the  left or right  in the  operation as follows: SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of  the  symmetric  matrix   A  is  to  be\n          referenced as follows: UPLO = 'U' or 'u'   Only the upper triangular part of the\n                             symmetric matrix is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the lower triangular part of the\n                             symmetric matrix is to be referenced. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry,  M  specifies the number of rows of the matrix  C.\n          M  must be at least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of the matrix C.\n          N  must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          m  when  SIDE = ‘L’ or ‘l’  and is n  otherwise.\n          Before entry  with  SIDE = ‘L’ or ‘l’,  the  m by m  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading m by m upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  m by m  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n          Before entry  with  SIDE = ‘R’ or ‘r’,  the  n by n  part of\n          the array  A  must contain the  symmetric matrix,  such that\n          when  UPLO = ‘U’ or ‘u’, the leading n by n upper triangular\n          part of the array  A  must contain the upper triangular part\n          of the  symmetric matrix and the  strictly  lower triangular\n          part of  A  is not referenced,  and when  UPLO = ‘L’ or ‘l’,\n          the leading  n by n  lower triangular part  of the  array  A\n          must  contain  the  lower triangular part  of the  symmetric\n          matrix and the  strictly upper triangular part of  A  is not\n          referenced.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the  calling (sub) program. When  SIDE = ‘L’ or ‘l’  then\n          LDA must be at least  max( 1, m ), otherwise  LDA must be at\n          least max( 1, n ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, N )\n          Before entry, the leading  m by n part of the array  B  must\n          contain the matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n          supplied as zero then C need not be set on input.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry, the leading  m by n  part of the array  C must\n          contain the matrix  C,  except when  beta  is zero, in which\n          case C need not be set on entry.\n          On exit, the array  C  is overwritten by the  m by n updated\n          matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB complex(kind=16) :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZSYMM Source Code subroutine ZSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zsymm.3m_blas.man !> \\brief \\b ZSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where  alpha and beta are scalars, A is a symmetric matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of ZSYMM . ! ! END use M_blas , only : zsymm_ => ZSYMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZSYMM","tags":"","loc":"proc/zsymm.html"},{"title":"ZSYR2K – M_blas","text":"subroutine ZSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses M_blas \\brief \\b ZSYR2K\n\\par Purpose: \\verbatim ZSYR2K  performs one of the symmetric rank 2k operations C := alpha A B T + alpha B A T + beta*C, or C := alpha A T B + alpha B T A + beta*C, where  alpha and beta  are scalars,  C is an  n by n symmetric matrix\nand  A and B  are  n by k  matrices  in the  first  case  and  k by n\nmatrices in the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns  of the  matrices  A and B,  and on  entry  with\n          TRANS = ‘T’ or ‘t’,  K  specifies  the number of rows of the\n          matrices  A and B.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  B  must contain the matrix  B,  otherwise\n          the leading  k by n  part of the array  B  must contain  the\n          matrix B.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDB must be at least  max( 1, n ), otherwise  LDB must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB complex(kind=16) :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZSYR2K Source Code subroutine ZSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zsyr2k.3m_blas.man !> \\brief \\b ZSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !>                                         beta*C. !> !>              TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of ZSYR2K. ! ! END use M_blas , only : zsyr2k_ => ZSYR2K implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZSYR2K","tags":"","loc":"proc/zsyr2k.html"},{"title":"ZSYRK – M_blas","text":"subroutine ZSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Uses M_blas \\brief \\b ZSYRK\n\\par Purpose: \\verbatim ZSYRK  performs one of the symmetric rank k operations C := alpha A A* T + beta C, or C := alpha A T A + beta*C, where  alpha and beta  are scalars,  C is an  n by n symmetric matrix\nand  A  is an  n by k  matrix in the first case and a  k by n  matrix\nin the second case.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On  entry,   UPLO  specifies  whether  the  upper  or  lower\n          triangular  part  of the  array  C  is to be  referenced  as\n          follows: UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                             is to be referenced.\n\n         UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                             is to be referenced. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry,  TRANS  specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry,  N specifies the order of the matrix C.  N must be\n          at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with  TRANS = ‘N’ or ‘n’,  K  specifies  the number\n          of  columns   of  the   matrix   A,   and  on   entry   with\n          TRANS = ‘T’ or ‘t’,  K  specifies  the number of rows of the\n          matrix A.  K must be at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry, ALPHA specifies the scalar alpha.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n          k  when  TRANS = ‘N’ or ‘n’,  and is  n  otherwise.\n          Before entry with  TRANS = ‘N’ or ‘n’,  the  leading  n by k\n          part of the array  A  must contain the matrix  A,  otherwise\n          the leading  k by n  part of the array  A  must contain  the\n          matrix A.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in  the  calling  (sub)  program.   When  TRANS = ‘N’ or ‘n’\n          then  LDA must be at least  max( 1, n ), otherwise  LDA must\n          be at least  max( 1, k ).\n\\endverbatim \\param[in] BETA\n\\verbatim\n         BETA is COMPLEX*16\n          On entry, BETA specifies the scalar beta.\n\\endverbatim \\param[in,out] C\n\\verbatim\n         C is COMPLEX*16 array, dimension ( LDC, N )\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the leading  n by n\n          upper triangular part of the array C must contain the upper\n          triangular part  of the  symmetric matrix  and the strictly\n          lower triangular part of C is not referenced.  On exit, the\n          upper triangular part of the array  C is overwritten by the\n          upper triangular part of the updated matrix.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the leading  n by n\n          lower triangular part of the array C must contain the lower\n          triangular part  of the  symmetric matrix  and the strictly\n          upper triangular part of C is not referenced.  On exit, the\n          lower triangular part of the array  C is overwritten by the\n          lower triangular part of the updated matrix.\n\\endverbatim \\param[in] LDC\n\\verbatim\n         LDC is INTEGER\n          On entry, LDC specifies the first dimension of C as declared\n          in  the  calling  (sub)  program.   LDC  must  be  at  least\n          max( 1, n ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS integer :: N integer :: K complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: BETA complex(kind=16) :: C (LDC,*) integer :: LDC Contents Source Code ZSYRK Source Code subroutine ZSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file zsyrk.3m_blas.man !> \\brief \\b ZSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of ZSYRK . ! ! END use M_blas , only : zsyrk_ => ZSYRK implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), C ( LDC , * ) call ZSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine ZSYRK","tags":"","loc":"proc/zsyrk.html"},{"title":"ZTBMV – M_blas","text":"subroutine ZTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b ZTBMV\n\\par Purpose: \\verbatim ZTBMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular band matrix, with ( k + 1 ) diagonals.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N ).\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTBMV Source Code subroutine ZTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ztbmv.3m_blas.man !> \\brief \\b ZTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ). !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTBMV . ! ! END use M_blas , only : ztbmv_ => ZTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine ZTBMV","tags":"","loc":"proc/ztbmv.html"},{"title":"ZTBSV – M_blas","text":"subroutine ZTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Uses M_blas \\brief \\b ZTBSV\n\\par Purpose: \\verbatim ZTBSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular band matrix, with ( k + 1 )\ndiagonals. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] K\n\\verbatim\n         K is INTEGER\n          On entry with UPLO = ‘U’ or ‘u’, K specifies the number of\n          super-diagonals of the matrix A.\n          On entry with UPLO = ‘L’ or ‘l’, K specifies the number of\n          sub-diagonals of the matrix A.\n          K must satisfy  0 .le. K.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with UPLO = ‘U’ or ‘u’, the leading ( k + 1 )\n          by n part of the array A must contain the upper triangular\n          band part of the matrix of coefficients, supplied column by\n          column, with the leading diagonal of the matrix in row\n          ( k + 1 ) of the array, the first super-diagonal starting at\n          position 2 in row k, and so on. The top left k by k triangle\n          of the array A is not referenced.\n          The following program segment will transfer an upper\n          triangular band matrix from conventional full matrix storage\n          to band storage: DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . \\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          ( k + 1 ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N integer :: K complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTBSV Source Code subroutine ZTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ztbsv.3m_blas.man !> \\brief \\b ZTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTBSV . ! ! END use M_blas , only : ztbsv_ => ZTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine ZTBSV","tags":"","loc":"proc/ztbsv.html"},{"title":"ZTPMV – M_blas","text":"subroutine ZTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b ZTPMV\n\\par Purpose: \\verbatim ZTPMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix, supplied in packed form.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX 16 array, dimension at least\n          ( ( n ( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex(kind=16) :: AP (*) complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTPMV Source Code subroutine ZTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ztpmv.3m_blas.man !> \\brief \\b ZTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTPMV . ! ! END use M_blas , only : ztpmv_ => ZTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine ZTPMV","tags":"","loc":"proc/ztpmv.html"},{"title":"ZTPSV – M_blas","text":"subroutine ZTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Uses M_blas \\brief \\b ZTPSV\n\\par Purpose: \\verbatim ZTPSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] AP\n\\verbatim\n         AP is COMPLEX 16 array, dimension at least\n          ( ( n ( n + 1 ) )/2 ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the array AP must\n          contain the upper triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n          respectively, and so on.\n          Before entry with UPLO = ‘L’ or ‘l’, the array AP must\n          contain the lower triangular matrix packed sequentially,\n          column by column, so that AP( 1 ) contains a( 1, 1 ),\n          AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n          respectively, and so on.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced, but are assumed to be unity.\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex(kind=16) :: AP (*) complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTPSV Source Code subroutine ZTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ztpsv.3m_blas.man !> \\brief \\b ZTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTPSV . ! ! END use M_blas , only : ztpsv_ => ZTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine ZTPSV","tags":"","loc":"proc/ztpsv.html"},{"title":"ZTRMM – M_blas","text":"subroutine ZTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b ZTRMM\n\\par Purpose: \\verbatim ZTRMM  performs one of the matrix-matrix operations B := alpha op( A ) B,   or   B := alpha B op( A ) where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A T   or   op( A ) = A H.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry,  SIDE specifies whether  op( A ) multiplies B from\n          the left or right as follows: SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**H. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, k ), where k is m\n          when  SIDE = ‘L’ or ‘l’  and is  n  when  SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, N ).\n          Before entry,  the leading  m by n part of the array  B must\n          contain the matrix  B,  and  on exit  is overwritten  by the\n          transformed matrix.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB Contents Source Code ZTRMM Source Code subroutine ZTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ztrmm.3m_blas.man !> \\brief \\b ZTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ). !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! ! ! !     End of ZTRMM . ! ! END use M_blas , only : ztrmm_ => ZTRMM implicit none COMPLEX * 16 ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ) call ZTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine ZTRMM","tags":"","loc":"proc/ztrmm.html"},{"title":"ZTRMV – M_blas","text":"subroutine ZTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b ZTRMV\n\\par Purpose: \\verbatim ZTRMV  performs one of the matrix-vector operations x := A x,   or   x := A T x,   or   x := A* H x, where x is an n element vector and  A is an n by n unit, or non-unit,\nupper or lower triangular matrix.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the operation to be performed as\n          follows: TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N ).\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element vector x. On exit, X is overwritten with the\n          transformed vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine.\n The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTRMV Source Code subroutine ZTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ztrmv.3m_blas.man !> \\brief \\b ZTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ). !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTRMV . ! ! END use M_blas , only : ztrmv_ => ZTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine ZTRMV","tags":"","loc":"proc/ztrmv.html"},{"title":"ZTRSM – M_blas","text":"subroutine ZTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Uses M_blas \\brief \\b ZTRSM\n\\par Purpose: \\verbatim ZTRSM  solves one of the matrix equations op( A ) X = alpha B,   or   X op( A ) = alpha B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of op( A ) = A   or   op( A ) = A T   or   op( A ) = A H. The matrix X is overwritten on B.\n\\endverbatim\n\\param[in] SIDE\n\\verbatim\n         SIDE is CHARACTER*1\n          On entry, SIDE specifies whether op( A ) appears on the left\n          or right of X as follows: SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n         SIDE = 'R' or 'r'   X*op( A ) = alpha*B. \\endverbatim \\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix A is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANSA\n\\verbatim\n         TRANSA is CHARACTER*1\n          On entry, TRANSA specifies the form of op( A ) to be used in\n          the matrix multiplication as follows: TRANSA = 'N' or 'n'   op( A ) = A.\n\n         TRANSA = 'T' or 't'   op( A ) = A**T.\n\n         TRANSA = 'C' or 'c'   op( A ) = A**H. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit triangular\n          as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] M\n\\verbatim\n         M is INTEGER\n          On entry, M specifies the number of rows of B. M must be at\n          least zero.\n\\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the number of columns of B.  N must be\n          at least zero.\n\\endverbatim \\param[in] ALPHA\n\\verbatim\n         ALPHA is COMPLEX*16\n          On entry,  ALPHA specifies the scalar  alpha. When  alpha is\n          zero then  A is not referenced and  B need not be set before\n          entry.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, k ),\n          where k is m when SIDE = ‘L’ or ‘l’\n            and k is n when SIDE = ‘R’ or ‘r’.\n          Before entry  with  UPLO = ‘U’ or ‘u’,  the  leading  k by k\n          upper triangular part of the array  A must contain the upper\n          triangular matrix  and the strictly lower triangular part of\n          A is not referenced.\n          Before entry  with  UPLO = ‘L’ or ‘l’,  the  leading  k by k\n          lower triangular part of the array  A must contain the lower\n          triangular matrix  and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’,  the diagonal elements of\n          A  are not referenced either,  but are assumed to be  unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program.  When  SIDE = ‘L’ or ‘l’  then\n          LDA  must be at least  max( 1, m ),  when  SIDE = ‘R’ or ‘r’\n          then LDA must be at least max( 1, n ).\n\\endverbatim \\param[in,out] B\n\\verbatim\n         B is COMPLEX*16 array, dimension ( LDB, N )\n          Before entry,  the leading  m by n part of the array  B must\n          contain  the  right-hand  side  matrix  B,  and  on exit  is\n          overwritten by the solution matrix  X.\n\\endverbatim \\param[in] LDB\n\\verbatim\n         LDB is INTEGER\n          On entry, LDB specifies the first dimension of B as declared\n          in  the  calling  (sub)  program.   LDB  must  be  at  least\n          max( 1, m ).\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level3\n\\par Further Details: \\verbatim Level 3 Blas routine. – Written on 8-February-1989.\n    Jack Dongarra, Argonne National Laboratory.\n    Iain Duff, AERE Harwell.\n    Jeremy Du Croz, Numerical Algorithms Group Ltd.\n    Sven Hammarling, Numerical Algorithms Group Ltd.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: SIDE character(len=1) :: UPLO character(len=1) :: TRANSA character(len=1) :: DIAG integer :: M integer :: N complex(kind=16) :: ALPHA complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: B (LDB,*) integer :: LDB Contents Source Code ZTRSM Source Code subroutine ZTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ztrsm.3m_blas.man !> \\brief \\b ZTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! ! ! !     End of ZTRSM . ! ! END use M_blas , only : ztrsm_ => ZTRSM implicit none COMPLEX * 16 ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ) call ZTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine ZTRSM","tags":"","loc":"proc/ztrsm.html"},{"title":"ZTRSV – M_blas","text":"subroutine ZTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Uses M_blas \\brief \\b ZTRSV\n\\par Purpose: \\verbatim ZTRSV  solves one of the systems of equations A x = b,   or   A T x = b,   or   A* H x = b, where b and x are n element vectors and A is an n by n unit, or\nnon-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\nroutine. Such tests must be performed before calling this routine.\n\\endverbatim\n\\param[in] UPLO\n\\verbatim\n         UPLO is CHARACTER*1\n          On entry, UPLO specifies whether the matrix is an upper or\n          lower triangular matrix as follows: UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n         UPLO = 'L' or 'l'   A is a lower triangular matrix. \\endverbatim \\param[in] TRANS\n\\verbatim\n         TRANS is CHARACTER*1\n          On entry, TRANS specifies the equations to be solved as\n          follows: TRANS = 'N' or 'n'   A*x = b.\n\n         TRANS = 'T' or 't'   A**T*x = b.\n\n         TRANS = 'C' or 'c'   A**H*x = b. \\endverbatim \\param[in] DIAG\n\\verbatim\n         DIAG is CHARACTER*1\n          On entry, DIAG specifies whether or not A is unit\n          triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n         DIAG = 'N' or 'n'   A is not assumed to be unit\n                             triangular. \\endverbatim \\param[in] N\n\\verbatim\n         N is INTEGER\n          On entry, N specifies the order of the matrix A.\n          N must be at least zero.\n\\endverbatim \\param[in] A\n\\verbatim\n         A is COMPLEX*16 array, dimension ( LDA, N )\n          Before entry with  UPLO = ‘U’ or ‘u’, the leading n by n\n          upper triangular part of the array A must contain the upper\n          triangular matrix and the strictly lower triangular part of\n          A is not referenced.\n          Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n          lower triangular part of the array A must contain the lower\n          triangular matrix and the strictly upper triangular part of\n          A is not referenced.\n          Note that when  DIAG = ‘U’ or ‘u’, the diagonal elements of\n          A are not referenced either, but are assumed to be unity.\n\\endverbatim \\param[in] LDA\n\\verbatim\n         LDA is INTEGER\n          On entry, LDA specifies the first dimension of A as declared\n          in the calling (sub) program. LDA must be at least\n          max( 1, n ).\n\\endverbatim \\param[in,out] X\n\\verbatim\n         X is COMPLEX 16 array, dimension at least\n          ( 1 + ( n - 1 ) abs( INCX ) ).\n          Before entry, the incremented array X must contain the n\n          element right-hand side vector b. On exit, X is overwritten\n          with the solution vector x.\n\\endverbatim \\param[in] INCX\n\\verbatim\n         INCX is INTEGER\n          On entry, INCX specifies the increment for the elements of\n          X. INCX must not be zero.\n\\endverbatim\n\\author Univ. of Tennessee\n\\author Univ. of California Berkeley\n\\author Univ. of Colorado Denver\n\\author NAG Ltd.\n\\date December 2016\n\\ingroup complex16_blas_level2\n\\par Further Details: \\verbatim Level 2 Blas routine. – Written on 22-October-1986.\n    Jack Dongarra, Argonne National Lab.\n    Jeremy Du Croz, Nag Central Office.\n    Sven Hammarling, Nag Central Office.\n    Richard Hanson, Sandia National Labs.\n\\endverbatim Arguments Type Intent Optional Attributes Name character(len=1) :: UPLO character(len=1) :: TRANS character(len=1) :: DIAG integer :: N complex(kind=16) :: A (LDA,*) integer :: LDA complex(kind=16) :: X (*) integer :: INCX Contents Source Code ZTRSV Source Code subroutine ZTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ztrsv.3m_blas.man !> \\brief \\b ZTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTRSV . ! ! END use M_blas , only : ztrsv_ => ZTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine ZTRSV","tags":"","loc":"proc/ztrsv.html"},{"title":"cdotc – M_blas","text":"public  function cdotc(n, cx, incx, cy, incy) NAME cdotc ( 3 f ) - [ BLAS : COMPLEX_BLAS_LEVEL1 ] CDOTC := SUM CONJUGATE ( CX ) * CY ( conjugated vector do t product ) SYNOPSIS complex function cdotc(n,cx,incx,cy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) ::  incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex,intent(in) ::  cx(*),cy(*)\n   .. DEFINITION CDOTC forms the dot product of two complex vectors CDOTC = X&#94;H * Y OPTIONS N     number of elements in input vector(s)\n   CX    array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX  storage spacing between elements of CX\n   CY    array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY  storage spacing between elements of CY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS\n      jack dongarra, linpack,  3/11/78.\n      modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(in) :: cy (*) integer, intent(in) :: incy Return Value complex Contents Variables ctemp i ix iy Source Code cdotc Variables Type Visibility Attributes Name Initial complex, public :: ctemp integer, public :: i integer, public :: ix integer, public :: iy Source Code complex function cdotc ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ctemp = ( 0.0 , 0.0 ) cdotc = ( 0.0 , 0.0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = ctemp + conjg ( cx ( i )) * cy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = ctemp + conjg ( cx ( ix )) * cy ( iy ) ix = ix + incx iy = iy + incy enddo endif cdotc = ctemp end function cdotc","tags":"","loc":"proc/cdotc.html"},{"title":"cdotu – M_blas","text":"public  function cdotu(n, cx, incx, cy, incy) NAME cdotu ( 3 f ) - [ BLAS : COMPLEX_BLAS_LEVEL1 ] CDOTU := SUM CX * CY ( unconjugated vector do t product ) SYNOPSIS complex function cdotu(n,cx,incx,cy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) ::  incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex,intent(in) ::  cx(*),cy(*)\n   .. DEFINITION CDOTU forms the dot product of two complex vectors CDOTU = X&#94;T * Y OPTIONS N\n          number of elements in input vector(s)\n   CX\n          array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX\n          storage spacing between elements of CX\n   CY\n          array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY\n          storage spacing between elements of CY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS\n      jack dongarra, linpack, 3/11/78.\n      modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(in) :: cy (*) integer, intent(in) :: incy Return Value complex Contents Variables ctemp i ix iy Source Code cdotu Variables Type Visibility Attributes Name Initial complex, public :: ctemp integer, public :: i integer, public :: ix integer, public :: iy Source Code complex function cdotu ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. ctemp = ( 0.0 , 0.0 ) cdotu = ( 0.0 , 0.0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = ctemp + cx ( i ) * cy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = ctemp + cx ( ix ) * cy ( iy ) ix = ix + incx iy = iy + incy enddo endif cdotu = ctemp end function cdotu","tags":"","loc":"proc/cdotu.html"},{"title":"dasum – M_blas","text":"public pure function dasum(n, dx, incx) NAME dasum(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] takes the sum of the absolute values. SYNOPSIS double precision function dasum(n,dx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in) :: dx(*)\n   .. DEFINITION DASUM takes the sum of the absolute values. OPTIONS N N is INTEGER\n      number of elements in input vector(s) DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx Return Value doubleprecision Contents Variables dtemp i m mp1 nincx Source Code dasum Variables Type Visibility Attributes Name Initial double precision, public :: dtemp integer, public :: i integer, public :: m integer, public :: mp1 integer, public :: nincx Source Code pure double precision function dasum ( n , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic dabs , mod !     .. dasum = 0.0d0 dtemp = 0.0d0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 6 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dtemp + dabs ( dx ( i )) enddo if ( n . lt . 6 ) then dasum = dtemp return endif endif mp1 = m + 1 do i = mp1 , n , 6 dtemp = dtemp + dabs ( dx ( i )) + dabs ( dx ( i + 1 )) + dabs ( dx ( i + 2 )) + dabs ( dx ( i + 3 )) + dabs ( dx ( i + 4 )) + dabs ( dx ( i + 5 )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx dtemp = dtemp + dabs ( dx ( i )) enddo endif dasum = dtemp end function dasum","tags":"","loc":"proc/dasum.html"},{"title":"dcabs1 – M_blas","text":"public pure function dcabs1(z) NAME dcabs1(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] DCABS1 computes\n|Re(.)| + |Im(.)| of a double complex number SYNOPSIS double precision function dcabs1(z)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in) ::  Z\n   .. DEFINITION DCABS1 computes |Re(.)| + |Im(.)| of a double complex number OPTIONS Z Z is complex(kind=real64) AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: z Return Value doubleprecision Contents Source Code dcabs1 Source Code pure double precision function dcabs1 ( z ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: z !     .. !  ===================================================================== ! !     .. Intrinsic Functions .. intrinsic abs , dble , dimag ! dcabs1 = abs ( dble ( z )) + abs ( dimag ( z )) end function dcabs1","tags":"","loc":"proc/dcabs1.html"},{"title":"ddot – M_blas","text":"public pure function ddot(n, dx, incx, dy, incy) NAME ddot(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] forms the dot product of two vectors. SYNOPSIS double precision function ddot(n,dx,incx,dy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in) :: dx(*),dy(*)\n   .. DEFINITION DDOT forms the dot product of two vectors . uses unrolled loops for increments equal to one . OPTIONS N N is INTEGER\n      number of elements in input vector(s) DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX DY DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of DY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(in) :: dy (*) integer, intent(in) :: incy Return Value doubleprecision Contents Variables dtemp i ix iy m mp1 Source Code ddot Variables Type Visibility Attributes Name Initial double precision, public :: dtemp integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code pure double precision function ddot ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. ddot = 0.0d0 dtemp = 0.0d0 if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) enddo if ( n . lt . 5 ) then ddot = dtemp return endif endif mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy enddo endif ddot = dtemp end function ddot","tags":"","loc":"proc/ddot.html"},{"title":"dnrm2 – M_blas","text":"public pure function dnrm2(n, x, incx) NAME dnrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] returns the euclidean norm of\na vector via the function name SYNOPSIS double precision function dnrm2(n,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx, n\n   ..\n   .. Array Arguments ..\n   real(wp),intent(in) :: x(*)\n    .. DEFINITION DNRM2 returns the euclidean norm of a vector via the function\n  name, so that DNRM2 := sqrt ( x '* x ) OPTIONS N\n           number of elements in input vector(s)\n   X\n           X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX\n           INCX is INTEGER, storage spacing between elements of X If INCX > 0 , X ( 1 + ( i - 1 ) * INCX ) = x ( i ) for 1 <= i <= n If INCX < 0 , X ( 1 - ( n - i ) * INCX ) = x ( i ) for 1 <= i <= n If INCX = 0 , x isn ' t a vector so there is no need to call this subroutine . If you call it anyway , it will count x ( 1 ) in the vector norm N times . AUTHORS Edward Anderson, Lockheed Martin date:August 2016 \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 Blue, James L. (1978)\n   A Portable Fortran Program to Find the Euclidean Norm of a Vector\n   ACM Trans Math Softw 4:15–23\n   https://doi.org/10.1145/355769.355771 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) Contents Variables abig amed asml ax i ix maxn notbig one sbig scl ssml sumsq tbig tsml wp ymax ymin zero Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abig real(kind=wp), public :: amed real(kind=wp), public :: asml real(kind=wp), public :: ax integer, public :: i integer, public :: ix real(kind=wp), public, parameter :: maxn = huge(0.0_wp) logical, public :: notbig real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: sbig = real(radix(0._wp), wp)**(-ceiling((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp)) real(kind=wp), public :: scl real(kind=wp), public, parameter :: ssml = real(radix(0._wp), wp)**(-floor((minexponent(0._wp)-1)*0.5_wp)) real(kind=wp), public :: sumsq real(kind=wp), public, parameter :: tbig = real(radix(0._wp), wp)**floor((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp) real(kind=wp), public, parameter :: tsml = real(radix(0._wp), wp)**ceiling((minexponent(0._wp)-1)*0.5_wp) integer, public, parameter :: wp = kind(1.d0) real(kind=wp), public :: ymax real(kind=wp), public :: ymin real(kind=wp), public, parameter :: zero = 0.0_wp","tags":"","loc":"proc/dnrm2.html"},{"title":"dsdot – M_blas","text":"public pure function dsdot(n, sx, incx, sy, incy) NAME dsdot(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] SYNOPSIS double precision function dsdot(n,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in) :: sx(*),sy(*)\n   .. DEFINITION Compute the inner product of two vectors with extended\n  precision accumulation and result. Returns D.P. dot product accumulated in D.P., for S.P. SX and SY\n  DSDOT = sum for I = 0 to N-1 of SX(LX+I INCX) * SY(LY+I INCY),\n  where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is\n  defined in a similar way using INCY. OPTIONS N       number of elements in input vector(s)\n  SX      array, dimension(N)\n          single precision vector with N elements\n  INCX    storage spacing between elements of SX\n  SY      array, dimension(N)\n          single precision vector with N elements\n  INCY    storage spacing between elements of SY RETURN DSDOT   dot product (zero if N.LE.0) AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Lawson, C. L., (JPL), Hanson, R. J., (SNLA),\n Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) REFERENCES C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.\n   Krogh, Basic linear algebra subprograms for Fortran\n   usage, Algorithm No. 539, Transactions on Mathematical\n   Software 5, 3 (September 1979), pp. 308-323. REVISION HISTORY 1979-10-01  DATE WRITTEN\n  1989-08-31  Modified array declarations. (WRB)\n  1989-08-31  REVISION DATE from Version 3.2\n  1989-12-14  Prologue converted to Version 4.0 format. (BAB)\n  1992-03-10  Corrected definition of LX in DESCRIPTION. (WRB)\n  1992-05-01  Reformatted the REFERENCES section. (WRB)\n  1907-01-18  Reformat to LAPACK style (JL) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value doubleprecision Contents Variables i kx ky ns Source Code dsdot Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: kx integer, public :: ky integer, public :: ns Source Code pure double precision function dsdot ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. ! !  Authors: !  ======== !  Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !  Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) !  ===================================================================== ! !     .. Local Scalars .. integer i , kx , ky , ns !     .. !     .. Intrinsic Functions .. intrinsic dble !     .. dsdot = 0.0d0 if ( n . le . 0 ) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! !     Code for equal, positive, non-unit increments. ! ns = n * incx do i = 1 , ns , incx dsdot = dsdot + dble ( sx ( i )) * dble ( sy ( i )) enddo else ! !     Code for unequal or nonpositive increments. ! kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy do i = 1 , n dsdot = dsdot + dble ( sx ( kx )) * dble ( sy ( ky )) kx = kx + incx ky = ky + incy enddo endif end function dsdot","tags":"","loc":"proc/dsdot.html"},{"title":"dzasum – M_blas","text":"public  function dzasum(n, zx, incx) NAME dzasum(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] SYNOPSIS double precision function dzasum(n,zx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(inout) :: zx(*)\n   .. DEFINITION DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and\n returns a double precision result. OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx Return Value doubleprecision Contents Variables i nincx stemp Source Code dzasum Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx double precision, public :: stemp Source Code double precision function dzasum ( n , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision stemp integer i , nincx !     .. !     .. External Functions ..  DOUBLE PRECISION DCABS1 !     .. dzasum = 0.0d0 stemp = 0.0d0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n stemp = stemp + dcabs1 ( zx ( i )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + dcabs1 ( zx ( i )) enddo endif dzasum = stemp end function dzasum","tags":"","loc":"proc/dzasum.html"},{"title":"dznrm2 – M_blas","text":"public pure function dznrm2(n, x, incx) NAME dznrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SYNOPSIS double precision function dznrm2(n,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx, n\n   .. DEFINITION DZNRM2 returns the euclidean norm of a vector via the function\n  name, so that DZNRM2 := sqrt ( x ** H * x ) OPTIONS N\n          number of elements in input vector(s)\n   X\n          array, dimension (N) complex vector with N elements\n   INCX\n           INCX is INTEGER, storage spacing between elements of X If INCX > 0 , X ( 1 + ( i - 1 ) * INCX ) = x ( i ) for 1 <= i <= n If INCX < 0 , X ( 1 - ( n - i ) * INCX ) = x ( i ) for 1 <= i <= n If INCX = 0 , x isn ' t a vector so there is no need to call this subroutine . If you call it anyway , it will count x ( 1 ) in the vector norm N times . AUTHORS Edward Anderson, Lockheed Martin date:August 2016 \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 Blue, James L. (1978)\n   A Portable Fortran Program to Find the Euclidean Norm of a Vector\n   ACM Trans Math Softw 4:15–23\n   https://doi.org/10.1145/355769.355771 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) Contents Variables abig amed asml ax i ix maxn notbig one sbig scl ssml sumsq tbig tsml wp ymax ymin zero Source Code dznrm2 Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abig real(kind=wp), public :: amed real(kind=wp), public :: asml real(kind=wp), public :: ax integer, public :: i integer, public :: ix real(kind=wp), public, parameter :: maxn = huge(0.0_wp) logical, public :: notbig real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: sbig = real(radix(0._wp), wp)**(-ceiling((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp)) real(kind=wp), public :: scl real(kind=wp), public, parameter :: ssml = real(radix(0._wp), wp)**(-floor((minexponent(0._wp)-1)*0.5_wp)) real(kind=wp), public :: sumsq real(kind=wp), public, parameter :: tbig = real(radix(0._wp), wp)**floor((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp) real(kind=wp), public, parameter :: tsml = real(radix(0._wp), wp)**ceiling((minexponent(0._wp)-1)*0.5_wp) integer, public, parameter :: wp = kind(1.d0) real(kind=wp), public :: ymax real(kind=wp), public :: ymin real(kind=wp), public, parameter :: zero = 0.0_wp Source Code pure function dznrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.d0 ) real ( wp ) :: dznrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. complex ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! dznrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( real ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ax = abs ( aimag ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif dznrm2 = scl * sqrt ( sumsq ) end function dznrm2","tags":"","loc":"proc/dznrm2.html"},{"title":"icamax – M_blas","text":"public pure function icamax(n, cx, incx) NAME icamax ( 3 f ) -- [ BLAS : AUX_BLAS ] Return index of maximum \" absolute value \" in CX . SYNOPSIS integer function icamax(n,cx,incx)\n\n   .. scalar arguments ..\n   integer,intent(in) :: incx,n\n   ..\n   .. array arguments ..\n   complex,intent(in) :: cx(*)\n   .. DEFINITION ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| OPTIONS N N is INTEGER\n      number of elements in input vector(s) CX CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of CX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx Return Value integer Contents Variables i ix smax Source Code icamax Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix real, public :: smax Source Code pure integer function icamax ( n , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real smax integer i , ix !     .. !     .. External Functions ..  REAL SCABS1 !     .. icamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return icamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! smax = scabs1 ( cx ( 1 )) do i = 2 , n if ( scabs1 ( cx ( i )). gt . smax ) then icamax = i smax = scabs1 ( cx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 smax = scabs1 ( cx ( 1 )) ix = ix + incx do i = 2 , n if ( scabs1 ( cx ( ix )). gt . smax ) then icamax = i smax = scabs1 ( cx ( ix )) endif ix = ix + incx enddo endif end function icamax","tags":"","loc":"proc/icamax.html"},{"title":"idamax – M_blas","text":"public pure function idamax(n, dx, incx) NAME idamax(3f) - [BLAS:AUX_BLAS] SYNOPSIS integer function idamax(n,dx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)          :: incx,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in) :: dx(*)\n   .. DEFINITION IDAMAX finds the index of the first element having maximum absolute value. OPTIONS N N is INTEGER\n      number of elements in input vector(s) DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx Return Value integer Contents Variables dmax i ix Source Code idamax Variables Type Visibility Attributes Name Initial double precision, public :: dmax integer, public :: i integer, public :: ix Source Code pure integer function idamax ( n , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. double precision dmax integer i , ix !     .. !     .. Intrinsic Functions .. intrinsic dabs !     .. idamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return idamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! dmax = dabs ( dx ( 1 )) do i = 2 , n if ( dabs ( dx ( i )). gt . dmax ) then idamax = i dmax = dabs ( dx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 dmax = dabs ( dx ( 1 )) ix = ix + incx do i = 2 , n if ( dabs ( dx ( ix )). gt . dmax ) then idamax = i dmax = dabs ( dx ( ix )) endif ix = ix + incx enddo endif end function idamax","tags":"","loc":"proc/idamax.html"},{"title":"isamax – M_blas","text":"public  function isamax(n, sx, incx) NAME isamax ( 3 f ) - [ BLAS : AUX_BLAS ] Return index of maximum absolute value in SX . SYNOPSIS integer function isamax(n,sx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,n\n   ..\n   .. Array Arguments ..\n   real,intent(in) :: sx(*)\n   .. DEFINITION ISAMAX finds the index of the first element having maximum absolute value. OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx Return Value integer Contents Variables i ix smax Source Code isamax Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix real, public :: smax Source Code integer function isamax ( n , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real smax integer i , ix !     .. !     .. Intrinsic Functions .. intrinsic abs !     .. isamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return isamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! smax = abs ( sx ( 1 )) do i = 2 , n if ( abs ( sx ( i )). gt . smax ) then isamax = i smax = abs ( sx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 smax = abs ( sx ( 1 )) ix = ix + incx do i = 2 , n if ( abs ( sx ( ix )). gt . smax ) then isamax = i smax = abs ( sx ( ix )) endif ix = ix + incx enddo endif end function isamax","tags":"","loc":"proc/isamax.html"},{"title":"izamax – M_blas","text":"public pure function izamax(n, zx, incx) NAME izamax(3f) - [BLAS:AUX_BLAS] SYNOPSIS integer function izamax(n,zx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)              :: incx,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in) :: zx(*)\n   .. DEFINITION IZAMAX finds the index of the first element having maximum |Re(.)|\n + |Im(.)| OPTIONS N       number of elements in input vector(s)\n  ZX      array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n  INCX    storage spacing between elements of ZX RETURNS IZAMAX  index of the first element having maximum AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , 1 / 15 / 85 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx Return Value integer Contents Variables dmax i ix Source Code izamax Variables Type Visibility Attributes Name Initial double precision, public :: dmax integer, public :: i integer, public :: ix Source Code pure integer function izamax ( n , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dmax integer i , ix !     .. !     .. External Functions ..  DOUBLE PRECISION DCABS1 !     .. izamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return izamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! dmax = dcabs1 ( zx ( 1 )) do i = 2 , n if ( dcabs1 ( zx ( i )). gt . dmax ) then izamax = i dmax = dcabs1 ( zx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 dmax = dcabs1 ( zx ( 1 )) ix = ix + incx do i = 2 , n if ( dcabs1 ( zx ( ix )). gt . dmax ) then izamax = i dmax = dcabs1 ( zx ( ix )) endif ix = ix + incx enddo endif end function izamax","tags":"","loc":"proc/izamax.html"},{"title":"lsame – M_blas","text":"public pure function lsame(ca, cb) NAME lsame(3f) - [BLAS:AUX_BLAS] compare two letters ignoring case SYNOPSIS logical function lsame(ca,cb)\n\n   .. Scalar Arguments ..\n   character(len=1),intent(in) :: ca,cb\n   .. DEFINITION LSAME returns .TRUE. if CA is the same letter as CB regardless of\n  case. OPTIONS CA CA is CHARACTER*1 CB CB is CHARACTER*1\n       CA and CB specify the single characters to be compared. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ca character(len=1), intent(in) :: cb Return Value logical Contents Variables inta intb Source Code lsame Variables Type Visibility Attributes Name Initial integer, public :: inta integer, public :: intb Source Code pure logical function lsame ( ca , cb ) implicit none !  -- Reference BLAS level1 routine (version 3.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 !     .. Scalar Arguments .. character ( len = 1 ), intent ( in ) :: ca , cb !     .. ! ===================================================================== !     .. Intrinsic Functions .. intrinsic iachar !     .. !     .. Local Scalars .. integer :: inta , intb !     .. !     Test if the characters are equal lsame = ca . eq . cb if ( lsame ) return !     Now test for equivalence after converting uppercase to lowercase !     if characters are alphameric inta = ichar ( ca ) intb = ichar ( cb ) if ( inta . ge . 97 . and . inta . le . 122 ) inta = inta - 32 if ( intb . ge . 97 . and . intb . le . 122 ) intb = intb - 32 lsame = inta . eq . intb end function lsame","tags":"","loc":"proc/lsame.html"},{"title":"sasum – M_blas","text":"public pure function sasum(n, sx, incx) NAME sasum ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SASUM := sum of absolute values of SX . SYNOPSIS real function sasum(n,sx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,n\n   ..\n   .. Array Arguments ..\n   real,intent(in) :: sx(*)\n   .. DEFINITION SASUM takes the sum of the absolute values . uses unrolled loops for increment equal to one . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx Return Value real Contents Variables i m mp1 nincx stemp Source Code sasum Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: m integer, public :: mp1 integer, public :: nincx real, public :: stemp Source Code pure real function sasum ( n , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic abs , mod !     .. sasum = 0.0e0 stemp = 0.0e0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 6 ) if ( m . ne . 0 ) then do i = 1 , m stemp = stemp + abs ( sx ( i )) enddo if ( n . lt . 6 ) then sasum = stemp return endif endif mp1 = m + 1 do i = mp1 , n , 6 stemp = stemp + abs ( sx ( i )) + abs ( sx ( i + 1 )) + abs ( sx ( i + 2 )) + abs ( sx ( i + 3 )) + abs ( sx ( i + 4 )) + abs ( sx ( i + 5 )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + abs ( sx ( i )) enddo endif sasum = stemp end function sasum","tags":"","loc":"proc/sasum.html"},{"title":"scabs1 – M_blas","text":"public pure elemental function scabs1(z) NAME scabs1(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SYNOPSIS elemental real function scabs1(z)\n\n   .. Scalar Arguments ..\n   complex,intent(in) ::  z\n   .. DEFINITION SCABS1 computes |Re(.)| + |Im(.)| of a complex number OPTIONS Z Z is COMPLEX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name complex, intent(in) :: z Return Value real Contents Source Code scabs1 Source Code pure elemental real function scabs1 ( z ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: z !     .. !  ===================================================================== !     .. Intrinsic Functions .. intrinsic abs , aimag , real !     .. scabs1 = abs ( real ( z )) + abs ( aimag ( z )) end function scabs1","tags":"","loc":"proc/scabs1~2.html"},{"title":"scasum – M_blas","text":"public  function scasum(n, cx, incx) NAME scasum ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SCASUM := SUM ( I = 1 to N ) ABS ( REAL ( CX ( I ))) + ABS ( AIMAG ( CX ( I ))) . SYNOPSIS real function scasum(n,cx,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: cx(*)\n   .. DEFINITION SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and\n returns a single precision result. OPTIONS N N is INTEGER\n      number of elements in input vector(s) CX CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx Return Value real Contents Variables i nincx stemp Source Code scasum Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx real, public :: stemp Source Code real function scasum ( n , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real stemp integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic abs , aimag , real !     .. scasum = 0.0e0 stemp = 0.0e0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n stemp = stemp + abs ( real ( cx ( i ))) + abs ( aimag ( cx ( i ))) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + abs ( real ( cx ( i ))) + abs ( aimag ( cx ( i ))) enddo endif scasum = stemp end function scasum","tags":"","loc":"proc/scasum.html"},{"title":"scnrm2 – M_blas","text":"public pure function scnrm2(n, x, incx) NAME scnrm2 ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SCNRM2 := square root of sum of magnitudes of entries of CX . SYNOPSIS real function scnrm2(n,x,incx)\n\n  ..\n  .. Scalar Arguments ..\n  integer,intent(in) :: incx, n\n  ..\n  .. Array Arguments ..\n  complex(wp),intent(in) :: x(*)\n  .. DEFINITION SCNRM2 returns the euclidean norm of a vector via the function\n  name, so that SCNRM2 := sqrt ( x ** H * x ) OPTIONS N N is INTEGER\n      number of elements in input vector(s) X X is COMPLEX array, dimension (N)\n      complex vector with N elements INCX INCX is INTEGER , storage spacing between elements of X If INCX > 0 , X ( 1 + ( i - 1 ) * INCX ) = x ( i ) for 1 <= i <= n If INCX < 0 , X ( 1 - ( n - i ) * INCX ) = x ( i ) for 1 <= i <= n If INCX = 0 , x isn ' t a vector so there is no need to call this subroutine . If you call it anyway , it will count x ( 1 ) in the vector norm N times . AUTHORS Edward Anderson, Lockheed Martin date:August 2016 \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 Blue, James L. (1978)\n   A Portable Fortran Program to Find the Euclidean Norm of a Vector\n   ACM Trans Math Softw 4:15–23\n   https://doi.org/10.1145/355769.355771 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) Contents Variables abig amed asml ax i ix maxn notbig one sbig scl ssml sumsq tbig tsml wp ymax ymin zero Source Code scnrm2 Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abig real(kind=wp), public :: amed real(kind=wp), public :: asml real(kind=wp), public :: ax integer, public :: i integer, public :: ix real(kind=wp), public, parameter :: maxn = huge(0.0_wp) logical, public :: notbig real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: sbig = real(radix(0._wp), wp)**(-ceiling((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp)) real(kind=wp), public :: scl real(kind=wp), public, parameter :: ssml = real(radix(0._wp), wp)**(-floor((minexponent(0._wp)-1)*0.5_wp)) real(kind=wp), public :: sumsq real(kind=wp), public, parameter :: tbig = real(radix(0._wp), wp)**floor((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp) real(kind=wp), public, parameter :: tsml = real(radix(0._wp), wp)**ceiling((minexponent(0._wp)-1)*0.5_wp) integer, public, parameter :: wp = kind(1.e0) real(kind=wp), public :: ymax real(kind=wp), public :: ymin real(kind=wp), public, parameter :: zero = 0.0_wp Source Code pure function scnrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.e0 ) real ( wp ) :: scnrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. complex ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! scnrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( real ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ax = abs ( aimag ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif scnrm2 = scl * sqrt ( sumsq ) end function scnrm2","tags":"","loc":"proc/scnrm2.html"},{"title":"sdot – M_blas","text":"public pure function sdot(n, sx, incx, sy, incy) NAME sdot ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SDOT := SUM SX * SY ( vector do t product ) SYNOPSIS real function sdot(n,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in) :: sx(*),sy(*)\n   .. DEFINITION SDOT forms the dot product of two vectors . uses unrolled loops for increments equal to one . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of SY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value real Contents Variables i ix iy m mp1 stemp Source Code sdot Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 real, public :: stemp Source Code pure real function sdot ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. stemp = 0.0e0 sdot = 0.0e0 if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m stemp = stemp + sx ( i ) * sy ( i ) enddo if ( n . lt . 5 ) then sdot = stemp return endif endif mp1 = m + 1 do i = mp1 , n , 5 stemp = stemp + sx ( i ) * sy ( i ) + sx ( i + 1 ) * sy ( i + 1 ) + sx ( i + 2 ) * sy ( i + 2 ) + sx ( i + 3 ) * sy ( i + 3 ) + sx ( i + 4 ) * sy ( i + 4 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = stemp + sx ( ix ) * sy ( iy ) ix = ix + incx iy = iy + incy enddo endif sdot = stemp end function sdot","tags":"","loc":"proc/sdot.html"},{"title":"sdsdot – M_blas","text":"public pure function sdsdot(n, sb, sx, incx, sy, incy) NAME sdsdot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Compute the inner\nproduct of two vectors with extended precision accumulation. SDSDOT := SUM SX * SY (accumulated double precision, returned single) SYNOPSIS real function sdsdot(n,sb,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in) :: sb\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in) :: sx(*),sy(*)\n   .. DEFINITION Compute the inner product of two vectors with extended precision accumulation . Returns S . P . result with dot product accumulated in D . P . SDSDOT = SB + sum for I = 0 to N - 1 of SX ( LX + I * INCX ) * SY ( LY + I * INCY ) , where LX = 1 if INCX . GE . 0 , else LX = 1 + ( 1 - N ) * INCX , and LY is defined in a similar way using INCY . OPTIONS N N is INTEGER\n       number of elements in input vector(s) SB SB is REAL\n       single precision scalar to be added to inner product SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n       single precision vector with N elements INCX INCX is INTEGER\n       storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n       single precision vector with N elements INCY INCY is INTEGER\n       storage spacing between elements of SY AUTHORS Lawson, C. L., (JPL), Hanson, R. J., (SNLA), Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS REFERENCES C . L . Lawson , R . J . Hanson , D . R . Kincaid and F . T . Krogh , Basic linear algebra subprograms for Fortran usage , Algorithm No . 539 , Transactions on Mathematical Software 5 , 3 ( September 1979 ) , pp . 308 - 323 . REVISION HISTORY ( YYMMDD ) 791001 DATE WRITTEN 890531 Changed all specific intrinsics to generic . ( WRB ) 890831 Modified array declarations . ( WRB ) 890831 REVISION DATE from Version 3 . 2 891214 Prologue converted to Version 4 . 0 format . ( BAB ) 920310 Corrected definition of LX in DESCRIPTION . ( WRB ) 920501 Reformatted the REFERENCES section . ( WRB ) 070118 Reformat to LAPACK coding style SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sb real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value real Contents Variables dsdot i kx ky ns Source Code sdsdot Variables Type Visibility Attributes Name Initial double precision, public :: dsdot integer, public :: i integer, public :: kx integer, public :: ky integer, public :: ns Source Code pure real function sdsdot ( n , sb , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sb integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. !     .. Local Scalars .. double precision dsdot integer i , kx , ky , ns !     .. !     .. Intrinsic Functions .. intrinsic dble !     .. dsdot = sb if ( n . le . 0 ) then sdsdot = real ( dsdot ) return endif if ( incx . eq . incy . and . incx . gt . 0 ) then ! !     Code for equal and positive increments. ! ns = n * incx do i = 1 , ns , incx dsdot = dsdot + dble ( sx ( i )) * dble ( sy ( i )) enddo else ! !     Code for unequal or nonpositive increments. ! kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy do i = 1 , n dsdot = dsdot + dble ( sx ( kx )) * dble ( sy ( ky )) kx = kx + incx ky = ky + incy enddo endif sdsdot = real ( dsdot ) end function sdsdot","tags":"","loc":"proc/sdsdot.html"},{"title":"snrm2 – M_blas","text":"public  function snrm2(n, x, incx) NAME snrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SNRM2 := square root of sum of SX(I)**2 SYNOPSIS real function snrm2(n,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx, n\n   ..\n   .. Array Arguments ..\n   real(wp),intent(in) :: x(*)\n   .. DEFINITION SNRM2 returns the euclidean norm of a vector via the function\n  name, so that SNRM2 := sqrt ( x '* x ) . OPTIONS N N is INTEGER\n      number of elements in input vector(s) X X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER , storage spacing between elements of X If INCX > 0 , X ( 1 + ( i - 1 ) * INCX ) = x ( i ) for 1 <= i <= n If INCX < 0 , X ( 1 - ( n - i ) * INCX ) = x ( i ) for 1 <= i <= n If INCX = 0 , x isn ' t a vector so there is no need to call this subroutine . If you call it anyway , it will count x ( 1 ) in the vector norm N times . AUTHORS Edward Anderson, Lockheed Martin date:August 2016 \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 Blue, James L. (1978)\n   A Portable Fortran Program to Find the Euclidean Norm of a Vector\n   ACM Trans Math Softw 4:15–23\n   https://doi.org/10.1145/355769.355771 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) Contents Variables abig amed asml ax i ix maxn notbig one sbig scl ssml sumsq tbig tsml wp ymax ymin zero Source Code snrm2 Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abig real(kind=wp), public :: amed real(kind=wp), public :: asml real(kind=wp), public :: ax integer, public :: i integer, public :: ix real(kind=wp), public, parameter :: maxn = huge(0.0_wp) logical, public :: notbig real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: sbig = real(radix(0._wp), wp)**(-ceiling((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp)) real(kind=wp), public :: scl real(kind=wp), public, parameter :: ssml = real(radix(0._wp), wp)**(-floor((minexponent(0._wp)-1)*0.5_wp)) real(kind=wp), public :: sumsq real(kind=wp), public, parameter :: tbig = real(radix(0._wp), wp)**floor((maxexponent(0._wp)-digits(0._wp)+1)*0.5_wp) real(kind=wp), public, parameter :: tsml = real(radix(0._wp), wp)**ceiling((minexponent(0._wp)-1)*0.5_wp) integer, public, parameter :: wp = kind(1.e0) real(kind=wp), public :: ymax real(kind=wp), public :: ymin real(kind=wp), public, parameter :: zero = 0.0_wp Source Code function snrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.e0 ) real ( wp ) :: snrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. real ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! snrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( x ( ix )) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif snrm2 = scl * sqrt ( sumsq ) end function snrm2","tags":"","loc":"proc/snrm2.html"},{"title":"zdotc – M_blas","text":"public pure function zdotc(n, zx, incx, zy, incy) NAME zdotc(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS complex(kind=real64) function zdotc(n,zx,incx,zy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in) :: zx(*),zy(*)\n   .. DEFINITION ZDOTC forms the dot product of two complex vectors\n       ZDOTC = X&#94;H * Y OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX ZY ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of ZY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: zy (*) integer, intent(in) :: incy Return Value complex(kind=real64) Contents Variables i ix iy ztemp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy complex(kind=real64), public :: ztemp","tags":"","loc":"proc/zdotc.html"},{"title":"zdotu – M_blas","text":"public pure function zdotu(n, zx, incx, zy, incy) NAME zdotu(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS complex(kind=real64) function zdotu(n,zx,incx,zy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in) :: zx(*),zy(*)\n   .. DEFINITION ZDOTU forms the dot product of two complex vectors\n       ZDOTU = X&#94;T * Y OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX ZY ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of ZY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: zy (*) integer, intent(in) :: incy Return Value complex(kind=real64) Contents Variables i ix iy ztemp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy complex(kind=real64), public :: ztemp","tags":"","loc":"proc/zdotu.html"},{"title":"caxpy – M_blas","text":"public  subroutine caxpy(n, ca, cx, incx, cy, incy) NAME caxpy ( 3 f ) -- [ BLAS : COMPLEX_BLAS_LEVEL1 ] CY : = CY + CA * CX ( constant times a vector plus a vector ) SYNOPSIS subroutine caxpy(n,ca,cx,incx,cy,incy)\n\n    .. Scalar Arguments ..\n    complex,intent(in)    :: ca\n    integer,intent(in)    :: incx,incy,n\n    ..\n    .. Array Arguments ..\n    complex,intent(in)    :: cx(*)\n    complex,intent(inout) :: cy(*) DESCRIPTION CAXPY constant times a vector plus a vector . OPTIONS N      number of elements in input vector(s)\nCA     On entry, CA specifies the scalar alpha.\nCX     CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\nINCX   storage spacing between elements of CX\nCY     CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\nINCY   storage spacing between elements of CY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. November 2017 FURTHER DETAILS Jack Dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: ca complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy Contents Variables i ix iy Source Code caxpy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine caxpy ( n , ca , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: ca integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) complex , intent ( inout ) :: cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer :: i , ix , iy !     .. !     .. External Functions .. !     .. if ( n . le . 0 ) return if ( scabs1 ( ca ). eq . 0.0e+0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n cy ( i ) = cy ( i ) + ca * cx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n cy ( iy ) = cy ( iy ) + ca * cx ( ix ) ix = ix + incx iy = iy + incy enddo endif ! end subroutine caxpy","tags":"","loc":"proc/caxpy~2.html"},{"title":"ccopy – M_blas","text":"public  subroutine ccopy(n, cx, incx, cy, incy) NAME ccopy ( 3 f ) - [ BLAS : COMPLEX_BLAS_LEVEL1 ] CY := CX ( copies elements of a vector x to a vector y ) SYNOPSIS subroutine ccopy(n,cx,incx,cy,incy)\n\n .. scalar arguments ..\n    integer,intent(in)  ::  incx,incy,n\n ..\n .. array arguments ..\n    complex,intent(in)  ::  cx(*)\n    complex,intent(out) ::  cy(*) DESCRIPTION CCOPY copies a vector x to a vector y. OPTIONS N     number of elements in input vector(s)\nCX    dimension ( 1 + ( N - 1 )*abs( INCX ) )\nINCX  storage spacing between elements of CX\nCY    dimension ( 1 + ( N - 1 )*abs( INCY ) )\nINCY  storage spacing between elements of CY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(out) :: cy (*) integer, intent(in) :: incy Contents Variables i ix iy Source Code ccopy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine ccopy ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) complex , intent ( out ) :: cy ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then !        code for both increments equal to 1 cy ( 1 : n ) = cx ( 1 : n ) else !        code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n cy ( iy ) = cx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine ccopy","tags":"","loc":"proc/ccopy.html"},{"title":"cgbmv – M_blas","text":"public  subroutine cgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) NAME cgbmv ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] CY := alpha * A * CX + beta * CY ; ==> A is a rectangular band matrix ). SYNOPSIS subroutine cgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: incx,incy,kl,ku,lda,m,n\n   character,intent(in)  :: trans\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),x(*)\n   complex,intent(inout) :: y(*)\n   .. DESCRIPTION CGBMV  performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , or y := alpha * A ** H * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n band matrix, with kl sub-diagonals and ku super-diagonals. OPTIONS TRANS\n            On entry, TRANS specifies the operation to be performed as\n            follows: TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . M\n            On entry, M specifies the number of rows of the matrix A.\n            M must be at least zero. N\n            On entry, N specifies the number of columns of the matrix A.\n            N must be at least zero. KL\n            On entry, KL specifies the number of sub-diagonals of the\n            matrix A. KL must satisfy  0 .le. KL. KU\n           On entry, KU specifies the number of super-diagonals of the\n           matrix A. KU must satisfy  0 .le. KU. ALPHA\n           On entry, ALPHA specifies the scalar alpha. A\n           A is COMPLEX array, dimension ( LDA, N )\n           Before entry, the leading ( kl + ku + 1 ) by n part of the\n           array A must contain the matrix of coefficients, supplied\n           column by column, with the leading diagonal of the matrix in\n           row ( ku + 1 ) of the array, the first super-diagonal\n           starting at position 2 in row ku, the first sub-diagonal\n           starting at position 1 in row ( ku + 2 ), and so on. Elements in the array A that do not correspond to elements in the band matrix ( such as the top left ku by ku triangle ) are not referenced . The following program segment will transfer a band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE LDA\n           On entry, LDA specifies the first dimension of A as declared\n           in the calling (sub) program. LDA must be at least\n           ( kl + ku + 1 ). X\n           X is COMPLEX array, dimension at least\n           ( 1 + ( n - 1 ) abs( INCX ) ) when TRANS = ‘N’ or ‘n’\n           and at least\n           ( 1 + ( m - 1 ) abs( INCX ) ) otherwise.\n           Before entry, the incremented array X must contain the\n           vector x. INCX\n           INCX is INTEGER\n           On entry, INCX specifies the increment for the elements of\n           X. INCX must not be zero. BETA\n           BETA is COMPLEX\n           On entry, BETA specifies the scalar beta. When BETA is\n           supplied as zero then Y need not be set on input. Y\n           Y is COMPLEX array, dimension at least\n           ( 1 + ( m - 1 ) abs( INCY ) ) when TRANS = ‘N’ or ‘n’\n           and at least\n           ( 1 + ( n - 1 ) abs( INCY ) ) otherwise.\n           Before entry, the incremented array Y must contain the\n           vector y. On exit, Y is overwritten by the updated vector y. INCY\n           INCY is INTEGER\n           On entry, INCY specifies the increment for the elements of\n           Y. INCY must not be zero. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS\n   Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kup1 kx ky lenx leny noconj one temp zero Source Code cgbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kup1 integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny logical, public :: noconj complex, public, parameter :: one = (1.0e+0, 0.0e+0) complex, public :: temp complex, public, parameter :: zero = (0.0e+0, 0.0e+0) Source Code subroutine cgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'CGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set LENX and LENY,the lengths of the vectors x and y, and set !     up the start points in X and Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then do i = 1 , leny y ( i ) = zero enddo else do i = 1 , leny y ( i ) = beta * y ( i ) enddo endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + conjg ( a ( k + i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + conjg ( a ( k + i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif end subroutine cgbmv","tags":"","loc":"proc/cgbmv.html"},{"title":"cgemm – M_blas","text":"public  subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME cgemm ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL3 ] C := alpha * A * B + beta * C ; ==> A , B , C rectangular . SYNOPSIS subroutine cgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: k,lda,ldb,ldc,m,n\n   character,intent(in)  :: transa,transb\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),b(ldb,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CGEMM performs one of the matrix-matrix operations C := alpha * op ( A ) * op ( B ) + beta * C , where op( X ) is one of op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, alpha and beta are scalars, and A, B and C are matrices, with op( A )\n  an m by k matrix,  op( B )  a K by N matrix and C an M by N matrix. OPTIONS TRANSA On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n',  op( A ) = A.\n\n           TRANSA = 'T' or 't',  op( A ) = A**T.\n\n           TRANSA = 'C' or 'c',  op( A ) = A**H. TRANSB TRANSB is CHARACTER*1\n        On entry, TRANSB specifies the form of op( B ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSB = 'N' or 'n',  op( B ) = B.\n\n           TRANSB = 'T' or 't',  op( B ) = B**T.\n\n           TRANSB = 'C' or 'c',  op( B ) = B**H. M\n            On entry, M specifies the number of rows of the matrix\n            op( A ) and of the matrix C. M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix\n        op( B ) and the number of columns of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry, K specifies the number of columns of the matrix\n        op( A ) and the number of rows of the matrix op( B ). K must\n        be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        k when TRANSA = 'N' or 'n', and is m otherwise.\n        Before entry with TRANSA = 'N' or 'n', the leading m by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by m part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANSA = ' N ' or ' n ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , k ) . B B is COMPLEX array, dimension ( LDB, kb ), where kb is\n        n when TRANSB = 'N' or 'n', and is k otherwise.\n        Before entry with TRANSB = 'N' or 'n', the leading k by n\n        part of the array B must contain the matrix B, otherwise\n        the leading n by k part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANSB = ' N ' or ' n ' then LDB must be at least max ( 1 , k ) , otherwise LDB must be at least max ( 1 , n ) . BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is COMPLEX array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n matrix ( alpha * op ( A ) * op ( B ) + beta * C ) . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables conja conjb i info j l nota notb nrowa nrowb one temp zero Source Code cgemm Variables Type Visibility Attributes Name Initial logical, public :: conja logical, public :: conjb integer, public :: i integer, public :: info integer, public :: j integer, public :: l logical, public :: nota logical, public :: notb integer, public :: nrowa integer, public :: nrowb complex, public, parameter :: one = (1.0e+0, 0.0e+0) complex, public :: temp complex, public, parameter :: zero = (0.0e+0, 0.0e+0) Source Code subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , l , nrowa , nrowb logical conja , conjb , nota , notb !     .. !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and  NROWB  as the number of rows of  A  and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) conja = lsame ( transa , 'C' ) conjb = lsame ( transb , 'C' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . conja ) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . conjb ) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'CGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n do i = 1 , m c ( i , j ) = zero enddo enddo else do j = 1 , n do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( l , j ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo elseif ( conja ) then ! !           Form  C := alpha*A**H*B + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif elseif ( nota ) then if ( conjb ) then ! !           Form  C := alpha*A*B**H + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * conjg ( b ( j , l )) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( j , l ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo endif elseif ( conja ) then if ( conjb ) then ! !           Form  C := alpha*A**H*B**H + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * conjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**H*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( conjb ) then ! !           Form  C := alpha*A**T*B**H + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * conjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! !     End of CGEMM . ! end subroutine cgemm","tags":"","loc":"proc/cgemm.html"},{"title":"cgemv – M_blas","text":"public  subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) NAME cgemv ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] CY := alpha * A * CX + beta * CY ; ==> A a rectangular matrix . SYNOPSIS subroutine cgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   COMPLEX,intent(in)    :: ALPHA,BETA\n   INTEGER,intent(in)    :: INCX,INCY,LDA,M,N\n   CHARACTER,intent(in)  :: TRANS\n   ..\n   .. Array Arguments ..\n   COMPLEX,intent(in)    :: A(LDA,*),X(*)\n   COMPLEX,intent(inout) :: Y(*)\n   .. DEFINITION CGEMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , or y := alpha * A ** H * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n matrix. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, N )\n        Before entry, the leading m by n part of the array A must\n        contain the matrix of coefficients. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is COMPLEX array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry with BETA non - zero , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky lenx leny noconj one temp zero Source Code cgemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny logical, public :: noconj complex, public, parameter :: one = (1.0e+0, 0.0e+0) complex, public :: temp complex, public, parameter :: zero = (0.0e+0, 0.0e+0) Source Code subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo else do i = 1 , m temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo else do i = 1 , m temp = temp + conjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! !     End of CGEMV . ! end subroutine cgemv","tags":"","loc":"proc/cgemv.html"},{"title":"cgerc – M_blas","text":"public  subroutine cgerc(m, n, alpha, x, incx, y, incy, a, lda) NAME cgerc ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] A := A + alpha * CX * CONJUGATE-TRANSPOSE ( CY ); ==> A is a rectangular matrix . SYNOPSIS subroutine cgerc(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   integer,intent(in)    :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: a(lda,*)\n   complex,intent(in)    :: x(*),y(*)\n   .. DEFINITION CGERC performs the rank 1 operation A := alpha * x * y ** H + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( m - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the m\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is COMPLEX array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code cgerc Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine cgerc ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CGERC ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * conjg ( y ( jy )) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * conjg ( y ( jy )) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine cgerc","tags":"","loc":"proc/cgerc.html"},{"title":"cgeru – M_blas","text":"public  subroutine cgeru(m, n, alpha, x, incx, y, incy, a, lda) NAME cgeru ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] A := A + alpha * CX * TRANSPOSE ( CY ); ==> A is a rectangular matrix . SYNOPSIS subroutine cgeru(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   integer,intent(in)    :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: a(lda,*)\n   complex,intent(in)    :: x(*),y(*)\n   .. DEFINITION CGERU performs the rank 1 operation A := alpha * x * y ** T + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( m - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the m\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is COMPLEX array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code cgeru Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine cgeru ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CGERU ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine cgeru","tags":"","loc":"proc/cgeru.html"},{"title":"chbmv – M_blas","text":"public  subroutine chbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) NAME chbmv ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] CY := alpha * A * CX + beta * CY ; ==> A a ( square ) hermitian band matrix . SYNOPSIS subroutine chbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: incx,incy,k,lda,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),x(*)\n   complex,intent(inout) :: y(*)\n   .. DEFINITION CHBMV(3f) performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian band matrix, with k super-diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the band matrix A is being supplied as\n        follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               being supplied.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               being supplied. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry, K specifies the number of super-diagonals of the\n        matrix A. K must satisfy 0 .le. K. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer the upper triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that the imaginary parts of the diagonal elements need not be set and are assumed to be zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is COMPLEX\n        On entry, BETA specifies the scalar beta. Y Y is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kplus1 kx ky l one temp1 temp2 zero Source Code chbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kplus1 integer, public :: kx integer, public :: ky integer, public :: l complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CHBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * real ( a ( kplus1 , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( a ( kplus1 , j )) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( a ( 1 , j )) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( a ( 1 , j )) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! !     End of CHBMV . ! end subroutine chbmv","tags":"","loc":"proc/chbmv.html"},{"title":"chemm – M_blas","text":"public  subroutine chemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME chemm ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL3 ] C := alpha * A * TRANSPOSE ( A )+ beta * C ; ==> A hermitian , B , C rectangular . SYNOPSIS subroutine chemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: lda,ldb,ldc,m,n\n   character,intent(in)  :: side,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),b(ldb,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CHEMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is an hermitian matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the hermitian matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the hermitian matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               hermitian matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               hermitian matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the hermitian matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the hermitian matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the hermitian\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the hermitian matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the hermitian matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the hermitian\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Note that the imaginary parts of the diagonal elements need\n        not be set, they are assumed to be zero. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is COMPLEX array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is COMPLEX array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code chemm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CHEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * conjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * real ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * real ( a ( i , i )) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * conjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * real ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * real ( a ( i , i )) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * real ( a ( j , j )) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * conjg ( a ( j , k )) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * conjg ( a ( j , k )) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! !     End of CHEMM . ! end subroutine chemm","tags":"","loc":"proc/chemm.html"},{"title":"chemv – M_blas","text":"public  subroutine chemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) NAME chemv ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] CY := alpha * A * CX + beta * CY ; ==> A a ( square ) hermitian matrix . SYNOPSIS subroutine chemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: incx,incy,lda,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),x(*)\n   complex,intent(inout) :: y(*)\n   .. DEFINITION CHEMV  performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular part of the hermitian matrix and the strictly\n        lower triangular part of A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular part of the hermitian matrix and the strictly\n        upper triangular part of A is not referenced.\n        Note that the imaginary parts of the diagonal elements need\n        not be set and are assumed to be zero. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky one temp1 temp2 zero Source Code chemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CHEMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * real ( a ( j , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( a ( j , j )) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( a ( j , j )) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( a ( j , j )) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine chemv","tags":"","loc":"proc/chemv.html"},{"title":"cher – M_blas","text":"public  subroutine cher(uplo, n, alpha, x, incx, a, lda) NAME cher ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] A := A + alpha * CX * CONJUGATE-TRANSPOSE ( CX ); ==> A a ( square ) hermitian matrix . ( performs the hermitian rank 1 operation ) SYNOPSIS subroutine cher(uplo,n,alpha,x,incx,a,lda)\n\n   .. Scalar Arguments ..\n   real,intent(in)       :: alpha\n   integer,intent(in)    :: incx,lda,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: a(lda,*)\n   complex,intent(in)    :: x(*)\n   .. DEFINITION CHER performs the hermitian rank 1 operation A := alpha * x * x ** H + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . A A is COMPLEX array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jx kx temp zero Source Code cher Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine cher ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CHER  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . real ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp ) else a ( j , j ) = real ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ix = kx do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp ) else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) a ( j , j ) = real ( a ( j , j )) + real ( temp * x ( j )) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo else a ( j , j ) = real ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) a ( j , j ) = real ( a ( j , j )) + real ( temp * x ( jx )) ix = jx do i = j + 1 , n ix = ix + incx a ( i , j ) = a ( i , j ) + x ( ix ) * temp enddo else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx enddo endif endif ! end subroutine cher","tags":"","loc":"proc/cher.html"},{"title":"cher2 – M_blas","text":"public  subroutine cher2(uplo, n, alpha, x, incx, y, incy, a, lda) NAME cher2 ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL2 ] A := A + alpha * CX * CONJUGATE-TRANSPOSE ( CY ) n + CONJUGATE ( alpha )* CY * CONJUGATE-TRANSPOSE ( CX ); ==> n A a ( square ) hermitian matrix . ( performs the hermitian rank 2 operation ) SYNOPSIS subroutine cher2(uplo,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex,intent(in)     :: alpha\n   integer,intent(in)     :: incx,incy,lda,n\n   character,intent(in)   :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(inout)  :: a(lda,*)\n   complex,intent(in)     :: x(*),y(*)\n   .. DEFINITION CHER2 performs the hermitian rank 2 operation A := alpha * x * y ** H + conjg ( alpha ) * y * x ** H + A , where alpha is a scalar, x and y are n element vectors and A is an n\n  by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is COMPLEX array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix iy j jx jy kx ky temp1 temp2 zero Source Code cher2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky complex, public :: temp1 complex, public :: temp2 complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine cher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CHER2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) else a ( j , j ) = real ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ix = kx iy = ky do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo else a ( j , j ) = real ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine cher2","tags":"","loc":"proc/cher2.html"},{"title":"cher2k – M_blas","text":"public  subroutine cher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME cher2k ( 3f ) - [ BLAS : COMPLEX_BLAS_LEVEL3 ] C := alpha * A * TRANSPOSE ( B )+ alpha * B * TRANSPOSE ( A )+ beta * C ; ==> C hermitian . ( performs one of the hermitian rank 2k operations ) SYNOPSIS subroutine cher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   real,intent(in)       :: beta\n   integer,intent(in)    :: k,lda,ldb,ldc,n\n   character,intent(in)  :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),b(ldb,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CHER2K performs one of the hermitian rank 2k operations C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C , or C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C , where alpha and beta are scalars with beta real, C is an n by n\n  hermitian matrix and A and B are n by k matrices in the first case\n  and k by n matrices in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'C' or 'c', K specifies the number of rows of the\n        matrices A and B. K must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is COMPLEX array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . BETA BETA is REAL\n        On entry, BETA specifies the scalar beta. C C is COMPLEX array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.\n      Ed Anderson, Cray Research Inc. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code cher2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa real, public, parameter :: one = 1.0e+0 complex, public :: temp1 complex, public :: temp2 logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine cher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha real , intent ( in ) :: beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one parameter ( one = 1.0e+0 ) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CHER2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . real ( zero )) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) enddo endif else if ( beta . eq . real ( zero )) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! if ( upper ) then do j = 1 , n if ( beta . eq . real ( zero )) then do i = 1 , j c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * conjg ( b ( j , l )) temp2 = conjg ( alpha * a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = real ( c ( j , j )) + real ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo else do j = 1 , n if ( beta . eq . real ( zero )) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * conjg ( b ( j , l )) temp2 = conjg ( alpha * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = real ( c ( j , j )) + real ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo endif else ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + conjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + conjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . real ( zero )) then c ( j , j ) = real ( alpha * temp1 + conjg ( alpha ) * temp2 ) else c ( j , j ) = beta * real ( c ( j , j )) + real ( alpha * temp1 + conjg ( alpha ) * temp2 ) endif else if ( beta . eq . real ( zero )) then c ( i , j ) = alpha * temp1 + conjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + conjg ( alpha ) * temp2 endif endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + conjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + conjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . real ( zero )) then c ( j , j ) = real ( alpha * temp1 + conjg ( alpha ) * temp2 ) else c ( j , j ) = beta * real ( c ( j , j )) + real ( alpha * temp1 + conjg ( alpha ) * temp2 ) endif else if ( beta . eq . real ( zero )) then c ( i , j ) = alpha * temp1 + conjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + conjg ( alpha ) * temp2 endif endif enddo enddo endif endif ! end subroutine cher2k","tags":"","loc":"proc/cher2k.html"},{"title":"cherk – M_blas","text":"public  subroutine cherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME cherk(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] performs one of the hermitian rank k operations C:=alpha A TRANSPOSE(A)+beta*C, C hermitian. SYNOPSIS subroutine cherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   real,intent(in)       :: alpha,beta\n   integer,intent(in)    :: k,lda,ldc,n\n   character,intent(in)  :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CHERK performs one of the hermitian rank k operations C := alpha * A * A ** H + beta * C , or C := alpha * A ** H * A + beta * C , where alpha and beta are real scalars, C is an n by n hermitian\n  matrix and A is an n by k matrix in the first case and a k by n\n  matrix in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrix A, and on entry with\n        TRANS = 'C' or 'c', K specifies the number of rows of the\n        matrix A. K must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is REAL\n        On entry, BETA specifies the scalar beta. C C is COMPLEX array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.\n      Ed Anderson, Cray Research Inc. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one rtemp temp upper zero Source Code cherk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: rtemp complex, public :: temp logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine cherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic cmplx , conjg , max , real !     .. !     .. Local Scalars .. complex temp real rtemp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CHERK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n do i = 1 , j c ( i , j ) = zero enddo enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) enddo endif else if ( beta . eq . zero ) then do j = 1 , n do i = j , n c ( i , j ) = zero enddo enddo else do j = 1 , n c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**H + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . cmplx ( zero )) then temp = alpha * conjg ( a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo c ( j , j ) = real ( c ( j , j )) + real ( temp * a ( i , l )) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then do i = j , n c ( i , j ) = zero enddo elseif ( beta . ne . one ) then c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . cmplx ( zero )) then temp = alpha * conjg ( a ( j , l )) c ( j , j ) = real ( c ( j , j )) + real ( temp * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**H*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j - 1 temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo rtemp = zero do l = 1 , k rtemp = rtemp + conjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * real ( c ( j , j )) endif enddo else do j = 1 , n rtemp = zero do l = 1 , k rtemp = rtemp + conjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * real ( c ( j , j )) endif do i = j + 1 , n temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine cherk","tags":"","loc":"proc/cherk.html"},{"title":"chpmv – M_blas","text":"public  subroutine chpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) NAME chpmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CY := alpha A CX + beta*CY, A a (square) hermitian packed matrix. SYNOPSIS subroutine chpmv(uplo,n,alpha,ap,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: incx,incy,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: ap(*),x(*)\n   complex,intent(inout) :: y(*)\n   .. DEFINITION CHPMV(3f) performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. AP AP is COMPLEX array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular part of the hermitian matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n        and a( 2, 2 ) respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular part of the hermitian matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n        and a( 3, 1 ) respectively, and so on.\n        Note that the imaginary parts of the diagonal elements need\n        not be set and are assumed to be zero. X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: ap (*) complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kk kx ky one temp1 temp2 zero Source Code chpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CHPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * real ( ap ( kk + j - 1 )) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( ap ( kk + j - 1 )) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( ap ( kk )) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( ap ( kk )) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif ! end subroutine chpmv","tags":"","loc":"proc/chpmv.html"},{"title":"chpr – M_blas","text":"public  subroutine chpr(uplo, n, alpha, x, incx, ap) NAME chpr(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] performs the hermitian rank 1 operation A := A + alpha CX CONJUGATE-TRANSPOSE(CX), a a (square) hermitian packed. SYNOPSIS subroutine chpr(uplo,n,alpha,x,incx,ap)\n\n   .. Scalar Arguments ..\n   real,intent(in)       :: alpha\n   integer,intent(in)    :: incx,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: ap(*)\n   complex,intent(in)    :: x(*)\n   .. DEFINITION CHPR performs the hermitian rank 1 operation A := alpha * x * x ** H + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AP AP is COMPLEX array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(inout) :: ap (*) Contents Variables i info ix j jx k kk kx temp zero Source Code chpr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chpr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: ap ( * ) complex , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'CHPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . real ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( j ) * temp ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ix = kx do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( jx ) * temp ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) ap ( kk ) = real ( ap ( kk )) + real ( temp * x ( j )) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo else ap ( kk ) = real ( ap ( kk )) endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ap ( kk ) = real ( ap ( kk )) + real ( temp * x ( jx )) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx ap ( k ) = ap ( k ) + x ( ix ) * temp enddo else ap ( kk ) = real ( ap ( kk )) endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif ! end subroutine chpr","tags":"","loc":"proc/chpr.html"},{"title":"chpr2 – M_blas","text":"public  subroutine chpr2(uplo, n, alpha, x, incx, y, incy, ap) NAME chpr2(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] performs the hermitian rank 2 operation A := A + alpha CX CONJUGATE-TRANSPOSE(CY)n + CONJUGATE(ALPHA) CY CONJUGATE-TRANSPOSE(CX),n A a (square) hermitian packed matrix. SYNOPSIS subroutine chpr2(uplo,n,alpha,x,incx,y,incy,ap)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   integer,intent(in)    :: incx,incy,n\n   character,intent(in)  :: uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: ap(*)\n   complex,intent(in)    :: x(*),y(*)\n   .. DEFINITION CHPR2 performs the hermitian rank 2 operation A := alpha * x * y ** H + conjg ( alpha ) * y * x ** H + A , where alpha is a scalar, x and y are n element vectors and A is an\n  n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. X X is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is COMPLEX array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AP AP is COMPLEX array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: ap (*) Contents Variables i info ix iy j jx jy k kk kx ky temp1 temp2 zero Source Code chpr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky complex, public :: temp1 complex, public :: temp2 complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine chpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: ap ( * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CHPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ix = kx iy = ky do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) ap ( kk ) = real ( ap ( kk )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo else ap ( kk ) = real ( ap ( kk )) endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ap ( kk ) = real ( ap ( kk )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else ap ( kk ) = real ( ap ( kk )) endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif ! end subroutine chpr2","tags":"","loc":"proc/chpr2.html"},{"title":"crotg – M_blas","text":"public  subroutine crotg(a, b, c, s) NAME crotg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate a hermitian Given's rotation. SYNOPSIS subroutine CROTG( a, b, c, s )\n\n  .. Scalar Arguments ..\n     complex(wp),intent(inout) :: a\n     complex(wp),intent(in)    :: b\n     real(wp),intent(out)      :: c\n     complex(wp),intent(out)   :: s DESCRIPTION CROTG constructs a plane rotation [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s ic complex, and c* 2 + conjg(s) s = 1. The computation uses the formulas | x | = sqrt ( Re ( x ) ** 2 + Im ( x ) ** 2 ) sgn ( x ) = x / | x | if x /= 0 = 1 if x = 0 c = | a | / sqrt ( | a |** 2 + | b |** 2 ) s = sgn ( a ) * conjg ( b ) / sqrt ( | a |** 2 + | b |** 2 ) When a and b are real and r /= 0, the formulas simplify to r = sgn(a)*sqrt(|a|**2 + |b|**2)\n c = a / r\n s = b / r the same as in CROTG when |a| > |b|. When |b| >= |a|, the\n  sign of c and s will be different from those computed by CROTG\n  if the signs of a and b are not the same. OPTIONS A On entry , the scalar a . On exit , the scalar r . B The scalar b . C The scalar c . S The scalar s . AUTHORS Edward Anderson, Lockheed Martin CONTRIBUTORS Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n Algorithm 978: Safe Scaling in the Level 1 BLAS\n ACM Trans Math Softw 44:1--28\n https://doi.org/10.1145/3061665 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s Contents Variables abssq czero d f f1 f2 fs g g1 g2 gs h2 one p r rtmax rtmin safmax safmin t u uu v vv w wp zero Source Code crotg Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abssq complex(kind=wp), public, parameter :: czero = 0.0_wp real(kind=wp), public :: d complex(kind=wp), public :: f real(kind=wp), public :: f1 real(kind=wp), public :: f2 complex(kind=wp), public :: fs complex(kind=wp), public :: g real(kind=wp), public :: g1 real(kind=wp), public :: g2 complex(kind=wp), public :: gs real(kind=wp), public :: h2 real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public :: p complex(kind=wp), public :: r real(kind=wp), public, parameter :: rtmax = sqrt(real(radix(0._wp), wp)**max(1-minexponent(0._wp), maxexponent(0._wp)-1)*epsilon(0._wp)) real(kind=wp), public, parameter :: rtmin = sqrt(real(radix(0._wp), wp)**max(minexponent(0._wp)-1, 1-maxexponent(0._wp))/epsilon(0._wp)) real(kind=wp), public, parameter :: safmax = real(radix(0._wp), wp)**max(1-minexponent(0._wp), maxexponent(0._wp)-1) real(kind=wp), public, parameter :: safmin = real(radix(0._wp), wp)**max(minexponent(0._wp)-1, 1-maxexponent(0._wp)) complex(kind=wp), public :: t real(kind=wp), public :: u real(kind=wp), public :: uu real(kind=wp), public :: v real(kind=wp), public :: vv real(kind=wp), public :: w integer, public, parameter :: wp = kind(1.e0) real(kind=wp), public, parameter :: zero = 0.0_wp Source Code subroutine crotg ( a , b , c , s ) integer , parameter :: wp = kind ( 1.e0 ) ! !  -- Reference BLAS level1 routine -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp complex ( wp ), parameter :: czero = 0.0_wp !  .. !  .. Scaling constants .. real ( wp ), parameter :: safmin = real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) real ( wp ), parameter :: safmax = real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) real ( wp ), parameter :: rtmin = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) / epsilon ( 0._wp ) ) real ( wp ), parameter :: rtmax = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) * epsilon ( 0._wp ) ) !  .. !  .. Scalar Arguments .. complex ( wp ), intent ( inout ) :: a complex ( wp ), intent ( in ) :: b real ( wp ), intent ( out ) :: c complex ( wp ), intent ( out ) :: s !  .. !  .. Local Scalars .. real ( wp ) :: d , f1 , f2 , g1 , g2 , h2 , p , u , uu , v , vv , w complex ( wp ) :: f , fs , g , gs , r , t !  .. !  .. Intrinsic Functions .. intrinsic :: abs , aimag , conjg , max , min , real , sqrt !  .. !  .. Statement Functions .. real ( wp ) :: abssq !  .. !  .. Statement Function definitions .. abssq ( t ) = real ( t ) ** 2 + aimag ( t ) ** 2 !  .. !  .. Executable Statements .. ! f = a g = b if ( g == czero ) then c = one s = czero r = f elseif ( f == czero ) then c = zero g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! g2 = abssq ( g ) d = sqrt ( g2 ) s = conjg ( g ) / d r = d else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) d = sqrt ( g2 ) s = conjg ( gs ) / d r = d * u endif else f1 = max ( abs ( real ( f )), abs ( aimag ( f )) ) g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( f1 > rtmin . and . f1 < rtmax . and . & g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! f2 = abssq ( f ) g2 = abssq ( g ) h2 = f2 + g2 if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = f2 * p s = conjg ( g ) * ( f * p ) r = f * ( h2 * p ) else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , f1 , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) if ( f1 * uu < rtmin ) then ! !           f is not well-scaled when scaled by g1. !           Use a different scaling for f. ! v = min ( safmax , max ( safmin , f1 ) ) vv = one / v w = v * uu fs = f * vv f2 = abssq ( fs ) h2 = f2 * w ** 2 + g2 else ! !           Otherwise use the same scaling for f and g. ! w = one fs = f * uu f2 = abssq ( fs ) h2 = f2 + g2 endif if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = ( f2 * p ) * w s = conjg ( gs ) * ( fs * p ) r = ( fs * ( h2 * p ) ) * u endif endif a = r end subroutine crotg","tags":"","loc":"proc/crotg.html"},{"title":"cscal – M_blas","text":"public  subroutine cscal(n, ca, cx, incx) NAME cscal ( 3 f ) - [ BLAS : COMPLEX_BLAS_LEVEL1 ] scales a vector by a constant . CX:=CA*CX (complex multiplier) SYNOPSIS subroutine cscal(n,ca,cx,incx)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: ca\n   integer,intent(in)    :: incx,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: cx(*)\n   .. DEFINITION CSCAL scales a vector by a constant . OPTIONS N\n          number of elements in input vector(s)\n   CA\n          On entry, CA specifies the scalar alpha.\n   CX\n          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX\n          storage spacing between elements of CX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: ca complex, intent(inout) :: cx (*) integer, intent(in) :: incx Contents Variables i nincx Source Code cscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx Source Code subroutine cscal ( n , ca , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: ca integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n cx ( i ) = ca * cx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx cx ( i ) = ca * cx ( i ) enddo endif end subroutine cscal","tags":"","loc":"proc/cscal.html"},{"title":"csrot – M_blas","text":"public  subroutine csrot(n, cx, incx, cy, incy, c, s) NAME csrot(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] Applies a real Given's rotation to complex vectors. SYNOPSIS subroutine csrot( n, cx, incx, cy, incy, c, s )\n\n   .. Scalar Arguments ..\n   integer,intent(in)       :: incx, incy, n\n   real,intent(in)          :: c, s\n   ..\n   .. Array Arguments ..\n   complex,intent(inout)    :: cx( * ), cy( * )\n   .. DEFINITION CSROT applies a plane rotation, where the cos and sin (c and s) are real\n  and the vectors cx and cy are complex.\n  jack dongarra, linpack, 3/11/78. OPTIONS N N is INTEGER\n        On entry, N specifies the order of the vectors cx and cy.\n        N must be at least zero. CX CX is COMPLEX array , dimension at least ( 1 + ( N - 1 ) * abs ( INCX ) ) . Before entry , the incremented array CX must contain the n element vector cx . On exit , CX is overwritten by the updated vector cx . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of CX . INCX must not be zero . CY CY is COMPLEX array , dimension at least ( 1 + ( N - 1 ) * abs ( INCY ) ) . Before entry , the incremented array CY must contain the n element vector cy . On exit , CY is overwritten by the updated vector cy . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of CY . INCY must not be zero . C C is REAL\n        On entry, C specifies the cosine, cos. S S is REAL\n        On entry, S specifies the sine, sin. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy real, intent(in) :: c real, intent(in) :: s Contents Variables ctemp i ix iy Source Code csrot Variables Type Visibility Attributes Name Initial complex, public :: ctemp integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine csrot ( n , cx , incx , cy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n real , intent ( in ) :: c , s !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy complex ctemp !     .. !     .. Executable Statements .. ! if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = c * cx ( i ) + s * cy ( i ) cy ( i ) = c * cy ( i ) - s * cx ( i ) cx ( i ) = ctemp enddo else ! !        code for unequal increments or equal increments not equal !          to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = c * cx ( ix ) + s * cy ( iy ) cy ( iy ) = c * cy ( iy ) - s * cx ( ix ) cx ( ix ) = ctemp ix = ix + incx iy = iy + incy enddo endif end subroutine csrot","tags":"","loc":"proc/csrot.html"},{"title":"csscal – M_blas","text":"public  subroutine csscal(n, sa, cx, incx) NAME csscal ( 3 f ) - [ BLAS : COMPLEX_BLAS_LEVEL1 ] CSSCAL scales a complex vector by a real constant . CX:=SA*CX (real multiplier). SYNOPSIS subroutine csscal(n,sa,cx,incx)\n\n   .. scalar arguments ..\n   real,intent(in)       :: sa\n   integer,intent(in)    :: incx,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: cx(*)\n   .. DEFINITION CSSCAL scales a complex vector by a real constant . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SA SA is REAL\n        On entry, SA specifies the scalar alpha. CX CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of CX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa complex, intent(inout) :: cx (*) integer, intent(in) :: incx Contents Variables i nincx Source Code csscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx Source Code subroutine csscal ( n , sa , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic aimag , cmplx , real !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n cx ( i ) = cmplx ( sa * real ( cx ( i )), sa * aimag ( cx ( i ))) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx cx ( i ) = cmplx ( sa * real ( cx ( i )), sa * aimag ( cx ( i ))) enddo endif end subroutine csscal","tags":"","loc":"proc/csscal.html"},{"title":"cswap – M_blas","text":"public  subroutine cswap(n, cx, incx, cy, incy) NAME cswap(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] Interchange vectors CX and CY. SYNOPSIS subroutine cswap(n,cx,incx,cy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex,intent(inout) :: cx(*),cy(*)\n   .. DEFINITION CSWAP interchanges two vectors. OPTIONS N N is INTEGER\n      number of elements in input vector(s) CX CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of CX CY CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of CY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy Contents Variables ctemp i ix iy Source Code cswap Variables Type Visibility Attributes Name Initial complex, public :: ctemp integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine cswap ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 do i = 1 , n ctemp = cx ( i ) cx ( i ) = cy ( i ) cy ( i ) = ctemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = cx ( ix ) cx ( ix ) = cy ( iy ) cy ( iy ) = ctemp ix = ix + incx iy = iy + incy enddo endif end subroutine cswap","tags":"","loc":"proc/cswap.html"},{"title":"csymm – M_blas","text":"public  subroutine csymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME csymm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] C:=alpha A B+beta*C, A symmetric, B, C rectangular. SYNOPSIS subroutine csymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: lda,ldb,ldc,m,n\n   character,intent(in)  :: side,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),b(ldb,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CSYMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is a symmetric matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the symmetric matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the symmetric matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               symmetric matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               symmetric matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is COMPLEX array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is COMPLEX On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is COMPLEX array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code csymm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine csymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! !     End of CSYMM . ! end subroutine csymm","tags":"","loc":"proc/csymm.html"},{"title":"csyr2k – M_blas","text":"public  subroutine csyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME csyr2k(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] C:=alpha A TRANSPOSE(B)+alpha B TRANSPOSE(A)+beta*C, C symmetric. SYNOPSIS subroutine csyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: k,lda,ldb,ldc,n\n   character,intent(in)  :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*),b(ldb,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CSYR2K performs one of the symmetric rank 2k operations C := alpha * A * B ** T + alpha * B * A ** T + beta * C , or C := alpha * A ** T * B + alpha * B ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A and B are n by k matrices in the first case and k by n\n  matrices in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'T' or 't', K specifies the number of rows of the\n        matrices A and B. K must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is COMPLEX array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . BETA BETA is COMPLEX\n        On entry, BETA specifies the scalar beta. C C is COMPLEX array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code csyr2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp1 complex, public :: temp2 logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine csyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif ! !     End of CSYR2K. ! end subroutine csyr2k","tags":"","loc":"proc/csyr2k.html"},{"title":"csyrk – M_blas","text":"public  subroutine csyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME csyrk(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] C:=alpha A TRANSPOSE(A)+beta*C, C symmetric. SYNOPSIS subroutine csyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha,beta\n   integer,intent(in)    :: k,lda,ldc,n\n   character,intent(in)  :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: c(ldc,*)\n   .. DEFINITION CSYRK performs one of the symmetric rank k operations C := alpha * A * A ** T + beta * C , or C := alpha * A ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A is an n by k matrix in the first case and a k by n matrix\n  in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrix A, and on entry with\n        TRANS = 'T' or 't', K specifies the number of rows of the\n        matrix A. K must be at least zero. ALPHA ALPHA is COMPLEX\n        On entry, ALPHA specifies the scalar alpha. A A is COMPLEX array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is COMPLEX\n        On entry, BETA specifies the scalar beta. C C is COMPLEX array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp upper zero Source Code csyrk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine csyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : n , j ) = c ( 1 : n , j ) + temp * a ( 1 : n , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! !     End of CSYRK . ! end subroutine csyrk","tags":"","loc":"proc/csyrk.html"},{"title":"ctbmv – M_blas","text":"public  subroutine ctbmv(uplo, trans, diag, n, k, a, lda, x, incx) NAME ctbmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := A*CX, A is a triangular band matrix. SYNOPSIS subroutine ctbmv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,k,lda,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTBMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular band matrix, with ( k + 1 ) diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is COMPLEX array , dimension ( LDA , N ) . Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l noconj nounit temp zero Source Code ctbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + conjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo else if ( nounit ) temp = temp * conjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + conjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + conjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo else if ( nounit ) temp = temp * conjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif ! !     End of CTBMV . ! end subroutine ctbmv","tags":"","loc":"proc/ctbmv.html"},{"title":"ctbsv – M_blas","text":"public  subroutine ctbsv(uplo, trans, diag, n, k, a, lda, x, incx) NAME ctbsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := INVERSE(A)*CX, where A is a triangular band matrix. SYNOPSIS subroutine ctbsv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,k,lda,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTBSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular band matrix, with ( k + 1 )\n  diagonals. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is COMPLEX array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l noconj nounit temp zero Source Code ctbsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - conjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( kplus1 , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( a ( kplus1 , j )) endif x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - conjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( 1 , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - conjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( a ( 1 , j )) endif x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif ! !     End of CTBSV . ! end subroutine ctbsv","tags":"","loc":"proc/ctbsv.html"},{"title":"ctpmv – M_blas","text":"public  subroutine ctpmv(uplo, trans, diag, n, ap, x, incx) NAME ctpmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := A*CX, A is a packed triangular band matrix. SYNOPSIS subroutine ctpmv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: ap(*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTPMV  performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is COMPLEX array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: ap (*) complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx noconj nounit temp zero Source Code ctpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk - 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do i = j - 1 , 1 , - 1 temp = temp + conjg ( ap ( k )) * x ( i ) k = k - 1 enddo endif x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + conjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk + 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do i = j + 1 , n temp = temp + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo endif x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + conjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif ! !     End of CTPMV . ! end subroutine ctpmv","tags":"","loc":"proc/ctpmv.html"},{"title":"ctpsv – M_blas","text":"public  subroutine ctpsv(uplo, trans, diag, n, ap, x, incx) NAME ctpsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := INVERSE(A)*CX, where A is a packed triangular band matrix. SYNOPSIS subroutine ctpsv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: ap(*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTPSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is COMPLEX array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: ap (*) complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx noconj nounit temp zero Source Code ctpsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk if ( noconj ) then do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do i = 1 , j - 1 temp = temp - conjg ( ap ( k )) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / conjg ( ap ( kk + j - 1 )) endif x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do k = kk , kk + j - 2 temp = temp - conjg ( ap ( k )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( ap ( kk + j - 1 )) endif x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( ap ( k )) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / conjg ( ap ( kk - n + j )) endif x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - conjg ( ap ( k )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( ap ( kk - n + j )) endif x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif ! !     End of CTPSV . ! end subroutine ctpsv","tags":"","loc":"proc/ctpsv.html"},{"title":"ctrmm – M_blas","text":"public  subroutine ctrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME ctrmm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] B:=A B or B:=B A, A triangular, B rectangular. SYNOPSIS subroutine ctrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   integer,intent(in)    :: lda,ldb,m,n\n   character,intent(in)  :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: b(ldb,*)\n   .. DEFINITION CTRMM performs one of the matrix-matrix operations B := alpha * op ( A ) * B , or B := alpha * B * op ( A ) where alpha is a scalar, B is an m by n matrix, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether op ( A ) multiplies B from the left or right as follows : SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**H. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is COMPLEX On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is COMPLEX array, dimension ( LDA, k ), where k is m\n        when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is COMPLEX array , dimension ( LDB , N ) . Before entry , the leading m by n part of the array B must contain the matrix B , and on exit is overwritten by the transformed matrix . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside noconj nounit nrowa one temp upper zero Source Code ctrmm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: noconj logical, public :: nounit integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * conjg ( a ( i , i )) do k = 1 , i - 1 temp = temp + conjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * conjg ( a ( i , i )) do k = i + 1 , m temp = temp + conjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * conjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * conjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif ! !     End of CTRMM . ! end subroutine ctrmm","tags":"","loc":"proc/ctrmm.html"},{"title":"ctrmv – M_blas","text":"public  subroutine ctrmv(uplo, trans, diag, n, a, lda, x, incx) NAME ctrmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := A*CX, A is a triangular matrix. SYNOPSIS subroutine ctrmv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,lda,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTRMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is COMPLEX array, dimension ( LDA, N ).\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx noconj nounit temp zero Source Code ctrmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'CTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j - 1 , 1 , - 1 temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + conjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j + 1 , n temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j + 1 , n ix = ix + incx temp = temp + conjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif ! !     End of CTRMV . ! end subroutine ctrmv","tags":"","loc":"proc/ctrmv.html"},{"title":"ctrsm – M_blas","text":"public  subroutine ctrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME ctrsm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] B:=INVERSE(A) C or B:=C INVERSE(A), B, C rectangular, A triangular. SYNOPSIS subroutine ctrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   complex,intent(in)    :: alpha\n   integer,intent(in)    :: lda,ldb,m,n\n   character,intent(in)  :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: b(ldb,*)\n   .. DEFINITION CTRSM solves one of the matrix equations op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. The matrix X is overwritten on B. OPTIONS SIDE SIDE is CHARACTER*1\n        On entry, SIDE specifies whether op( A ) appears on the left\n        or right of X as follows:\n\n           SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n           SIDE = 'R' or 'r'   X*op( A ) = alpha*B. UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**H. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is COMPLEX On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is COMPLEX array, dimension ( LDA, k ),\n        where k is m when SIDE = 'L' or 'l'\n          and k is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is COMPLEX array , dimension ( LDB , N ) Before entry , the leading m by n part of the array B must contain the right - hand side matrix B , and on exit is overwritten by the solution matrix X . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside noconj nounit nrowa one temp upper zero Source Code ctrsm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: noconj logical, public :: nounit integer, public :: nrowa complex, public, parameter :: one = (1.0e+0,0.0e+0) complex, public :: temp logical, public :: upper complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: b ( ldb , * ) !     .. !  ===================================================================== !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) if ( noconj ) then do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = 1 , i - 1 temp = temp - conjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / conjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) if ( noconj ) then do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = i + 1 , m temp = temp - conjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / conjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / conjg ( a ( k , k )) endif b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / conjg ( a ( k , k )) endif b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif end subroutine ctrsm","tags":"","loc":"proc/ctrsm.html"},{"title":"ctrsv – M_blas","text":"public  subroutine ctrsv(uplo, trans, diag, n, a, lda, x, incx) NAME ctrsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CX := INVERSE(A)*CX, where A is a triangular matrix. SYNOPSIS subroutine ctrsv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)    :: incx,lda,n\n   character,intent(in)  :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex,intent(in)    :: a(lda,*)\n   complex,intent(inout) :: x(*)\n   .. DEFINITION CTRSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is COMPLEX array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is COMPLEX array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx noconj nounit temp zero Source Code ctrsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: noconj logical, public :: nounit complex, public :: temp complex, public, parameter :: zero = (0.0e+0,0.0e+0) Source Code subroutine ctrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'CTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - conjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n ix = kx temp = x ( jx ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - conjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 ix = kx temp = x ( jx ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( a ( i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( jx ) = temp jx = jx - incx enddo endif endif endif ! !     End of CTRSV . ! end subroutine ctrsv","tags":"","loc":"proc/ctrsv.html"},{"title":"daxpy – M_blas","text":"public  subroutine daxpy(n, da, dx, incx, dy, incy) NAME daxpy ( 3 f ) - [ BLAS : DOUBLE_BLAS_LEVEL1 ] constant times a vector plus a vector . SYNOPSIS subroutine daxpy(n,da,dx,incx,dy,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: da\n   integer,intent(in)             :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: dx(*)\n   double precision,intent(inout) :: dy(*)\n   .. DEFINITION DAXPY constant times a vector plus a vector . uses unrolled loops for increments equal to one . OPTIONS N N is INTEGER\n      number of elements in input vector(s) DA DA is DOUBLE PRECISION\n        On entry, DA specifies the scalar alpha. DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX DY DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of DY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy Contents Variables i ix iy m mp1 Source Code daxpy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) double precision , intent ( inout ) :: dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( da . eq . 0.0d0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 4 ) if ( m . ne . 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) enddo endif if ( n . lt . 4 ) return mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine daxpy","tags":"","loc":"proc/daxpy.html"},{"title":"dcopy – M_blas","text":"public  subroutine dcopy(n, dx, incx, dy, incy) NAME dcopy(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] copies elements of a vector,\n            x, to a vector, y. SYNOPSIS subroutine dcopy(n,dx,incx,dy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in)           :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)  :: dx(*)\n   double precision,intent(out) :: dy(*)\n   .. DEFINITION DCOPY copies a vector , x , to a vector , y . uses unrolled loops for increments equal to 1 . OPTIONS N N is INTEGER\n      number of elements in input vector(s) DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX DY DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of DY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(out) :: dy (*) integer, intent(in) :: incy Contents Variables i ix iy m mp1 Source Code dcopy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code subroutine dcopy ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) double precision , intent ( out ) :: dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 7 ) if ( m . ne . 0 ) then do i = 1 , m dy ( i ) = dx ( i ) enddo if ( n . lt . 7 ) return endif mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine dcopy","tags":"","loc":"proc/dcopy.html"},{"title":"dgbmv – M_blas","text":"public  subroutine dgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) NAME dgbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: incx,incy,kl,ku,lda,m,n\n   character,intent(in)           :: trans\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),x(*)\n   double precision,intent(inout) :: y(*)\n   .. DEFINITION DGBMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n band matrix, with kl sub-diagonals and ku super-diagonals. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. KL KL is INTEGER\n        On entry, KL specifies the number of sub-diagonals of the\n        matrix A. KL must satisfy 0 .le. KL. KU KU is INTEGER\n        On entry, KU specifies the number of super-diagonals of the\n        matrix A. KU must satisfy 0 .le. KU. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry , the leading ( kl + ku + 1 ) by n part of the array A must contain the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( ku + 1 ) of the array , the first super - diagonal starting at position 2 in row ku , the first sub - diagonal starting at position 1 in row ( ku + 2 ) , and so on . Elements in the array A that do not correspond to elements in the band matrix ( such as the top left ku by ku triangle ) are not referenced . The following program segment will transfer a band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( kl + ku + 1 ). X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is DOUBLE PRECISION array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kup1 kx ky lenx leny one temp zero Source Code dgbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kup1 integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'DGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif ! end subroutine dgbmv","tags":"","loc":"proc/dgbmv.html"},{"title":"dgemm – M_blas","text":"public  subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME dgemm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   DOUBLE PRECISION,intent(in)    :: ALPHA,BETA\n   integer,intent(in)             :: k,lda,ldb,ldc,m,n\n   character,intent(in)           :: transa,transb\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),b(ldb,*)\n   double precision,intent(inout) :: c(ldc,*)\n   .. DEFINITION DGEMM performs one of the matrix-matrix operations C := alpha * op ( A ) * op ( B ) + beta * C , where op( X ) is one of op( X ) = X   or   op( X ) = X**T, alpha and beta are scalars, and A, B and C are matrices, with op( A )\n  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. OPTIONS TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n',  op( A ) = A.\n\n           TRANSA = 'T' or 't',  op( A ) = A**T.\n\n           TRANSA = 'C' or 'c',  op( A ) = A**T. TRANSB TRANSB is CHARACTER*1\n        On entry, TRANSB specifies the form of op( B ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSB = 'N' or 'n',  op( B ) = B.\n\n           TRANSB = 'T' or 't',  op( B ) = B**T.\n\n           TRANSB = 'C' or 'c',  op( B ) = B**T. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix\n        op( A ) and of the matrix C. M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix\n        op( B ) and the number of columns of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry, K specifies the number of columns of the matrix\n        op( A ) and the number of rows of the matrix op( B ). K must\n        be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n        k when TRANSA = 'N' or 'n', and is m otherwise.\n        Before entry with TRANSA = 'N' or 'n', the leading m by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by m part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANSA = ' N ' or ' n ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , k ) . B B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is\n        n when TRANSB = 'N' or 'n', and is k otherwise.\n        Before entry with TRANSB = 'N' or 'n', the leading k by n\n        part of the array B must contain the matrix B, otherwise\n        the leading n by k part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANSB = ' N ' or ' n ' then LDB must be at least max ( 1 , k ) , otherwise LDB must be at least max ( 1 , n ) . BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is DOUBLE PRECISION array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n matrix ( alpha * op ( A ) * op ( B ) + beta * C ) . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nota notb nrowa nrowb one temp zero Source Code dgemm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l logical, public :: nota logical, public :: notb integer, public :: nrowa integer, public :: nrowb double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , l , nrowa , nrowb logical nota , notb !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . lsame ( transa , 'C' )) . and . (. not . lsame ( transa , 'T' ))) then info = 1 else if ((. not . notb ) . and . (. not . lsame ( transb , 'C' )) . and . (. not . lsame ( transb , 'T' ))) then info = 2 else if ( m . lt . 0 ) then info = 3 else if ( n . lt . 0 ) then info = 4 else if ( k . lt . 0 ) then info = 5 else if ( lda . lt . max ( 1 , nrowa )) then info = 8 else if ( ldb . lt . max ( 1 , nrowb )) then info = 10 else if ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'DGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And if  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero else if ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( nota ) then ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo else if ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( j , l ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine dgemm","tags":"","loc":"proc/dgemm.html"},{"title":"dgemv – M_blas","text":"public  subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) NAME dgemv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: incx,incy,lda,m,n\n   character,intent(in)           :: trans\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),x(*)\n   double precision,intent(inout) :: y(*)\n   .. DEFINITION DGEMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n matrix. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, N )\n        Before entry, the leading m by n part of the array A must\n        contain the matrix of coefficients. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is DOUBLE PRECISION array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry with BETA non - zero , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky lenx leny one temp zero Source Code dgemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 else if ( m . lt . 0 ) then info = 2 else if ( n . lt . 0 ) then info = 3 else if ( lda . lt . max ( 1 , m )) then info = 6 else if ( incx . eq . 0 ) then info = 8 else if ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) y ( 1 : m ) = y ( 1 : m ) + temp * a ( 1 : m , j ) jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! end subroutine dgemv","tags":"","loc":"proc/dgemv.html"},{"title":"dger – M_blas","text":"public  subroutine dger(m, n, alpha, x, incx, y, incy, a, lda) NAME dger(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dger(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: x(*),y(*)\n   double precision,intent(inout) :: a(lda,*)\n   .. DEFINITION DGER performs the rank 1 operation A := alpha * x * y ** T + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( m - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the m\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code dger Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dger ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: x ( * ), y ( * ) double precision , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DGER  ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif ! end subroutine dger","tags":"","loc":"proc/dger.html"},{"title":"drot – M_blas","text":"public  subroutine drot(n, dx, incx, dy, incy, c, s) NAME drot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] DROT applies a plane rotation. SYNOPSIS subroutine drot(n,dx,incx,dy,incy,c,s) applies a plane rotation.\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: c,s\n   integer,intent(in)             :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: dx(*),dy(*)\n   .. DEFINITION DROT applies a plane rotation. OPTIONS N\n          number of elements in input vector(s)\n   DX\n           array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX storage spacing between elements of DX DY\n           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n   INCY\n          storage spacing between elements of DY\n   C\n   S AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 \\ingroup double_blas_level1 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy double precision, intent(in) :: c double precision, intent(in) :: s Contents Variables dtemp i ix iy Source Code drot Variables Type Visibility Attributes Name Initial double precision, public :: dtemp integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine drot ( n , dx , incx , dy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: c , s integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! do i = 1 , n dtemp = c * dx ( i ) + s * dy ( i ) dy ( i ) = c * dy ( i ) - s * dx ( i ) dx ( i ) = dtemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = c * dx ( ix ) + s * dy ( iy ) dy ( iy ) = c * dy ( iy ) - s * dx ( ix ) dx ( ix ) = dtemp ix = ix + incx iy = iy + incy enddo endif end subroutine drot","tags":"","loc":"proc/drot.html"},{"title":"drotg – M_blas","text":"public  subroutine drotg(a, b, c, s) NAME drotg ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] constructs a plane rotation SYNOPSIS subroutine DROTG( a, b, c, s )\n\n .. Scalar Arguments ..\n real(wp),intent(inout) :: a, b\n real(wp),intent(out)   :: c, s DEFINITION DROTG constructs a plane rotation [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c 2 + s 2 = 1. The computation uses the formulas sigma = sgn ( a ) if | a | > | b | = sgn ( b ) if | b | >= | a | r = sigma * sqrt ( a ** 2 + b ** 2 ) c = 1 ; s = 0      if r = 0 c = a / r ; s = b/r  if r != 0 The subroutine also computes z = s if | a | > | b | , = 1 / c if | b | >= | a | and c != 0 = 1 if c = 0 This allows c and s to be reconstructed from z as follows: If z = 1 , set c = 0 , s = 1 . If | z | < 1 , set c = sqrt ( 1 - z ** 2 ) and s = z . If | z | > 1 , set c = 1 / z and s = sqrt ( 1 - c ** 2 ) . OPTIONS A\n           On entry, the scalar a.\n           On exit, the scalar r. B\n           On entry, the scalar b.\n           On exit, the scalar z. C\n           The scalar c. S\n           The scalar s. AUTHORS Edward Anderson, Lockheed Martin \\par Contributors: Weslley Pereira, University of Colorado Denver, USA \\ingroup single_blas_level1 FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s Contents Variables anorm bnorm one r safmax safmin scl sigma wp z zero Variables Type Visibility Attributes Name Initial real(kind=wp), public :: anorm real(kind=wp), public :: bnorm real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public :: r real(kind=wp), public, parameter :: safmax = real(radix(0.0_wp), wp)**max(1-minexponent(0.0_wp), maxexponent(0.0_wp)-1) real(kind=wp), public, parameter :: safmin = real(radix(0.0_wp), wp)**max(minexponent(0.0_wp)-1, 1-maxexponent(0.0_wp)) real(kind=wp), public :: scl real(kind=wp), public :: sigma integer, public, parameter :: wp = kind(1.d0) real(kind=wp), public :: z real(kind=wp), public, parameter :: zero = 0.0_wp","tags":"","loc":"proc/drotg.html"},{"title":"drotm – M_blas","text":"public  subroutine drotm(n, dx, incx, dy, incy, dparam) NAME drotm(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply the Modified Givens\nTransformation, H, to the 2 by N matrix SYNOPSIS subroutine drotm(n,dx,incx,dy,incy,dparam)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: dparam(5)\n   double precision,intent(inout) :: dx(*),dy(*)\n   .. DEFINITION Apply the Modified Givens Transformation , H , to the 2 by N matrix ( DX ** T ) , where ** T indicates transpose . the elements of DX are in ( DY ** T ) DX ( LX + I * INCX ) , I = 0 to N - 1 , where LX = 1 if INCX . ge . 0 , else LX = ( - INCX ) * N , and similarly for SY using LY and INCY . with DPARAM ( 1 ) = DFLAG , H has one of the following forms .. DFLAG =- 1 . D0 DFLAG = 0 . D0 DFLAG = 1 . D0 DFLAG =- 2 . D0 ( DH11 DH12 ) ( 1 . D0 DH12 ) ( DH11 1 . D0 ) ( 1 . D0 0 . D0 ) H = ( ) ( ) ( ) ( ) ( DH21 DH22 ) , ( DH21 1 . D0 ) , ( - 1 . D0 DH22 ) , ( 0 . D0 1 . D0 ) . SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM . OPTIONS N\n          number of elements in input vector(s)\n   DX\n           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX\n          storage spacing between elements of DX DY\n           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) )\n   INCY\n          storage spacing between elements of DY DPARAM\n           array, dimension (5) DPARAM(1)=DFLAG\n        DPARAM(2)=DH11\n        DPARAM(3)=DH21\n        DPARAM(4)=DH12\n        DPARAM(5)=DH22 AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 \\ingroup double_blas_level1 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy double precision, intent(in) :: dparam (5) Contents Variables dflag dh11 dh12 dh21 dh22 i kx ky nsteps two w z zero Source Code drotm Variables Type Visibility Attributes Name Initial double precision, public :: dflag double precision, public :: dh11 double precision, public :: dh12 double precision, public :: dh21 double precision, public :: dh22 integer, public :: i integer, public :: kx integer, public :: ky integer, public :: nsteps doubleprecision, public, parameter :: two = 2.0d0 double precision, public :: w double precision, public :: z doubleprecision, public, parameter :: zero = 0.0d0 Source Code subroutine drotm ( n , dx , incx , dy , incy , dparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dparam ( 5 ) double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dflag , dh11 , dh12 , dh21 , dh22 , w , z integer i , kx , ky , nsteps !     .. doubleprecision , parameter :: zero = 0.0d0 doubleprecision , parameter :: two = 2.0d0 !     .. ! dflag = dparam ( 1 ) if ( n . le . 0 . or . ( dflag + two . eq . zero )) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! nsteps = n * incx if ( dflag . lt . zero ) then dh11 = dparam ( 2 ) dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) dh22 = dparam ( 5 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w * dh11 + z * dh12 dy ( i ) = w * dh21 + z * dh22 enddo elseif ( dflag . eq . zero ) then dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w + z * dh12 dy ( i ) = w * dh21 + z enddo else dh11 = dparam ( 2 ) dh22 = dparam ( 5 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w * dh11 + z dy ( i ) = - w + dh22 * z enddo endif else kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy ! if ( dflag . lt . zero ) then dh11 = dparam ( 2 ) dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) dh22 = dparam ( 5 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w * dh11 + z * dh12 dy ( ky ) = w * dh21 + z * dh22 kx = kx + incx ky = ky + incy enddo elseif ( dflag . eq . zero ) then dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w + z * dh12 dy ( ky ) = w * dh21 + z kx = kx + incx ky = ky + incy enddo else dh11 = dparam ( 2 ) dh22 = dparam ( 5 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w * dh11 + z dy ( ky ) = - w + dh22 * z kx = kx + incx ky = ky + incy enddo endif endif end subroutine drotm","tags":"","loc":"proc/drotm.html"},{"title":"drotmg – M_blas","text":"public  subroutine drotmg(dd1, dd2, dx1, dy1, dparam) NAME drotmg(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] SYNOPSIS subroutine drotmg(dd1,dd2,dx1,dy1,dparam)\n\n   .. Scalar Arguments ..\n   double precision,intent(inout) :: dd1,dd2,dx1\n   double precision,intent(in)    :: dy1\n   ..\n   .. Array Arguments ..\n   double precision,intent(out)   :: dparam(5)\n   .. DEFINITION CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS THE SECOND COMPONENT OF THE 2 - VECTOR ( DSQRT ( DD1 ) * DX1 , DSQRT ( DD2 ) *> DY2 ) ** T . WITH DPARAM ( 1 ) = DFLAG , H HAS ONE OF THE FOLLOWING FORMS .. DFLAG =- 1 . D0 DFLAG = 0 . D0 DFLAG = 1 . D0 DFLAG =- 2 . D0 ( DH11 DH12 ) ( 1 . D0 DH12 ) ( DH11 1 . D0 ) ( 1 . D0 0 . D0 ) H = ( ) ( ) ( ) ( ) ( DH21 DH22 ) , ( DH21 1 . D0 ) , ( - 1 . D0 DH22 ) , ( 0 . D0 1 . D0 ) . LOCATIONS 2 - 4 OF DPARAM CONTAIN DH11 , DH21 , DH12 , AND DH22 RESPECTIVELY . ( VALUES OF 1 . D0 , - 1 . D0 , OR 0 . D0 IMPLIED BY THE VALUE OF DPARAM ( 1 ) ARE NOT STORED IN DPARAM . ) THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE INEXACT . THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE OF DD1 AND DD2 . ALL ACTUAL SCALING OF DATA IS DONE USING GAM . OPTIONS DD1 DD1 is DOUBLE PRECISION DD2 DD2 is DOUBLE PRECISION DX1 DX1 is DOUBLE PRECISION DY1 DY1 is DOUBLE PRECISION DPARAM DPARAM is DOUBLE PRECISION array, dimension (5)\n  DPARAM(1)=DFLAG\n  DPARAM(2)=DH11\n  DPARAM(3)=DH21\n  DPARAM(4)=DH12\n  DPARAM(5)=DH22 AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: dd1 double precision, intent(inout) :: dd2 double precision, intent(inout) :: dx1 double precision, intent(in) :: dy1 double precision, intent(out) :: dparam (5) Contents Variables dflag dh11 dh12 dh21 dh22 dp1 dp2 dq1 dq2 dtemp du gam gamsq one rgamsq two zero Source Code drotmg Variables Type Visibility Attributes Name Initial double precision, public :: dflag double precision, public :: dh11 double precision, public :: dh12 double precision, public :: dh21 double precision, public :: dh22 double precision, public :: dp1 double precision, public :: dp2 double precision, public :: dq1 double precision, public :: dq2 double precision, public :: dtemp double precision, public :: du doubleprecision, public, parameter :: gam = 4096.d0 doubleprecision, public, parameter :: gamsq = 16777216.d0 doubleprecision, public, parameter :: one = 1.0d0 doubleprecision, public, parameter :: rgamsq = 5.9604645d-8 doubleprecision, public, parameter :: two = 2.0d0 doubleprecision, public, parameter :: zero = 0.0d0 Source Code subroutine drotmg ( dd1 , dd2 , dx1 , dy1 , dparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( inout ) :: dd1 , dd2 , dx1 double precision , intent ( in ) :: dy1 !     .. !     .. Array Arguments .. double precision , intent ( out ) :: dparam ( 5 ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dflag , dh11 , dh12 , dh21 , dh22 , dp1 , dp2 , dq1 , dq2 , dtemp , du !     .. !     .. Intrinsic Functions .. intrinsic dabs !     .. !     .. Data statements .. ! doubleprecision , parameter :: zero = 0.0d0 doubleprecision , parameter :: one = 1.0d0 doubleprecision , parameter :: two = 2.0d0 doubleprecision , parameter :: gam = 409 6.d0 doubleprecision , parameter :: gamsq = 1677721 6.d0 doubleprecision , parameter :: rgamsq = 5.9604645d-8 !     .. if ( dd1 . lt . zero ) then !        GO ZERO-H-D-AND-DX1.. dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero else !        CASE-DD1-NONNEGATIVE dp2 = dd2 * dy1 if ( dp2 . eq . zero ) then dflag = - two dparam ( 1 ) = dflag return endif !        REGULAR-CASE.. dp1 = dd1 * dx1 dq2 = dp2 * dy1 dq1 = dp1 * dx1 ! if ( dabs ( dq1 ). gt . dabs ( dq2 )) then dh21 = - dy1 / dx1 dh12 = dp2 / dp1 ! du = one - dh12 * dh21 ! if ( du . gt . zero ) then dflag = zero dd1 = dd1 / du dd2 = dd2 / du dx1 = dx1 * du else !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero endif else if ( dq2 . lt . zero ) then !              GO ZERO-H-D-AND-DX1.. dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero else dflag = one dh11 = dp1 / dp2 dh22 = dx1 / dy1 du = one + dh11 * dh22 dtemp = dd2 / du dd2 = dd1 / du dd1 = dtemp dx1 = dy1 * du endif endif !     PROCEDURE..SCALE-CHECK if ( dd1 . ne . zero ) then do while (( dd1 . le . rgamsq ) . or . ( dd1 . ge . gamsq )) if ( dflag . eq . zero ) then dh11 = one dh22 = one dflag = - one else dh21 = - one dh12 = one dflag = - one endif if ( dd1 . le . rgamsq ) then dd1 = dd1 * gam ** 2 dx1 = dx1 / gam dh11 = dh11 / gam dh12 = dh12 / gam else dd1 = dd1 / gam ** 2 dx1 = dx1 * gam dh11 = dh11 * gam dh12 = dh12 * gam endif enddo endif if ( dd2 . ne . zero ) then do while ( ( dabs ( dd2 ). le . rgamsq ) . or . ( dabs ( dd2 ). ge . gamsq ) ) if ( dflag . eq . zero ) then dh11 = one dh22 = one dflag = - one else dh21 = - one dh12 = one dflag = - one endif if ( dabs ( dd2 ). le . rgamsq ) then dd2 = dd2 * gam ** 2 dh21 = dh21 / gam dh22 = dh22 / gam else dd2 = dd2 / gam ** 2 dh21 = dh21 * gam dh22 = dh22 * gam endif enddo endif endif if ( dflag . lt . zero ) then dparam ( 2 ) = dh11 dparam ( 3 ) = dh21 dparam ( 4 ) = dh12 dparam ( 5 ) = dh22 elseif ( dflag . eq . zero ) then dparam ( 3 ) = dh21 dparam ( 4 ) = dh12 else dparam ( 2 ) = dh11 dparam ( 5 ) = dh22 endif dparam ( 1 ) = dflag end subroutine drotmg","tags":"","loc":"proc/drotmg.html"},{"title":"dsbmv – M_blas","text":"public  subroutine dsbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) NAME dsbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dsbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: incx,incy,k,lda,n\n   character,intent(in)           :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),x(*)\n   double precision,intent(inout) :: y(*)\n   .. DEFINITION DSBMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric band matrix, with k super-diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the band matrix A is being supplied as\n        follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               being supplied.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               being supplied. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry, K specifies the number of super-diagonals of the\n        matrix A. K must satisfy 0 .le. K. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer the upper triangular part of a symmetric band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a symmetric band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is DOUBLE PRECISION.\n        On entry, BETA specifies the scalar beta. Y Y is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kplus1 kx ky l one temp1 temp2 zero Source Code dsbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kplus1 integer, public :: kx integer, public :: ky integer, public :: l double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp1 double precision, public :: temp2 double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DSBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( kplus1 , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( kplus1 , j ) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( 1 , j ) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( 1 , j ) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsbmv","tags":"","loc":"proc/dsbmv.html"},{"title":"dscal – M_blas","text":"public  subroutine dscal(n, da, dx, incx) NAME dscal ( 3 f ) - [ BLAS : DOUBLE_BLAS_LEVEL1 ] scales a vector by a constant . SYNOPSIS subroutine dscal(n,da,dx,incx)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: da\n   integer,intent(in)             :: incx,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: dx(*)\n   .. DEFINITION DSCAL scales a vector by a constant . uses unrolled loops for increment equal to 1. OPTIONS N\n           number of elements in input vector(s)\n   DA\n           On entry, DA specifies the scalar alpha.\n   DX\n           array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX\n           storage spacing between elements of DX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da double precision, intent(inout) :: dx (*) integer, intent(in) :: incx Contents Variables i m mp1 nincx Source Code dscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: m integer, public :: mp1 integer, public :: nincx Source Code subroutine dscal ( n , da , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) enddo if ( n . lt . 5 ) return endif mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) enddo endif end subroutine dscal","tags":"","loc":"proc/dscal.html"},{"title":"dspmv – M_blas","text":"public  subroutine dspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) NAME dspmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: incx,incy,n\n   character,intent(in)           :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: ap(*),x(*)\n   double precision,intent(inout) :: y(*)\n   .. DEFINITION DSPMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. AP AP is DOUBLE PRECISION array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular part of the symmetric matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n        and a( 2, 2 ) respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular part of the symmetric matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n        and a( 3, 1 ) respectively, and so on. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: ap (*) double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kk kx ky one temp1 temp2 zero Source Code dspmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp1 double precision, public :: temp2 double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DSPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * ap ( kk ) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * ap ( kk ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif ! end subroutine dspmv","tags":"","loc":"proc/dspmv.html"},{"title":"dspr – M_blas","text":"public  subroutine dspr(uplo, n, alpha, x, incx, ap) NAME dspr(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dspr(uplo,n,alpha,x,incx,ap)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: incx,n\n   character,intent(in)           :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: ap(*)\n   double precision,intent(in)    :: x(*)\n   .. DESCRIPTION DSPR performs the symmetric rank 1 operation A := alpha * x * x ** T + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AP AP is DOUBLE PRECISION array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(inout) :: ap (*) Contents Variables i info ix j jx k kk kx temp zero Source Code dspr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dspr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: ap ( * ) double precision , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'DSPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif ! end subroutine dspr","tags":"","loc":"proc/dspr.html"},{"title":"dspr2 – M_blas","text":"public  subroutine dspr2(uplo, n, alpha, x, incx, y, incy, ap) NAME dspr2(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dspr2(uplo,n,alpha,x,incx,y,incy,ap)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: incx,incy,n\n   character,intent(in)            :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: ap(*)\n   double precision,intent(in)    :: x(*),y(*)\n   .. DEFINITION DSPR2 performs the symmetric rank 2 operation A := alpha * x * y ** T + alpha * y * x ** T + A , where alpha is a scalar, x and y are n element vectors and A is an\n  n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AP AP is DOUBLE PRECISION array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: ap (*) Contents Variables i info ix iy j jx jy k kk kx ky temp1 temp2 zero Source Code dspr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky double precision, public :: temp1 double precision, public :: temp2 double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: ap ( * ) double precision , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DSPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif ! end subroutine dspr2","tags":"","loc":"proc/dspr2.html"},{"title":"dswap – M_blas","text":"public  subroutine dswap(n, dx, incx, dy, incy) NAME dswap(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] interchanges two vectors. SYNOPSIS subroutine dswap(n,dx,incx,dy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: dx(*),dy(*)\n   .. DEFINITION DSWAP interchanges two vectors . uses unrolled loops for increments equal to 1 . OPTIONS N N is INTEGER\n      number of elements in input vector(s) DX DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of DX DY DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of DY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy Contents Variables dtemp i ix iy m mp1 Source Code dswap Variables Type Visibility Attributes Name Initial double precision, public :: dtemp integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code subroutine dswap ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! ! !       clean-up loop ! m = mod ( n , 3 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dx ( i ) dx ( i ) = dy ( i ) dy ( i ) = dtemp enddo if ( n . lt . 3 ) return endif mp1 = m + 1 do i = mp1 , n , 3 dtemp = dx ( i ) dx ( i ) = dy ( i ) dy ( i ) = dtemp dtemp = dx ( i + 1 ) dx ( i + 1 ) = dy ( i + 1 ) dy ( i + 1 ) = dtemp dtemp = dx ( i + 2 ) dx ( i + 2 ) = dy ( i + 2 ) dy ( i + 2 ) = dtemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dx ( ix ) dx ( ix ) = dy ( iy ) dy ( iy ) = dtemp ix = ix + incx iy = iy + incy enddo endif end subroutine dswap","tags":"","loc":"proc/dswap.html"},{"title":"dsymm – M_blas","text":"public  subroutine dsymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME dsymm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: lda,ldb,ldc,m,n\n   character,intent(in)           :: side,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),b(ldb,*)\n   double precision,intent(inout) :: c(ldc,*)\n   .. DEFINITION DSYMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is a symmetric matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the symmetric matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the symmetric matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               symmetric matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               symmetric matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is DOUBLE PRECISION array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is DOUBLE PRECISION array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code dsymm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp1 double precision, public :: temp2 logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'DSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! end subroutine dsymm","tags":"","loc":"proc/dsymm.html"},{"title":"dsymv – M_blas","text":"public  subroutine dsymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) NAME dsymv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dsymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: incx,incy,lda,n\n   character,intent(in)           :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),x(*)\n   double precision,intent(inout) :: y(*)\n   .. DEFINITION DSYMV performs the matrix-vector  operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular part of the symmetric matrix and the strictly\n        lower triangular part of A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular part of the symmetric matrix and the strictly\n        upper triangular part of A is not referenced. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is DOUBLE PRECISION . On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky one temp1 temp2 zero Source Code dsymv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp1 double precision, public :: temp2 double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'DSYMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( j , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( j , j ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( j , j ) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( j , j ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsymv","tags":"","loc":"proc/dsymv.html"},{"title":"dsyr – M_blas","text":"public  subroutine dsyr(uplo, n, alpha, x, incx, a, lda) NAME dsyr(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dsyr(uplo,n,alpha,x,incx,a,lda)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)       :: alpha\n   integer,intent(in)                :: incx,lda,n\n   character,intent(in)              :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout)    :: a(lda,*)\n   double precision,intent(in)       :: x(*)\n   .. DEFINITION DSYR performs the symmetric rank 1 operation A := alpha * x * x ** T + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 \\ingroup double_blas_level2 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jx kx temp zero Source Code dsyr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsyr ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: a ( lda , * ) double precision , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( 1 : j , j ) = a ( 1 : j , j ) + x ( 1 : j ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( j : n , j ) = a ( j : n , j ) + x ( j : n ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif endif ! end subroutine dsyr","tags":"","loc":"proc/dsyr.html"},{"title":"dsyr2 – M_blas","text":"public  subroutine dsyr2(uplo, n, alpha, x, incx, y, incy, a, lda) NAME dsyr2(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dsyr2(uplo,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: incx,incy,lda,n\n   character,intent(in)           :: uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(inout) :: a(lda,*)\n   double precision,intent(in)    :: x(*),y(*)\n   .. DEFINITION DSYR2 performs the symmetric rank 2 operation A := alpha * x * y ** T + alpha * y * x ** T + A , where alpha is a scalar, x and y are n element vectors and A is an n\n  by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is DOUBLE PRECISION array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix iy j jx jy kx ky temp1 temp2 zero Source Code dsyr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky double precision, public :: temp1 double precision, public :: temp2 double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: a ( lda , * ) double precision , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = 1 , j a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = j , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsyr2","tags":"","loc":"proc/dsyr2.html"},{"title":"dsyr2k – M_blas","text":"public  subroutine dsyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME dsyr2k(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: k,lda,ldb,ldc,n\n   character,intent(in)           :: trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*),b(ldb,*)\n   double precision,intent(inout) :: c(ldc,*)\n   .. DEFINITION DSYR2K performs one of the symmetric rank 2k operations C := alpha * A * B ** T + alpha * B * A ** T + beta * C , or C := alpha * A ** T * B + alpha * B ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A and B are n by k matrices in the first case and k by n\n  matrices in the second case. OPTIONS UPLO On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . N On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'T' or 't' or 'C' or 'c', K specifies the number\n        of rows of the matrices A and B. K must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . BETA BETA is DOUBLE PRECISION.\n        On entry, BETA specifies the scalar beta. C C is DOUBLE PRECISION array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code dsyr2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp1 double precision, public :: temp2 logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif ! end subroutine dsyr2k","tags":"","loc":"proc/dsyr2k.html"},{"title":"dsyrk – M_blas","text":"public  subroutine dsyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME dsyrk(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha,beta\n   integer,intent(in)             :: k,lda,ldc,n\n   character,intent(in)           :: trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: c(ldc,*)\n   .. DEFINITION DSYRK performs one of the symmetric rank k operations C := alpha * A * A ** T + beta * C , or C := alpha * A ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A is an n by k matrix in the first case and a k by n matrix\n  in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrix A, and on entry with\n        TRANS = 'T' or 't' or 'C' or 'c', K specifies the number\n        of rows of the matrix A. K must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. A A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is DOUBLE PRECISION.\n        On entry, BETA specifies the scalar beta. C C is DOUBLE PRECISION array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 \\ingroup double_blas_level3 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp upper zero Source Code dsyrk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dsyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 else if ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 else if ( n . lt . 0 ) then info = 3 else if ( k . lt . 0 ) then info = 4 else if ( lda . lt . max ( 1 , nrowa )) then info = 7 else if ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'DSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero else if ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero else if ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + temp * a ( j : n , l ) endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine dsyrk","tags":"","loc":"proc/dsyrk.html"},{"title":"dtbmv – M_blas","text":"public  subroutine dtbmv(uplo, trans, diag, n, k, a, lda, x, incx) NAME dtbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dtbmv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,k,lda,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTBMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular band matrix, with ( k + 1 ) diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 \\ingroup double_blas_level2 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l nounit temp zero Source Code dtbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif ! end subroutine dtbmv","tags":"","loc":"proc/dtbmv.html"},{"title":"dtbsv – M_blas","text":"public  subroutine dtbsv(uplo, trans, diag, n, k, a, lda, x, incx) NAME dtbsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dtbsv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,k,lda,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTBSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular band matrix, with ( k + 1 )\n  diagonals. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is DOUBLE PRECISION array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 \\ingroup double_blas_level2 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l nounit temp zero Source Code dtbsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T)*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif ! end subroutine dtbsv","tags":"","loc":"proc/dtbsv.html"},{"title":"dtpmv – M_blas","text":"public  subroutine dtpmv(uplo, trans, diag, n, ap, x, incx) NAME dtpmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dtpmv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: ap(*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTPMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is DOUBLE PRECISION array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 \\ingroup double_blas_level2 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: ap (*) double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx nounit temp zero Source Code dtpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk - 1 do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk + 1 do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif ! end subroutine dtpmv","tags":"","loc":"proc/dtpmv.html"},{"title":"dtpsv – M_blas","text":"public  subroutine dtpsv(uplo, trans, diag, n, ap, x, incx) NAME dtpsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dtpsv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: ap(*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTPSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is DOUBLE PRECISION array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: ap (*) double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx nounit temp zero Source Code dtpsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif ! end subroutine dtpsv","tags":"","loc":"proc/dtpsv.html"},{"title":"dtrmm – M_blas","text":"public  subroutine dtrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME dtrmm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dtrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: lda,ldb,m,n\n   character,intent(in)           :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: b(ldb,*)\n   .. DEFINITION DTRMM performs one of the matrix-matrix operations B := alpha * op ( A ) * B , or B := alpha * B * op ( A ), where alpha is a scalar, B is an m by n matrix, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether op ( A ) multiplies B from the left or right as follows : SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**T. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is DOUBLE PRECISION . On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is DOUBLE PRECISION array, dimension ( LDA, k ), where k is m\n        when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is DOUBLE PRECISION array , dimension ( LDB , N ) Before entry , the leading m by n part of the array B must contain the matrix B , and on exit is overwritten by the transformed matrix . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside nounit nrowa one temp upper zero Source Code dtrmm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: nounit integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif ! end subroutine dtrmm","tags":"","loc":"proc/dtrmm.html"},{"title":"dtrmv – M_blas","text":"public  subroutine dtrmv(uplo, trans, diag, n, a, lda, x, incx) NAME dtrmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] SYNOPSIS subroutine dtrmv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,lda,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTRMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is DOUBLE PRECISION array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx nounit temp zero Source Code dtrmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'DTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif ! end subroutine dtrmv","tags":"","loc":"proc/dtrmv.html"},{"title":"dtrsm – M_blas","text":"public  subroutine dtrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME dtrsm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] SYNOPSIS subroutine dtrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)    :: alpha\n   integer,intent(in)             :: lda,ldb,m,n\n   character,intent(in)           :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: b(ldb,*)\n   .. DEFINITION DTRSM solves one of the matrix equations op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T. The matrix X is overwritten on B. OPTIONS SIDE SIDE is CHARACTER*1\n        On entry, SIDE specifies whether op( A ) appears on the left\n        or right of X as follows:\n\n           SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n           SIDE = 'R' or 'r'   X*op( A ) = alpha*B. UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**T. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is DOUBLE PRECISION . On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is DOUBLE PRECISION array, dimension ( LDA, k ),\n\n        where k is m when SIDE = 'L' or 'l'\n          and k is n when SIDE = 'R' or 'r'.\n\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA\n            On entry, LDA specifies the first dimension of A as declared\n            in the calling (sub) program. When SIDE = ‘L’ or ‘l’ then\n            LDA must be at least max( 1, m ), when SIDE = ‘R’ or ‘r’\n            then LDA must be at least max( 1, n ). B\n            Before entry, the leading m by n part of the array B must\n            contain the right-hand side matrix B, and on exit is\n            overwritten by the solution matrix X. LDB\n            On entry, LDB specifies the first dimension of B as declared\n            in the calling (sub) program. LDB must be at least\n            max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside nounit nrowa one temp upper zero Source Code dtrsm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: nounit integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: temp logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif ! end subroutine dtrsm","tags":"","loc":"proc/dtrsm.html"},{"title":"dtrsv – M_blas","text":"public  subroutine dtrsv(uplo, trans, diag, n, a, lda, x, incx) NAME dtrsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] SYNOPSIS subroutine dtrsv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)             :: incx,lda,n\n   character,intent(in)           :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   double precision,intent(in)    :: a(lda,*)\n   double precision,intent(inout) :: x(*)\n   .. DEFINITION DTRSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is DOUBLE PRECISION array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is DOUBLE PRECISION array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx nounit temp zero Source Code dtrsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: nounit double precision, public :: temp double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine dtrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'DTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine dtrsv","tags":"","loc":"proc/dtrsv.html"},{"title":"saxpy – M_blas","text":"public  subroutine saxpy(n, sa, sx, incx, sy, incy) NAME saxpy ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SY : = SY + SA * SX ( constant times a vector plus a vector ) SYNOPSIS subroutine saxpy(n,sa,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)     :: sa\n   integer,intent(in)  :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in)     :: sx(*)\n   real,intent(inout)  :: sy(*)\n   .. DEFINITION SAXPY constant times a vector plus a vector . uses unrolled loops for increments equal to one . OPTIONS N\n          number of elements in input vector(s)\n   SA\n          On entry, SA specifies the scalar alpha.\n   SX\n          SX is REAL array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX\n          storage spacing between elements of SX\n   SY\n          SY is REAL array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY\n          storage spacing between elements of SY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy Contents Variables i ix iy m mp1 Source Code saxpy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code subroutine saxpy ( n , sa , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) real , intent ( inout ) :: sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( sa . eq . 0.0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 4 ) if ( m . ne . 0 ) then do i = 1 , m sy ( i ) = sy ( i ) + sa * sx ( i ) enddo endif if ( n . lt . 4 ) return mp1 = m + 1 do i = mp1 , n , 4 sy ( i ) = sy ( i ) + sa * sx ( i ) sy ( i + 1 ) = sy ( i + 1 ) + sa * sx ( i + 1 ) sy ( i + 2 ) = sy ( i + 2 ) + sa * sx ( i + 2 ) sy ( i + 3 ) = sy ( i + 3 ) + sa * sx ( i + 3 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n sy ( iy ) = sy ( iy ) + sa * sx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine saxpy","tags":"","loc":"proc/saxpy.html"},{"title":"scopy – M_blas","text":"public  subroutine scopy(n, sx, incx, sy, incy) NAME scopy ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SY := SX SYNOPSIS subroutine scopy(n,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in)  :: sx(*)\n   real,intent(out) :: sy(*)\n   .. DEFINITION SCOPY copies a vector , x , to a vector , y . uses unrolled loops for increments equal to 1 . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of SY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(out) :: sy (*) integer, intent(in) :: incy Contents Variables i ix iy m mp1 Source Code scopy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 Source Code subroutine scopy ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) real , intent ( out ) :: sy ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 7 ) if ( m . ne . 0 ) then do i = 1 , m sy ( i ) = sx ( i ) enddo if ( n . lt . 7 ) return endif mp1 = m + 1 do i = mp1 , n , 7 sy ( i ) = sx ( i ) sy ( i + 1 ) = sx ( i + 1 ) sy ( i + 2 ) = sx ( i + 2 ) sy ( i + 3 ) = sx ( i + 3 ) sy ( i + 4 ) = sx ( i + 4 ) sy ( i + 5 ) = sx ( i + 5 ) sy ( i + 6 ) = sx ( i + 6 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n sy ( iy ) = sx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine scopy","tags":"","loc":"proc/scopy.html"},{"title":"set_xerbla – M_blas","text":"public  subroutine set_xerbla(proc) Arguments Type Intent Optional Attributes Name procedure( xerbla_interface ) :: proc Contents Source Code set_xerbla Source Code subroutine set_xerbla ( proc ) procedure ( xerbla_interface ) :: proc xerbla => proc end subroutine set_xerbla","tags":"","loc":"proc/set_xerbla.html"},{"title":"sgbmv – M_blas","text":"public  subroutine sgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) NAME sgbmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SY:=alpha A SX+beta*SY, A a band matrix. SYNOPSIS subroutine sgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)             :: alpha,beta\n   integer,intent(in)          :: incx,incy,kl,ku,lda,m,n\n   character(len=1),intent(in) :: trans\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: a(lda,*),x(*)\n   real,intent(inout) :: y(*)\n   .. DEFINITION SGBMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n band matrix, with kl sub-diagonals and ku super-diagonals. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. KL KL is INTEGER\n        On entry, KL specifies the number of sub-diagonals of the\n        matrix A. KL must satisfy 0 .le. KL. KU KU is INTEGER\n        On entry, KU specifies the number of super-diagonals of the\n        matrix A. KU must satisfy 0 .le. KU. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array , dimension ( LDA , N ) Before entry , the leading ( kl + ku + 1 ) by n part of the array A must contain the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( ku + 1 ) of the array , the first super - diagonal starting at position 2 in row ku , the first sub - diagonal starting at position 1 in row ( ku + 2 ) , and so on . Elements in the array A that do not correspond to elements in the band matrix ( such as the top left ku by ku triangle ) are not referenced . The following program segment will transfer a band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( kl + ku + 1 ). X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is REAL array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kup1 kx ky lenx leny one temp zero Source Code sgbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kup1 integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny real, public, parameter :: one = 1.0e+0 real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine sgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character ( len = 1 ), intent ( in ) :: trans !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'SGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif end subroutine sgbmv","tags":"","loc":"proc/sgbmv.html"},{"title":"sgemm – M_blas","text":"public  subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME sgemm(3f) - [BLAS:SINGLE_BLAS_LEVEL3] C:=alpha A B+beta*C, A, B, C rectangular. SYNOPSIS subroutine sgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: k,lda,ldb,ldc,m,n\n   character,intent(in) :: transa,transb\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: a(lda,*),b(ldb,*)\n   real,intent(inout) :: c(ldc,*)\n   .. DEFINITION SGEMM performs one of the matrix-matrix operations C := alpha * op ( A ) * op ( B ) + beta * C , where op( X ) is one of op( X ) = X   or   op( X ) = X**T, alpha and beta are scalars, and A, B and C are matrices, with op( A )\n  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. OPTIONS TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n',  op( A ) = A.\n\n           TRANSA = 'T' or 't',  op( A ) = A**T.\n\n           TRANSA = 'C' or 'c',  op( A ) = A**T. TRANSB TRANSB is CHARACTER*1\n        On entry, TRANSB specifies the form of op( B ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSB = 'N' or 'n',  op( B ) = B.\n\n           TRANSB = 'T' or 't',  op( B ) = B**T.\n\n           TRANSB = 'C' or 'c',  op( B ) = B**T. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix\n        op( A ) and of the matrix C. M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix\n        op( B ) and the number of columns of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry, K specifies the number of columns of the matrix\n        op( A ) and the number of rows of the matrix op( B ). K must\n        be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, ka ), where ka is\n        k when TRANSA = 'N' or 'n', and is m otherwise.\n\n        Before entry with TRANSA = 'N' or 'n', the leading m by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by m part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANSA = ' N ' or ' n ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , k ) . B B is REAL array, dimension ( LDB, kb ), where kb is\n        n when TRANSB = 'N' or 'n', and is k otherwise.\n\n        Before entry with TRANSB = 'N' or 'n', the leading k by n\n        part of the array B must contain the matrix B, otherwise\n        the leading n by k part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANSB = ' N ' or ' n ' then LDB must be at least max ( 1 , k ) , otherwise LDB must be at least max ( 1 , n ) . BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is REAL array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n matrix ( alpha * op ( A ) * op ( B ) + beta * C ) . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nota notb nrowa nrowb one temp zero Source Code sgemm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l logical, public :: nota logical, public :: notb integer, public :: nrowa integer, public :: nrowb real, public, parameter :: one = 1.0e+0 real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , l , nrowa , nrowb logical nota , notb !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . lsame ( transa , 'C' )) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . lsame ( transb , 'C' )) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'SGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And if  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( nota ) then ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( j , l ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine sgemm","tags":"","loc":"proc/sgemm.html"},{"title":"sgemv – M_blas","text":"public  subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) NAME sgemv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SY:=alpha A SX+beta*SY, A a rectangular matrix. SYNOPSIS subroutine sgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: incx,incy,lda,m,n\n   character,intent(in) :: trans\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: a(lda,*),x(*)\n   real,intent(inout) :: y(*)\n   .. DEFINITION SGEMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n matrix. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** T * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, N )\n        Before entry, the leading m by n part of the array A must\n        contain the matrix of coefficients. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is REAL array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry with BETA non - zero , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky lenx leny one temp zero Source Code sgemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny real, public, parameter :: one = 1.0e+0 real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'SGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif end subroutine sgemv","tags":"","loc":"proc/sgemv.html"},{"title":"sger – M_blas","text":"public  subroutine sger(m, n, alpha, x, incx, y, incy, a, lda) NAME sger(3f) - [BLAS:SINGLE_BLAS_LEVEL2] A:=A+alpha SX TRANSPOSE(SY), rank 1 update, A a rectangular matrix. SYNOPSIS subroutine sger(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   real,intent(in)    :: alpha\n   integer,intent(in) :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: x(*),y(*)\n   real,intent(inout) :: a(lda,*)\n   .. DEFINITION SGER performs the rank 1 operation A := alpha * x * y ** T + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is REAL array, dimension at least\n        ( 1 + ( m - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the m\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is REAL array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code sger Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine sger ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SGER  ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine sger","tags":"","loc":"proc/sger.html"},{"title":"srot – M_blas","text":"public  subroutine srot(n, sx, incx, sy, incy, c, s) NAME srot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply Given's rotation. SYNOPSIS subroutine srot(n,sx,incx,sy,incy,c,s)\n\n   .. Scalar Arguments ..\n   real,intent(in)    :: c,s\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(inout) :: sx(*),sy(*)\n   .. DEFINITION applies a plane rotation. OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of SY C C is REAL S S is REAL AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy real, intent(in) :: c real, intent(in) :: s Contents Variables i ix iy stemp Source Code srot Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy real, public :: stemp Source Code subroutine srot ( n , sx , incx , sy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: c , s integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! do i = 1 , n stemp = c * sx ( i ) + s * sy ( i ) sy ( i ) = c * sy ( i ) - s * sx ( i ) sx ( i ) = stemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = c * sx ( ix ) + s * sy ( iy ) sy ( iy ) = c * sy ( iy ) - s * sx ( ix ) sx ( ix ) = stemp ix = ix + incx iy = iy + incy enddo endif end subroutine srot","tags":"","loc":"proc/srot.html"},{"title":"srotg – M_blas","text":"public  subroutine srotg(a, b, c, s) NAME srotg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate Given's rotation. SYNOPSIS subroutine srotg( a, b, c, s ) .. Scalar Arguments .. real(wp),intent(inout) :: a, b\nreal(wp),intent(out)   :: c, s .. .. Local Scalars .. real(wp) :: anorm, bnorm, scl, sigma, r, z .. DEFINITION SROTG constructs a plane rotation [ c s ] [ a ] = [ r ] [ - s c ] [ b ] [ 0 ] satisfying c 2 + s 2 = 1. The computation uses the formulas sigma = sgn ( a ) if | a | > | b | = sgn ( b ) if | b | >= | a | r = sigma * sqrt ( a ** 2 + b ** 2 ) c = 1 ; s = 0      if r = 0 c = a / r ; s = b/r  if r != 0 The subroutine also computes z = s if | a | > | b | , = 1 / c if | b | >= | a | and c != 0 = 1 if c = 0 This allows c and s to be reconstructed from z as follows: If z = 1 , set c = 0 , s = 1 . If | z | < 1 , set c = sqrt ( 1 - z ** 2 ) and s = z . If | z | > 1 , set c = 1 / z and s = sqrt ( 1 - c ** 2 ) . OPTIONS A A is REAL On entry , the scalar a . On exit , the scalar r . B B is REAL On entry , the scalar b . On exit , the scalar z . C C is REAL\n       The scalar c. S S is REAL\n       The scalar s. AUTHORS Edward Anderson, Lockheed Martin \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s Contents Variables anorm bnorm one r safmax safmin scl sigma wp z zero Variables Type Visibility Attributes Name Initial real(kind=wp), public :: anorm real(kind=wp), public :: bnorm real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public :: r real(kind=wp), public, parameter :: safmax = real(radix(0._wp), wp)**max(1-minexponent(0._wp), maxexponent(0._wp)-1) real(kind=wp), public, parameter :: safmin = real(radix(0._wp), wp)**max(minexponent(0._wp)-1, 1-maxexponent(0._wp)) real(kind=wp), public :: scl real(kind=wp), public :: sigma integer, public, parameter :: wp = kind(1.e0) real(kind=wp), public :: z real(kind=wp), public, parameter :: zero = 0.0_wp","tags":"","loc":"proc/srotg.html"},{"title":"srotm – M_blas","text":"public  subroutine srotm(n, sx, incx, sy, incy, sparam) NAME srotm(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply a modified Given's rotation. SYNOPSIS subroutine srotm(n,sx,incx,sy,incy,sparam)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: sparam(5)\n   real,intent(inout) :: sx(*),sy(*)\n   .. DEFINITION APPLY THE MODIFIED GIVENS TRANSFORMATION , H , TO THE 2 BY N MATRIX ( SX ** T ) , WHERE ** T INDICATES TRANSPOSE . THE ELEMENTS OF SX ARE IN ( SX ** T ) SX ( LX + I * INCX ) , I = 0 TO N - 1 , WHERE LX = 1 IF INCX . GE . 0 , ELSE LX = ( - INCX ) * N , AND SIMILARLY FOR SY USING USING LY AND INCY . WITH SPARAM ( 1 ) = SFLAG , H HAS ONE OF THE FOLLOWING FORMS .. SFLAG =- 1 . E0 SFLAG = 0 . E0 SFLAG = 1 . E0 SFLAG =- 2 . E0 ( SH11 SH12 ) ( 1 . E0 SH12 ) ( SH11 1 . E0 ) ( 1 . E0 0 . E0 ) H = ( ) ( ) ( ) ( ) ( SH21 SH22 ) , ( SH21 1 . E0 ) , ( - 1 . E0 SH22 ) , ( 0 . E0 1 . E0 ) . SEE SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of SY SPARAM SPARAM is REAL array, dimension (5)\n  SPARAM(1)=SFLAG\n  SPARAM(2)=SH11\n  SPARAM(3)=SH21\n  SPARAM(4)=SH12\n  SPARAM(5)=SH22 AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy real, intent(in) :: sparam (5) Contents Variables i kx ky nsteps sflag sh11 sh12 sh21 sh22 two w z zero Source Code srotm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: kx integer, public :: ky integer, public :: nsteps real, public :: sflag real, public :: sh11 real, public :: sh12 real, public :: sh21 real, public :: sh22 real, public, parameter :: two = 2.0e0 real, public :: w real, public :: z real, public, parameter :: zero = 0.0e0 Source Code subroutine srotm ( n , sx , incx , sy , incy , sparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sparam ( 5 ) real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real sflag , sh11 , sh12 , sh21 , sh22 , w , z real , parameter :: zero = 0.0e0 real , parameter :: two = 2.0e0 integer i , kx , ky , nsteps !     .. ! sflag = sparam ( 1 ) if ( n . le . 0 . or . ( sflag + two . eq . zero )) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! nsteps = n * incx if ( sflag . lt . zero ) then sh11 = sparam ( 2 ) sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) sh22 = sparam ( 5 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w * sh11 + z * sh12 sy ( i ) = w * sh21 + z * sh22 enddo elseif ( sflag . eq . zero ) then sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w + z * sh12 sy ( i ) = w * sh21 + z enddo else sh11 = sparam ( 2 ) sh22 = sparam ( 5 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w * sh11 + z sy ( i ) = - w + sh22 * z enddo endif else kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy ! if ( sflag . lt . zero ) then sh11 = sparam ( 2 ) sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) sh22 = sparam ( 5 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w * sh11 + z * sh12 sy ( ky ) = w * sh21 + z * sh22 kx = kx + incx ky = ky + incy enddo elseif ( sflag . eq . zero ) then sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w + z * sh12 sy ( ky ) = w * sh21 + z kx = kx + incx ky = ky + incy enddo else sh11 = sparam ( 2 ) sh22 = sparam ( 5 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w * sh11 + z sy ( ky ) = - w + sh22 * z kx = kx + incx ky = ky + incy enddo endif endif end subroutine srotm","tags":"","loc":"proc/srotm.html"},{"title":"srotmg – M_blas","text":"public  subroutine srotmg(sd1, sd2, sx1, sy1, sparam) NAME srotmg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate a modified Given's rotation. SYNOPSIS subroutine srotmg(sd1,sd2,sx1,sy1,sparam)\n\n   .. Scalar Arguments ..\n   real,intent(inout) :: sd1,sd2,sx1\n   real,intent(in)    :: sy1\n   ..\n   .. Array Arguments ..\n   real,intent(out)   :: sparam(5)\n   .. DEFINITION Construct the modified Givens Transformation Matrix H which zeros the second component of the 2 - vector ( sqrt ( sd1 ) * sx1 , sqrt ( sd2 ) *> sy2 ) ** t . with sparam ( 1 ) = sflag , H has one of the following forms .. SFLAG =- 1 . E0 SFLAG = 0 . E0 SFLAG = 1 . E0 SFLAG =- 2 . E0 ( SH11 SH12 ) ( 1 . E0 SH12 ) ( SH11 1 . E0 ) ( 1 . E0 0 . E0 ) H = ( ) ( ) ( ) ( ) ( SH21 SH22 ) , ( SH21 1 . E0 ) , ( - 1 . E0 SH22 ) , ( 0 . E0 1 . E0 ) . locations 2 - 4 of SPARAM contain SH11 , SH21 , SH12 , and SH22 respectively . ( values of 1 . e0 , - 1 . e0 , or 0 . e0 implied by the value of SPARAM ( 1 ) are not stored in SPARAM . ) the values of GAMSQ and RGAMSQ set in the data statement may be inexact . This is OK as they are only used for testing the size of SD1 and SD2 . All actual scaling of data is done using GAM . OPTIONS SD1 SD1 is REAL SD2 SD2 is REAL SX1 SX1 is REAL SY1 SY1 is REAL SPARAM SPARAM is REAL array, dimension (5)\n  SPARAM(1)=SFLAG\n  SPARAM(2)=SH11\n  SPARAM(3)=SH21\n  SPARAM(4)=SH12\n  SPARAM(5)=SH22 AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name real, intent(inout) :: sd1 real, intent(inout) :: sd2 real, intent(inout) :: sx1 real, intent(in) :: sy1 real, intent(out) :: sparam (5) Contents Variables gam gamsq one rgamsq sflag sh11 sh12 sh21 sh22 sp1 sp2 sq1 sq2 stemp su two zero Source Code srotmg Variables Type Visibility Attributes Name Initial real, public, parameter :: gam = 4096.e0 real, public, parameter :: gamsq = 1.67772e7 real, public, parameter :: one = 1.0e0 real, public, parameter :: rgamsq = 5.96046e-8 real, public :: sflag real, public :: sh11 real, public :: sh12 real, public :: sh21 real, public :: sh22 real, public :: sp1 real, public :: sp2 real, public :: sq1 real, public :: sq2 real, public :: stemp real, public :: su real, public, parameter :: two = 2.0e0 real, public, parameter :: zero = 0.0e0 Source Code subroutine srotmg ( sd1 , sd2 , sx1 , sy1 , sparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( inout ) :: sd1 , sd2 , sx1 real , intent ( in ) :: sy1 !     .. !     .. Array Arguments .. real , intent ( out ) :: sparam ( 5 ) !     .. !  ===================================================================== ! !     .. Local Scalars .. real sflag , sh11 , sh12 , sh21 , sh22 , sp1 , sp2 , sq1 , sq2 , stemp , su !     .. !     .. Intrinsic Functions .. intrinsic abs !     .. !     .. Data statements .. real , parameter :: zero = 0.0e0 real , parameter :: one = 1.0e0 real , parameter :: two = 2.0e0 ! real , parameter :: gam = 409 6.e0 real , parameter :: gamsq = 1.67772e7 real , parameter :: rgamsq = 5.96046e-8 !     .. if ( sd1 . lt . zero ) then !        GO ZERO-H-D-AND-SX1.. sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero else !        CASE-SD1-NONNEGATIVE sp2 = sd2 * sy1 if ( sp2 . eq . zero ) then sflag = - two sparam ( 1 ) = sflag return endif !        REGULAR-CASE.. sp1 = sd1 * sx1 sq2 = sp2 * sy1 sq1 = sp1 * sx1 ! if ( abs ( sq1 ). gt . abs ( sq2 )) then sh21 = - sy1 / sx1 sh12 = sp2 / sp1 ! su = one - sh12 * sh21 ! if ( su . gt . zero ) then sflag = zero sd1 = sd1 / su sd2 = sd2 / su sx1 = sx1 * su else !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero endif else if ( sq2 . lt . zero ) then !              GO ZERO-H-D-AND-SX1.. sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero else sflag = one sh11 = sp1 / sp2 sh22 = sx1 / sy1 su = one + sh11 * sh22 stemp = sd2 / su sd2 = sd1 / su sd1 = stemp sx1 = sy1 * su endif endif !     PROCEDURE..SCALE-CHECK if ( sd1 . ne . zero ) then do while (( sd1 . le . rgamsq ) . or . ( sd1 . ge . gamsq )) if ( sflag . eq . zero ) then sh11 = one sh22 = one sflag = - one else sh21 = - one sh12 = one sflag = - one endif if ( sd1 . le . rgamsq ) then sd1 = sd1 * gam ** 2 sx1 = sx1 / gam sh11 = sh11 / gam sh12 = sh12 / gam else sd1 = sd1 / gam ** 2 sx1 = sx1 * gam sh11 = sh11 * gam sh12 = sh12 * gam endif enddo endif if ( sd2 . ne . zero ) then do while ( ( abs ( sd2 ). le . rgamsq ) . or . ( abs ( sd2 ). ge . gamsq ) ) if ( sflag . eq . zero ) then sh11 = one sh22 = one sflag = - one else sh21 = - one sh12 = one sflag = - one endif if ( abs ( sd2 ). le . rgamsq ) then sd2 = sd2 * gam ** 2 sh21 = sh21 / gam sh22 = sh22 / gam else sd2 = sd2 / gam ** 2 sh21 = sh21 * gam sh22 = sh22 * gam endif enddo endif endif if ( sflag . lt . zero ) then sparam ( 2 ) = sh11 sparam ( 3 ) = sh21 sparam ( 4 ) = sh12 sparam ( 5 ) = sh22 elseif ( sflag . eq . zero ) then sparam ( 3 ) = sh21 sparam ( 4 ) = sh12 else sparam ( 2 ) = sh11 sparam ( 5 ) = sh22 endif sparam ( 1 ) = sflag end subroutine srotmg","tags":"","loc":"proc/srotmg.html"},{"title":"ssbmv – M_blas","text":"public  subroutine ssbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) NAME ssbmv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SY := alpha * A * SX + beta * SY , A a symmetric band matrix . SYNOPSIS subroutine ssbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: incx,incy,k,lda,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*),x(*)\n   real,intent(inout)   :: y(*)\n   .. DEFINITION SSBMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric band matrix, with k super-diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the band matrix A is being supplied as\n        follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               being supplied.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               being supplied. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry, K specifies the number of super-diagonals of the\n        matrix A. K must satisfy 0 .le. K. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer the upper triangular part of a symmetric band matrix from conventional full matrix storage to band storage : > DO 20 , J = 1 , N > M = K + 1 - J > DO 10 , I = MAX ( 1 , J - K ) , J > A ( M + I , J ) = matrix ( I , J ) > 10 CONTINUE > 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the symmetric matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a symmetric band matrix from conventional full matrix storage to band storage : > DO 20 , J = 1 , N > M = 1 - J > DO 10 , I = J , MIN ( N , J + K ) > A ( M + I , J ) = matrix ( I , J ) > 10 CONTINUE > 20 CONTINUE LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is REAL\n        On entry, BETA specifies the scalar beta. Y Y is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kplus1 kx ky l one temp1 temp2 zero Source Code ssbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kplus1 integer, public :: kx integer, public :: ky integer, public :: l real, public, parameter :: one = 1.0e+0 real, public :: temp1 real, public :: temp2 real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'SSBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( kplus1 , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( kplus1 , j ) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( 1 , j ) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( 1 , j ) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssbmv","tags":"","loc":"proc/ssbmv.html"},{"title":"sscal – M_blas","text":"public  subroutine sscal(n, sa, sx, incx) NAME sscal ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL1 ] SX := SA * SX . SYNOPSIS subroutine sscal(n,sa,sx,incx)\n\n   .. Scalar Arguments ..\n   real,intent(in)    :: sa\n   integer,intent(in) :: incx,n\n   ..\n   .. Array Arguments ..\n   real,intent(inout) :: sx(*)\n   .. DEFINITION SSCAL scales a vector by a constant . uses unrolled loops for increment equal to 1. OPTIONS N N is INTEGER\n      number of elements in input vector(s) SA SA is REAL\n        On entry, SA specifies the scalar alpha. SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , linpack , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa real, intent(inout) :: sx (*) integer, intent(in) :: incx Contents Variables i m mp1 nincx Source Code sscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: m integer, public :: mp1 integer, public :: nincx Source Code subroutine sscal ( n , sa , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m sx ( i ) = sa * sx ( i ) enddo if ( n . lt . 5 ) return endif mp1 = m + 1 do i = mp1 , n , 5 sx ( i ) = sa * sx ( i ) sx ( i + 1 ) = sa * sx ( i + 1 ) sx ( i + 2 ) = sa * sx ( i + 2 ) sx ( i + 3 ) = sa * sx ( i + 3 ) sx ( i + 4 ) = sa * sx ( i + 4 ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx sx ( i ) = sa * sx ( i ) enddo endif end subroutine sscal","tags":"","loc":"proc/sscal.html"},{"title":"sspmv – M_blas","text":"public  subroutine sspmv(uplo, n, alpha, ap, x, incx, beta, y, incy) NAME sspmv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SY := alpha * A * SX + beta * SY , A a packed symmetric matrix . SYNOPSIS subroutine sspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: incx,incy,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: ap(*),x(*)\n   real,intent(inout)   :: y(*)\n   .. DEFINITION SSPMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. AP AP is REAL array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular part of the symmetric matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n        and a( 2, 2 ) respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular part of the symmetric matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n        and a( 3, 1 ) respectively, and so on. X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: ap (*) real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kk kx ky one temp1 temp2 zero Source Code sspmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky real, public, parameter :: one = 1.0e+0 real, public :: temp1 real, public :: temp2 real, public, parameter :: zero = 0.0e+0 Source Code subroutine sspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SSPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * ap ( kk ) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * ap ( kk ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif end subroutine sspmv","tags":"","loc":"proc/sspmv.html"},{"title":"sspr – M_blas","text":"public  subroutine sspr(uplo, n, alpha, x, incx, ap) NAME sspr ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] A := A + alpha * SX * TRANSPOSE ( SX ), A a packed symmetric matrix . SYNOPSIS subroutine sspr(uplo,n,alpha,x,incx,ap)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: incx,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: x(*)\n   real,intent(inout) :: ap(*)\n   .. DEFINITION SSPR performs the symmetric rank 1 operation A := alpha * x * x ** T + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AP AP is REAL array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(inout) :: ap (*) Contents Variables i info ix j jx k kk kx temp zero Source Code sspr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine sspr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ) real , intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'SSPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif end subroutine sspr","tags":"","loc":"proc/sspr.html"},{"title":"sspr2 – M_blas","text":"public  subroutine sspr2(uplo, n, alpha, x, incx, y, incy, ap) NAME sspr2 ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] A := A + alpha * SX * TRANSPOSE ( SY ) + alpha * SY * TRANSPOSE ( SX ), A packed symmetric . SYNOPSIS subroutine sspr2(uplo,n,alpha,x,incx,y,incy,ap)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: incx,incy,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: x(*),y(*)\n   real,intent(inout)   :: ap(*)\n   .. DEFINITION SSPR2 performs the symmetric rank 2 operation A := alpha * x * y ** T + alpha * y * x ** T + A , where alpha is a scalar, x and y are n element vectors and A is an\n  n by n symmetric matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AP AP is REAL array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the symmetric matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: ap (*) Contents Variables i info ix iy j jx jy k kk kx ky temp1 temp2 zero Source Code sspr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky real, public :: temp1 real, public :: temp2 real, public, parameter :: zero = 0.0e+0 Source Code subroutine sspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'SSPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif end subroutine sspr2","tags":"","loc":"proc/sspr2.html"},{"title":"sswap – M_blas","text":"public  subroutine sswap(n, sx, incx, sy, incy) NAME sswap(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Interchange vectors SX and SY. SYNOPSIS subroutine sswap(n,sx,incx,sy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in) :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   real,intent(inout) :: sx(*),sy(*)\n   .. DEFINITION SSWAP interchanges two vectors . uses unrolled loops for increments equal to 1 . OPTIONS N N is INTEGER\n      number of elements in input vector(s) SX SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of SX SY SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of SY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy Contents Variables i ix iy m mp1 stemp Source Code sswap Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy integer, public :: m integer, public :: mp1 real, public :: stemp Source Code subroutine sswap ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! ! !       clean-up loop ! m = mod ( n , 3 ) if ( m . ne . 0 ) then do i = 1 , m stemp = sx ( i ) sx ( i ) = sy ( i ) sy ( i ) = stemp enddo if ( n . lt . 3 ) return endif mp1 = m + 1 do i = mp1 , n , 3 stemp = sx ( i ) sx ( i ) = sy ( i ) sy ( i ) = stemp stemp = sx ( i + 1 ) sx ( i + 1 ) = sy ( i + 1 ) sy ( i + 1 ) = stemp stemp = sx ( i + 2 ) sx ( i + 2 ) = sy ( i + 2 ) sy ( i + 2 ) = stemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = sx ( ix ) sx ( ix ) = sy ( iy ) sy ( iy ) = stemp ix = ix + incx iy = iy + incy enddo endif end subroutine sswap","tags":"","loc":"proc/sswap.html"},{"title":"ssymm – M_blas","text":"public  subroutine ssymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME ssymm ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL3 ] C := alpha * A * B + beta * C , A symmetric , B , C rectangular . SYNOPSIS subroutine ssymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: lda,ldb,ldc,m,n\n   character,intent(in) :: side,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*),b(ldb,*)\n   real,intent(inout)   :: c(ldc,*)\n   .. DEFINITION SSYMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is a symmetric matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the symmetric matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the symmetric matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               symmetric matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               symmetric matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is REAL array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is REAL array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code ssymm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: temp1 real, public :: temp2 logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. real , parameter :: one = 1.0e+0 , zero = 0.0e+0 !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'SSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = temp1 * b ( i , j ) enddo else do i = 1 , m c ( i , j ) = beta * c ( i , j ) + temp1 * b ( i , j ) enddo endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif do i = 1 , m c ( i , j ) = c ( i , j ) + temp1 * b ( i , k ) enddo enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif do i = 1 , m c ( i , j ) = c ( i , j ) + temp1 * b ( i , k ) enddo enddo enddo endif end subroutine ssymm","tags":"","loc":"proc/ssymm.html"},{"title":"ssymv – M_blas","text":"public  subroutine ssymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) NAME ssymv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SY := alpha * A * SX + beta * SY , A a symmetric matrix . SYNOPSIS subroutine ssymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: incx,incy,lda,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*),x(*)\n   real,intent(inout)   :: y(*)\n   .. DEFINITION SSYMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular part of the symmetric matrix and the strictly\n        lower triangular part of A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular part of the symmetric matrix and the strictly\n        upper triangular part of A is not referenced. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is REAL On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky one temp1 temp2 zero Source Code ssymv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky real, public, parameter :: one = 1.0e+0 real, public :: temp1 real, public :: temp2 real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'SSYMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( j , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( j , j ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( j , j ) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( j , j ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssymv","tags":"","loc":"proc/ssymv.html"},{"title":"ssyr – M_blas","text":"public  subroutine ssyr(uplo, n, alpha, x, incx, a, lda) NAME ssyr ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] A := A + alpha * SX * TRANSPOSE ( SX ), A a symmetric matrix . SYNOPSIS subroutine ssyr(uplo,n,alpha,x,incx,a,lda)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: incx,lda,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: x(*)\n   real,intent(inout)   :: a(lda,*)\n   .. DEFINITION SSYR performs the symmetric rank 1 operation A := alpha * x * x ** T + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . A A is REAL array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jx kx temp zero Source Code ssyr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssyr ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( 1 : j , j ) = a ( 1 : j , j ) + x ( 1 : j ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( j : n , j ) = a ( j : n , j ) + x ( j : n ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif endif end subroutine ssyr","tags":"","loc":"proc/ssyr.html"},{"title":"ssyr2 – M_blas","text":"public  subroutine ssyr2(uplo, n, alpha, x, incx, y, incy, a, lda) NAME ssyr2 ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] A := A + alpha * SX * TRANSPOSE ( SY ) + alpha * SY * TRANSPOSE ( SX ), A a symmetric SYNOPSIS subroutine ssyr2(uplo,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: incx,incy,lda,n\n   character,intent(in) :: uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: x(*),y(*)\n   real,intent(inout)   :: a(lda,*)\n   .. DEFINITION SSYR2 performs the symmetric rank 2 operation A := alpha * x * y ** T + alpha * y * x ** T + A , where alpha is a scalar, x and y are n element vectors and A is an n\n  by n symmetric matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. X X is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is REAL array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is REAL array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix iy j jx jy kx ky temp1 temp2 zero Source Code ssyr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky real, public :: temp1 real, public :: temp2 real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = 1 , j a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = j , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssyr2","tags":"","loc":"proc/ssyr2.html"},{"title":"ssyr2k – M_blas","text":"public  subroutine ssyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME ssyr2k ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL3 ] C := alpha * A * TRANSPOSE ( B ) + alpha * B * TRANSPOSE ( A ) + beta * C , C symmetric . SYNOPSIS subroutine ssyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: k,lda,ldb,ldc,n\n   character,intent(in) :: trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*),b(ldb,*)\n   real,intent(inout)   :: c(ldc,*)\n   .. DEFINITION SSYR2K performs one of the symmetric rank 2k operations C := alpha * A * B ** T + alpha * B * A ** T + beta * C , or C := alpha * A ** T * B + alpha * B ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A and B are n by k matrices in the first case and k by n\n  matrices in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'T' or 't' or 'C' or 'c', K specifies the number\n        of rows of the matrices A and B. K must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is REAL array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . BETA BETA is REAL\n        On entry, BETA specifies the scalar beta. C C is REAL array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code ssyr2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: temp1 real, public :: temp2 logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + a ( j : n , l ) * temp1 + b ( j : n , l ) * temp2 endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif end subroutine ssyr2k","tags":"","loc":"proc/ssyr2k.html"},{"title":"ssyrk – M_blas","text":"public  subroutine ssyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME ssyrk ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL3 ] C := alpha * A * TRANSPOSE ( A ) + beta * C , C symmetric . SYNOPSIS subroutine ssyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha,beta\n   integer,intent(in)   :: k,lda,ldc,n\n   character,intent(in) :: trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*)\n   real,intent(inout)   :: c(ldc,*)\n   .. DEFINITION SSYRK performs one of the symmetric rank k operations C := alpha * A * A ** T + beta * C , or C := alpha * A ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A is an n by k matrix in the first case and a k by n matrix\n  in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns  of the  matrix A, and on entry with\n        TRANS = 'T' or 't' or 'C' or 'c', K specifies the number\n        of rows of the matrix A. K must be at least zero. ALPHA ALPHA is REAL\n        On entry, ALPHA specifies the scalar alpha. A A is REAL array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is REAL\n        On entry, BETA specifies the scalar beta. C C is REAL array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp upper zero Source Code ssyrk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: temp logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine ssyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'SSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine ssyrk","tags":"","loc":"proc/ssyrk.html"},{"title":"stbmv – M_blas","text":"public  subroutine stbmv(uplo, trans, diag, n, k, a, lda, x, incx) NAME stbmv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := A * SX , A a triangular band matrix . SYNOPSIS subroutine stbmv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,k,lda,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*)\n   real,intent(inout)   :: x(*)\n   .. DEFINITION STBMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular band matrix, with ( k + 1 ) diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is REAL array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l nounit temp zero Source Code stbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine stbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'STBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine stbmv","tags":"","loc":"proc/stbmv.html"},{"title":"stbsv – M_blas","text":"public  subroutine stbsv(uplo, trans, diag, n, k, a, lda, x, incx) NAME stbsv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := INVERSE ( A ) * SX , A a triangular band matrix . SYNOPSIS subroutine stbsv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,k,lda,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*)\n   real,intent(inout)   :: x(*)\n   .. DEFINITION STBSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular band matrix, with ( k + 1 )\n  diagonals. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is REAL array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l nounit temp zero Source Code stbsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine stbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'STBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T)*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif end subroutine stbsv","tags":"","loc":"proc/stbsv.html"},{"title":"stpmv – M_blas","text":"public  subroutine stpmv(uplo, trans, diag, n, ap, x, incx) NAME stpmv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := A * SX , A a packed symmetric matrix . SYNOPSIS subroutine stpmv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: ap(*)\n   real,intent(inout)   :: x(*)\n   .. DEFINITION STPMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is REAL array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: ap (*) real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx nounit temp zero Source Code stpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine stpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real , parameter :: zero = 0.0e+0 !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'STPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk - 1 do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk + 1 do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif end subroutine stpmv","tags":"","loc":"proc/stpmv.html"},{"title":"stpsv – M_blas","text":"public  subroutine stpsv(uplo, trans, diag, n, ap, x, incx) NAME stpsv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := INVERSE ( A ) * SX , A a packed symmetric matrix . SYNOPSIS subroutine stpsv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: ap(*)\n   real,intent(inout)   :: x(*)\n   .. DEFINITION STPSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is REAL array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: ap (*) real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx nounit temp zero Source Code stpsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine stpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'STPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif end subroutine stpsv","tags":"","loc":"proc/stpsv.html"},{"title":"strmm – M_blas","text":"public  subroutine strmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME strmm ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL3 ] B := A * B or B := B * A , A triangular , B rectangular . SYNOPSIS subroutine strmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: lda,ldb,m,n\n   character,intent(in) :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*)\n   real,intent(inout)   :: b(ldb,*)\n   .. DEFINITION STRMM performs one of the matrix-matrix operations B := alpha * op ( A ) * B , or B := alpha * B * op ( A ), where alpha is a scalar, B is an m by n matrix, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether op ( A ) multiplies B from the left or right as follows : SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**T. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is REAL On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is REAL array, dimension ( LDA, k ), where k is m\n        when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is REAL array , dimension ( LDB , N ) Before entry , the leading m by n part of the array B must contain the matrix B , and on exit is overwritten by the transformed matrix . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside nounit nrowa one temp upper zero Source Code strmm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: nounit integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: temp logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine strmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'STRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif end subroutine strmm","tags":"","loc":"proc/strmm.html"},{"title":"strmv – M_blas","text":"public  subroutine strmv(uplo, trans, diag, n, a, lda, x, incx) NAME strmv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := A * SX , A a triangular matrix . SYNOPSIS subroutine strmv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,lda,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: a(lda,*)\n   real,intent(inout) :: x(*)\n   .. DEFINITION STRMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , where x is an n element vector and  A is an n by n unit, or non-unit,\n  upper or lower triangular matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** T * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is REAL array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx nounit temp zero Source Code strmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine strmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real , parameter :: zero = 0.0e+0 !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'STRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) x ( 1 : j - 1 ) = x ( 1 : j - 1 ) + temp * a ( 1 : j - 1 , j ) if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine strmv","tags":"","loc":"proc/strmv.html"},{"title":"strsm – M_blas","text":"public  subroutine strsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME strsm ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL3 ] B := INVERSE ( A ) * C or B := C * INVERSE ( A ), B , C rectangular , A triangular . SYNOPSIS subroutine strsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   real,intent(in)      :: alpha\n   integer,intent(in)   :: lda,ldb,m,n\n   character,intent(in) :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)    :: a(lda,*)\n   real,intent(inout) :: b(ldb,*)\n   .. DEFINITION STRSM solves one of the matrix equations op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T. The matrix X is overwritten on B. OPTIONS SIDE SIDE is CHARACTER*1\n        On entry, SIDE specifies whether op( A ) appears on the left\n        or right of X as follows:\n\n           SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n           SIDE = 'R' or 'r'   X*op( A ) = alpha*B. UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**T. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is REAL On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is REAL array, dimension ( LDA, k ),\n        where k is m when SIDE = 'L' or 'l'\n          and k is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is REAL array , dimension ( LDB , N ) Before entry , the leading m by n part of the array B must contain the right - hand side matrix B , and on exit is overwritten by the solution matrix X . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside nounit nrowa one temp upper zero Source Code strsm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: nounit integer, public :: nrowa real, public, parameter :: one = 1.0e+0 real, public :: temp logical, public :: upper real, public, parameter :: zero = 0.0e+0 Source Code subroutine strsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'STRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n b ( 1 : m , j ) = zero enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif end subroutine strsm","tags":"","loc":"proc/strsm.html"},{"title":"strsv – M_blas","text":"public  subroutine strsv(uplo, trans, diag, n, a, lda, x, incx) NAME strsv ( 3 f ) - [ BLAS : SINGLE_BLAS_LEVEL2 ] SX := INVERSE ( A ) * SX , A a triangular matrix . SYNOPSIS subroutine strsv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)   :: incx,lda,n\n   character,intent(in) :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   real,intent(in)      :: a(lda,*)\n   real,intent(inout)   :: x(*)\n   .. DEFINITION STRSV solves one of the systems of equations A*x = b,   or   A**T*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**T*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is REAL array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is REAL array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx nounit temp zero Source Code strsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: nounit real, public :: temp real, public, parameter :: zero = 0.0e+0 Source Code subroutine strsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'STRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine strsv","tags":"","loc":"proc/strsv.html"},{"title":"xerbla_array – M_blas","text":"public  subroutine xerbla_array(srname_array, srname_len, info) NAME xerbla_array(3f) - [BLAS:AUX_BLAS] call XERBLA(3f) with an array of characters instead of a string SYNOPSIS subroutine xerbla_array(srname_array, srname_len, info)\n\n    .. Scalar Arguments ..\n    integer srname_len, info\n    ..\n    .. Array Arguments ..\n    character(*) srname_array(srname_len)\n    .. DEFINITION XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK\n  and BLAS error handler. Rather than taking a Fortran string argument\n  as the function’s name, XERBLA_ARRAY takes an array of single\n  characters along with the array’s length. XERBLA_ARRAY then copies\n  up to 32 characters of that array into a Fortran string and passes\n  that to XERBLA. If called with a non-positive SRNAME_LEN,\n  XERBLA_ARRAY will call XERBLA with a string of all blank characters. Say some macro or other device makes XERBLA_ARRAY available to C99\n  by a name lapack_xerbla and with a common Fortran calling convention.\n  Then a C99 program could invoke XERBLA via:\n     {\n       int flen = strlen( func );\n       lapack_xerbla( func , &flen, &info);\n     } Providing XERBLA_ARRAY is not necessary for intercepting LAPACK\n  errors. XERBLA_ARRAY calls XERBLA. OPTIONS SRNAME_ARRAY SRNAME_ARRAY is CHARACTER(*) array, dimension (SRNAME_LEN)\n       The name of the routine which called XERBLA_ARRAY. SRNAME_LEN SRNAME_LEN is INTEGER\n       The length of the name in SRNAME_ARRAY. INFO INFO is INTEGER\n       The position of the invalid parameter in the parameter list\n       of the calling routine. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname_array (srname_len) integer, intent(in) :: srname_len integer, intent(in) :: info Contents Variables i srname Source Code xerbla_array Variables Type Visibility Attributes Name Initial integer, public :: i character(len=32), public :: srname Source Code subroutine xerbla_array ( srname_array , srname_len , info ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: srname_len , info !     .. !     .. Array Arguments .. character ( len =* ), intent ( in ) :: srname_array ( srname_len ) !     .. ! ! ===================================================================== ! !     .. !     .. Local Scalars .. integer i !     .. !     .. Local Arrays .. character * 32 srname !     .. !     .. Intrinsic Functions .. intrinsic min , len !     .. !     .. External Functions .. !      EXTERNAL XERBLA !     .. !     .. Executable Statements .. srname = '' do i = 1 , min ( srname_len , len ( srname ) ) srname ( i : i ) = srname_array ( i ) enddo call xerbla ( srname , info ) end subroutine xerbla_array","tags":"","loc":"proc/xerbla_array.html"},{"title":"zaxpy – M_blas","text":"public  subroutine zaxpy(n, za, zx, incx, zy, incy) NAME zaxpy ( 3 f ) - [ BLAS : COMPLEX16_BLAS_LEVEL1 ] ZY : = ZY + ZA * ZX complex constant times a complex vector plus a complex vector . SYNOPSIS subroutine zaxpy(n,za,zx,incx,zy,incy)\n\n   ! .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: za\n   integer,intent(in)                 :: incx,incy,n\n   ! ..\n   ! .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: zx(*)\n   complex(kind=real64),intent(inout) :: zy(*)\n   ! .. DEFINITION ZAXPY constant times a vector plus a vector . ZY : = ZY + ZA * ZX OPTIONS N      number of elements in input vector(s)\n   ZA     On entry, ZA specifies the scalar alpha.\n   ZX     ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX   storage spacing between elements of ZX\n   ZY     ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY   storage spacing between elements of ZY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy Contents Variables i ix iy Source Code zaxpy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine zaxpy ( n , za , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: za integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) complex ( kind = real64 ), intent ( inout ) :: zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy !     .. !     .. External Functions .. !      double precision dcabs1 !      external dcabs1 !     .. if ( n . le . 0 ) return if ( dcabs1 ( za ). eq . 0.0d0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n zy ( i ) = zy ( i ) + za * zx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n zy ( iy ) = zy ( iy ) + za * zx ( ix ) ix = ix + incx iy = iy + incy enddo endif ! end subroutine zaxpy","tags":"","loc":"proc/zaxpy.html"},{"title":"zcopy – M_blas","text":"public  subroutine zcopy(n, zx, incx, zy, incy) NAME zcopy(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS subroutine zcopy(n,zx,incx,zy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in)               :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)  :: ZX(*)\n   complex(kind=real64),intent(out) :: ZY(*)\n   .. DEFINITION ZCOPY copies a vector, x, to a vector, y. OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX ZY ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of ZY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, linpack, 4/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(out) :: zy (*) integer, intent(in) :: incy Contents Variables i ix iy Source Code zcopy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy Source Code subroutine zcopy ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) complex ( kind = real64 ), intent ( out ) :: zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n zy ( i ) = zx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n zy ( iy ) = zx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine zcopy","tags":"","loc":"proc/zcopy.html"},{"title":"zdrot – M_blas","text":"public  subroutine zdrot(n, zx, incx, zy, incy, c, s) NAME zdrot(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS subroutine zdrot( n, zx, incx, zy, incy, c, s )\n\n   .. Scalar Arguments ..\n   integer,intent(in)          :: incx, incy, n\n   double precision,intent(in) :: c, s\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(inout) :: zx( * ), zy( * )\n   .. DEFINITION Applies a plane rotation, where the cos and sin (c and s) are real\n  and the vectors cx and cy are complex.\n  jack dongarra, linpack, 3/11/78. OPTIONS N N is INTEGER\n        On entry, N specifies the order of the vectors cx and cy.\n        N must be at least zero. ZX ZX is complex ( kind = real64 ) array , dimension at least ( 1 + ( N - 1 ) * abs ( INCX ) ) . Before entry , the incremented array ZX must contain the n element vector cx . On exit , ZX is overwritten by the updated vector cx . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of ZX . INCX must not be zero . ZY ZY is complex ( kind = real64 ) array , dimension at least ( 1 + ( N - 1 ) * abs ( INCY ) ) . Before entry , the incremented array ZY must contain the n element vector cy . On exit , ZY is overwritten by the updated vector cy . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of ZY . INCY must not be zero . C C is DOUBLE PRECISION\n        On entry, C specifies the cosine, cos. S S is DOUBLE PRECISION\n        On entry, S specifies the sine, sin. AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy double precision, intent(in) :: c double precision, intent(in) :: s Contents Variables ctemp i ix iy Variables Type Visibility Attributes Name Initial complex(kind=real64), public :: ctemp integer, public :: i integer, public :: ix integer, public :: iy","tags":"","loc":"proc/zdrot.html"},{"title":"zdscal – M_blas","text":"public  subroutine zdscal(n, da, zx, incx) NAME zdscal(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS subroutine zdscal(n,da,zx,incx)\n\n   .. Scalar Arguments ..\n   double precision,intent(in) :: da\n   integer,intent(in) :: incx,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(inout) :: zx(*)\n   .. DEFINITION ZDSCAL scales a vector by a constant . OPTIONS N N is INTEGER\n      number of elements in input vector(s) DA DA is DOUBLE PRECISION\n        On entry, DA specifies the scalar alpha. ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx Contents Variables i nincx Source Code zdscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx Source Code subroutine zdscal ( n , da , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic dcmplx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n zx ( i ) = dcmplx ( da , 0.0d0 ) * zx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx zx ( i ) = dcmplx ( da , 0.0d0 ) * zx ( i ) enddo endif end subroutine zdscal","tags":"","loc":"proc/zdscal.html"},{"title":"zgbmv – M_blas","text":"public  subroutine zgbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) NAME zgbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: incx,incy,kl,ku,lda,m,n\n   character,intent(in)               :: trans\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),x(*)\n   complex(kind=real64),intent(inout) :: y(*)\n   .. DEFINITION ZGBMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , or y := alpha * A ** H * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n band matrix, with kl sub-diagonals and ku super-diagonals. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. KL KL is INTEGER\n        On entry, KL specifies the number of sub-diagonals of the\n        matrix A. KL must satisfy 0 .le. KL. KU KU is INTEGER\n        On entry, KU specifies the number of super-diagonals of the\n        matrix A. KU must satisfy 0 .le. KU. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry , the leading ( kl + ku + 1 ) by n part of the array A must contain the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( ku + 1 ) of the array , the first super - diagonal starting at position 2 in row ku , the first sub - diagonal starting at position 1 in row ( ku + 2 ) , and so on . Elements in the array A that do not correspond to elements in the band matrix ( such as the top left ku by ku triangle ) are not referenced . The following program segment will transfer a band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N K = KU + 1 - J DO 10 , I = MAX ( 1 , J - KU ) , MIN ( M , J + KL ) A ( K + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( kl + ku + 1 ). X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is complex ( kind = real64 ) array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kup1 kx ky lenx leny noconj one temp zero Source Code zgbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kup1 integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny logical, public :: noconj complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'ZGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + dconjg ( a ( k + i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + dconjg ( a ( k + i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif ! end subroutine zgbmv","tags":"","loc":"proc/zgbmv.html"},{"title":"zgemm – M_blas","text":"public  subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME zgemm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: k,lda,ldb,ldc,m,n\n   character,intent(in)               :: transa,transb\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZGEMM performs one of the matrix-matrix operations C := alpha * op ( A ) * op ( B ) + beta * C , where op( X ) is one of op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, alpha and beta are scalars, and A, B and C are matrices, with op( A )\n  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. OPTIONS TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n',  op( A ) = A.\n\n           TRANSA = 'T' or 't',  op( A ) = A**T.\n\n           TRANSA = 'C' or 'c',  op( A ) = A**H. TRANSB TRANSB is CHARACTER*1\n        On entry, TRANSB specifies the form of op( B ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSB = 'N' or 'n',  op( B ) = B.\n\n           TRANSB = 'T' or 't',  op( B ) = B**T.\n\n           TRANSB = 'C' or 'c',  op( B ) = B**H. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix\n        op( A ) and of the matrix C. M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix\n        op( B ) and the number of columns of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry, K specifies the number of columns of the matrix\n        op( A ) and the number of rows of the matrix op( B ). K must\n        be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        k when TRANSA = 'N' or 'n', and is m otherwise.\n        Before entry with TRANSA = 'N' or 'n', the leading m by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by m part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANSA = ' N ' or ' n ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , k ) . B B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is\n        n when TRANSB = 'N' or 'n', and is k otherwise.\n        Before entry with TRANSB = 'N' or 'n', the leading k by n\n        part of the array B must contain the matrix B, otherwise\n        the leading n by k part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANSB = ' N ' or ' n ' then LDB must be at least max ( 1 , k ) , otherwise LDB must be at least max ( 1 , n ) . BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n matrix ( alpha * op ( A ) * op ( B ) + beta * C ) . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables conja conjb i info j l nota notb nrowa nrowb one temp zero Source Code zgemm Variables Type Visibility Attributes Name Initial logical, public :: conja logical, public :: conjb integer, public :: i integer, public :: info integer, public :: j integer, public :: l logical, public :: nota logical, public :: notb integer, public :: nrowa integer, public :: nrowb complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , l , nrowa , nrowb logical conja , conjb , nota , notb !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and NROWB  as the number of rows  of  A  and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) conja = lsame ( transa , 'C' ) conjb = lsame ( transb , 'C' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . conja ) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . conjb ) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'ZGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo elseif ( conja ) then ! !           Form  C := alpha*A**H*B + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif elseif ( nota ) then if ( conjb ) then ! !           Form  C := alpha*A*B**H + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * dconjg ( b ( j , l )) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( j , l ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo endif elseif ( conja ) then if ( conjb ) then ! !           Form  C := alpha*A**H*B**H + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * dconjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**H*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( conjb ) then ! !           Form  C := alpha*A**T*B**H + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * dconjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine zgemm","tags":"","loc":"proc/zgemm.html"},{"title":"zgemv – M_blas","text":"public  subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) NAME zgemv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: incx,incy,lda,m,n\n   character,intent(in)               :: trans\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),x(*)\n   complex(kind=real64),intent(inout) :: y(*)\n   .. DEFINITION ZGEMV performs one of the matrix-vector operations y := alpha * A * x + beta * y , or y := alpha * A ** T * x + beta * y , or y := alpha * A ** H * x + beta * y , where alpha and beta are scalars, x and y are vectors and A is an\n  m by n matrix. OPTIONS TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' y := alpha * A * x + beta * y . TRANS = ' T ' or ' t ' y := alpha * A ** T * x + beta * y . TRANS = ' C ' or ' c ' y := alpha * A ** H * x + beta * y . M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, N )\n        Before entry, the leading m by n part of the array A must\n        contain the matrix of coefficients. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n        and at least\n        ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is complex ( kind = real64 ) array , dimension at least ( 1 + ( m - 1 ) * abs ( INCY ) ) when TRANS = ' N ' or ' n ' and at least ( 1 + ( n - 1 ) * abs ( INCY ) ) otherwise . Before entry with BETA non - zero , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky lenx leny noconj one temp zero Source Code zgemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky integer, public :: lenx integer, public :: leny logical, public :: noconj complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then do i = 1 , leny y ( i ) = zero enddo else do i = 1 , leny y ( i ) = beta * y ( i ) enddo endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo else do i = 1 , m temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo else do i = 1 , m temp = temp + dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! end subroutine zgemv","tags":"","loc":"proc/zgemv.html"},{"title":"zgerc – M_blas","text":"public  subroutine zgerc(m, n, alpha, x, incx, y, incy, a, lda) NAME zgerc(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zgerc(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*),y(*)\n   complex(kind=real64),intent(inout) :: a(lda,*)\n   .. DEFINITION ZGERC performs the rank 1 operation A := alpha * x * y ** H + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M M is INTEGER\n        On entry, M specifies the number of rows of the matrix A.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( m - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the m\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code zgerc Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zgerc ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZGERC ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * dconjg ( y ( jy )) a ( 1 : m , j ) = a ( 1 : m , j ) + x ( 1 : m ) * temp endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * dconjg ( y ( jy )) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine zgerc","tags":"","loc":"proc/zgerc.html"},{"title":"zgeru – M_blas","text":"public  subroutine zgeru(m, n, alpha, x, incx, y, incy, a, lda) NAME zgeru(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zgeru(m,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: incx,incy,lda,m,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*),y(*)\n   complex(kind=real64),intent(inout) :: a(lda,*)\n   .. DEFINITION ZGERU performs the rank 1 operation A := alpha * x * y ** T + A , where alpha is a scalar, x is an m element vector, y is an n element\n  vector and A is an m by n matrix. OPTIONS M On entry , M specifies the number of rows of the matrix A . M must be at least zero . N On entry , N specifies the number of columns of the matrix A . N must be at least zero . ALPHA On entry , ALPHA specifies the scalar alpha . X array , dimension at least ( 1 + ( m - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the m element vector x . INCX On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . INCY On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A array , dimension ( LDA , N ) Before entry , the leading m by n part of the array A must contain the matrix of coefficients . On exit , A is overwritten by the updated matrix . LDA On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . LDA must be at least max ( 1 , m ) . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jy kx temp zero Source Code zgeru Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jy integer, public :: kx complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zgeru ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZGERU ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine zgeru","tags":"","loc":"proc/zgeru.html"},{"title":"zhbmv – M_blas","text":"public  subroutine zhbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) NAME zhbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zhbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: incx,incy,k,lda,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),x(*)\n   complex(kind=real64),intent(inout) :: y(*)\n   .. DEFINITION ZHBMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian band matrix, with k super-diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the band matrix A is being supplied as\n        follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               being supplied.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               being supplied. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry, K specifies the number of super-diagonals of the\n        matrix A. K must satisfy 0 .le. K. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer the upper triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the hermitian matrix , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer the lower triangular part of a hermitian band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that the imaginary parts of the diagonal elements need not be set and are assumed to be zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the\n        vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is complex(kind=real64)\n        On entry, BETA specifies the scalar beta. Y Y is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kplus1 kx ky l one temp1 temp2 zero Source Code zhbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kplus1 integer, public :: kx integer, public :: ky integer, public :: l complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZHBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * dble ( a ( kplus1 , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( a ( kplus1 , j )) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( a ( 1 , j )) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( a ( 1 , j )) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine zhbmv","tags":"","loc":"proc/zhbmv.html"},{"title":"zhemm – M_blas","text":"public  subroutine zhemm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME zhemm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zhemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: lda,ldb,ldc,m,n\n   character,intent(in)               :: side,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZHEMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is an hermitian matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the hermitian matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the hermitian matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               hermitian matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               hermitian matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the hermitian matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the hermitian matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the hermitian\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the hermitian matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the hermitian matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the hermitian\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Note that the imaginary parts of the diagonal elements need\n        not be set, they are assumed to be zero. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is complex(kind=real64) array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code zhemm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZHEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * dconjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * dble ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * dble ( a ( i , i )) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * dconjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * dble ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * dble ( a ( i , i )) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * dble ( a ( j , j )) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * dconjg ( a ( j , k )) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * dconjg ( a ( j , k )) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif end subroutine zhemm","tags":"","loc":"proc/zhemm.html"},{"title":"zhemv – M_blas","text":"public  subroutine zhemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy) NAME zhemv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zhemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: incx,incy,lda,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),x(*)\n   complex(kind=real64),intent(inout) :: y(*)\n   .. DEFINITION ZHEMV performs the matrix-vector  operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, N )\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular part of the hermitian matrix and the strictly\n        lower triangular part of A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular part of the hermitian matrix and the strictly\n        upper triangular part of A is not referenced.\n        Note that the imaginary parts of the diagonal elements need\n        not be set and are assumed to be zero. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy kx ky one temp1 temp2 zero Source Code zhemv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !      logical lsame !      external lsame !     .. !     .. External Subroutines .. !      external xerbla !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZHEMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * dble ( a ( j , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( a ( j , j )) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( a ( j , j )) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( a ( j , j )) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine zhemv","tags":"","loc":"proc/zhemv.html"},{"title":"zher – M_blas","text":"public  subroutine zher(uplo, n, alpha, x, incx, a, lda) NAME zher(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zher(uplo,n,alpha,x,incx,a,lda)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)        :: alpha\n   integer ,intent(in)                :: incx,lda,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*)\n   complex(kind=real64),intent(inout) :: a(lda,*)\n   .. DEFINITION ZHER performs the hermitian rank 1 operation A := alpha * x * x ** H + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix j jx kx temp zero Source Code zher Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zher ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . dble ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp ) else a ( j , j ) = dble ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ix = kx do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp ) else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) a ( j , j ) = dble ( a ( j , j )) + dble ( temp * x ( j )) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo else a ( j , j ) = dble ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) a ( j , j ) = dble ( a ( j , j )) + dble ( temp * x ( jx )) ix = jx do i = j + 1 , n ix = ix + incx a ( i , j ) = a ( i , j ) + x ( ix ) * temp enddo else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx enddo endif endif end subroutine zher","tags":"","loc":"proc/zher.html"},{"title":"zher2 – M_blas","text":"public  subroutine zher2(uplo, n, alpha, x, incx, y, incy, a, lda) NAME zher2(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zher2(uplo,n,alpha,x,incx,y,incy,a,lda)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: incx,incy,lda,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*),y(*)\n   complex(kind=real64),intent(inout) :: a(lda,*)\n   .. DEFINITION ZHER2 performs the hermitian rank 2 operation A := alpha * x * y ** H + conjg ( alpha ) * y * x ** H + A , where alpha is a scalar, x and y are n element vectors and A is an n\n  by n hermitian matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array A is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of A\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of A\n                               is to be referenced. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array A must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of A is not referenced . On exit , the upper triangular part of the array A is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array A must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of A is not referenced . On exit , the lower triangular part of the array A is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda Contents Variables i info ix iy j jx jy kx ky temp1 temp2 zero Source Code zher2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: kx integer, public :: ky complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) a ( 1 : j - 1 , j ) = a ( 1 : j - 1 , j ) + x ( 1 : j - 1 ) * temp1 + y ( 1 : j - 1 ) * temp2 a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) else a ( j , j ) = dble ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ix = kx iy = ky do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo else a ( j , j ) = dble ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif endif end subroutine zher2","tags":"","loc":"proc/zher2.html"},{"title":"zher2k – M_blas","text":"public  subroutine zher2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME zher2k(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   double precision,intent(in)        :: beta\n   integer ,intent(in)                ::k,lda,ldb,ldc,n\n   character,intent(in)               :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZHER2K performs one of the hermitian rank 2k operations C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C , or C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C , where alpha and beta are scalars with beta real, C is an n by n\n  hermitian matrix and A and B are n by k matrices in the first case\n  and k by n matrices in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** H + conjg ( alpha ) * B * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * B + conjg ( alpha ) * B ** H * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'C' or 'c', K specifies the number of rows of the\n        matrices A and B. K must be at least zero. ALPHA ALPHA is complex(kind=real64) .\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . Unchanged on exit . BETA BETA is DOUBLE PRECISION .\n        On entry, BETA specifies the scalar beta. C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.\n      Ed Anderson, Cray Research Inc. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code zher2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha double precision , intent ( in ) :: beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one parameter ( one = 1.0d+0 ) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . dble ( zero )) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j - 1 , j ) = beta * c ( 1 : j - 1 , j ) c ( j , j ) = beta * dble ( c ( j , j )) enddo endif else if ( beta . eq . dble ( zero )) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * dble ( c ( j , j )) c ( j + 1 : n , j ) = beta * c ( j + 1 : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! if ( upper ) then do j = 1 , n if ( beta . eq . dble ( zero )) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j - 1 , j ) = beta * c ( 1 : j - 1 , j ) c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * dconjg ( b ( j , l )) temp2 = dconjg ( alpha * a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = dble ( c ( j , j )) + dble ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo else do j = 1 , n if ( beta . eq . dble ( zero )) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j + 1 : n , j ) = beta * c ( j + 1 : n , j ) c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * dconjg ( b ( j , l )) temp2 = dconjg ( alpha * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = dble ( c ( j , j )) + dble ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo endif else ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + dconjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + dconjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . dble ( zero )) then c ( j , j ) = dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) else c ( j , j ) = beta * dble ( c ( j , j )) + dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) endif else if ( beta . eq . dble ( zero )) then c ( i , j ) = alpha * temp1 + dconjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + dconjg ( alpha ) * temp2 endif endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + dconjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + dconjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . dble ( zero )) then c ( j , j ) = dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) else c ( j , j ) = beta * dble ( c ( j , j )) + dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) endif else if ( beta . eq . dble ( zero )) then c ( i , j ) = alpha * temp1 + dconjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + dconjg ( alpha ) * temp2 endif endif enddo enddo endif endif end subroutine zher2k","tags":"","loc":"proc/zher2k.html"},{"title":"zherk – M_blas","text":"public  subroutine zherk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME zherk(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   double precision,intent(in)        :: alpha,beta\n   integer,intent(in)                 :: k,lda,ldc,n\n   character,intent(in)               :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZHERK performs one of the hermitian rank k operations C := alpha * A * A ** H + beta * C , or C := alpha * A ** H * A + beta * C , where alpha and beta are real scalars, C is an n by n hermitian\n  matrix and A is an n by k matrix in the first case and a k by n\n  matrix in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** H + beta * C . TRANS = ' C ' or ' c ' C := alpha * A ** H * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrix A, and on entry with\n        TRANS = 'C' or 'c', K specifies the number of rows of the\n        matrix A. K must be at least zero. ALPHA ALPHA is DOUBLE PRECISION .\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is DOUBLE PRECISION.\n        On entry, BETA specifies the scalar beta. C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the hermitian matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the hermitian matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. – Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.\n      Ed Anderson, Cray Research Inc. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one rtemp temp upper zero Source Code zherk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa double precision, public, parameter :: one = 1.0d+0 double precision, public :: rtemp complex(kind=real64), public :: temp logical, public :: upper double precision, public, parameter :: zero = 0.0d+0 Source Code subroutine zherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dcmplx , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp double precision rtemp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZHERK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * dble ( c ( j , j )) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * dble ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**H + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . dcmplx ( zero )) then temp = alpha * dconjg ( a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo c ( j , j ) = dble ( c ( j , j )) + dble ( temp * a ( i , l )) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j , j ) = beta * dble ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . dcmplx ( zero )) then temp = alpha * dconjg ( a ( j , l )) c ( j , j ) = dble ( c ( j , j )) + dble ( temp * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**H*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j - 1 temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo rtemp = zero do l = 1 , k rtemp = rtemp + dconjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * dble ( c ( j , j )) endif enddo else do j = 1 , n rtemp = zero do l = 1 , k rtemp = rtemp + dconjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * dble ( c ( j , j )) endif do i = j + 1 , n temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine zherk","tags":"","loc":"proc/zherk.html"},{"title":"zhpmv – M_blas","text":"public  subroutine zhpmv(uplo, n, alpha, ap, x, incx, beta, y, incy) NAME zhpmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zhpmv(uplo,n,alpha,ap,x,incx,beta,y,incy)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: incx,incy,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: ap(*),x(*)\n   complex(kind=real64),intent(inout) :: y(*)\n   .. DEFINITION ZHPMV performs the matrix-vector operation y := alpha * A * x + beta * y , where alpha and beta are scalars, x and y are n element vectors and\n  A is an n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. AP AP is complex(kind=real64) array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular part of the hermitian matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )\n        and a( 2, 2 ) respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular part of the hermitian matrix\n        packed sequentially, column by column, so that AP( 1 )\n        contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )\n        and a( 3, 1 ) respectively, and so on.\n        Note that the imaginary parts of the diagonal elements need\n        not be set and are assumed to be zero. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then Y need not be set on input . Y Y is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCY ) ) . Before entry , the incremented array Y must contain the n element vector y . On exit , Y is overwritten by the updated vector y . INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy Contents Variables i info ix iy j jx jy k kk kx ky one temp1 temp2 zero Source Code zhpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * dble ( ap ( kk + j - 1 )) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( ap ( kk + j - 1 )) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( ap ( kk )) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( ap ( kk )) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif end subroutine zhpmv","tags":"","loc":"proc/zhpmv.html"},{"title":"zhpr – M_blas","text":"public  subroutine zhpr(uplo, n, alpha, x, incx, ap) NAME zhpr(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zhpr(uplo,n,alpha,x,incx,ap)\n\n   .. Scalar Arguments ..\n   double precision ,intent(in)       :: alpha\n   integer ,intent(in)                :: incx,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*)\n   complex(kind=real64),intent(inout) :: ap(*)\n   .. DEFINITION ZHPR performs the hermitian rank 1 operation A := alpha * x * x ** H + A , where alpha is a real scalar, x is an n element vector and A is an\n  n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is DOUBLE PRECISION.\n        On entry, ALPHA specifies the scalar alpha. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AP AP is complex ( kind = real64 ) array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: ap (*) Contents Variables i info ix j jx k kk kx temp zero Source Code zhpr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhpr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ) complex ( kind = real64 ), intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . dble ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( j ) * temp ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ix = kx do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( jx ) * temp ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) ap ( kk ) = dble ( ap ( kk )) + dble ( temp * x ( j )) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo else ap ( kk ) = dble ( ap ( kk )) endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ap ( kk ) = dble ( ap ( kk )) + dble ( temp * x ( jx )) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx ap ( k ) = ap ( k ) + x ( ix ) * temp enddo else ap ( kk ) = dble ( ap ( kk )) endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif end subroutine zhpr","tags":"","loc":"proc/zhpr.html"},{"title":"zhpr2 – M_blas","text":"public  subroutine zhpr2(uplo, n, alpha, x, incx, y, incy, ap) NAME zhpr2(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine zhpr2(uplo,n,alpha,x,incx,y,incy,ap)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: incx,incy,n\n   character,intent(in)               :: uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: x(*),y(*)\n   complex(kind=real64),intent(inout) :: ap(*)\n   .. DEFINITION ZHPR2 performs the hermitian rank 2 operation A := alpha * x * y ** H + conjg ( alpha ) * y * x ** H + A , where alpha is a scalar, x and y are n element vectors and A is an\n  n by n hermitian matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the matrix A is supplied in the packed\n        array AP as follows:\n\n           UPLO = 'U' or 'u'   The upper triangular part of A is\n                               supplied in AP.\n\n           UPLO = 'L' or 'l'   The lower triangular part of A is\n                               supplied in AP. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. X X is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCX ) ).\n        Before entry, the incremented array X must contain the n\n        element vector x. INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . Y Y is complex(kind=real64) array, dimension at least\n        ( 1 + ( n - 1 )*abs( INCY ) ).\n        Before entry, the incremented array Y must contain the n\n        element vector y. INCY INCY is INTEGER On entry , INCY specifies the increment for the elements of Y . INCY must not be zero . AP AP is complex ( kind = real64 ) array , dimension at least ( ( n * ( n + 1 ) ) / 2 ) . Before entry with UPLO = ' U ' or ' u ' , the array AP must contain the upper triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 1 , 2 ) and a ( 2 , 2 ) respectively , and so on . On exit , the array AP is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the array AP must contain the lower triangular part of the hermitian matrix packed sequentially , column by column , so that AP ( 1 ) contains a ( 1 , 1 ) , AP ( 2 ) and AP ( 3 ) contain a ( 2 , 1 ) and a ( 3 , 1 ) respectively , and so on . On exit , the array AP is overwritten by the lower triangular part of the updated matrix . Note that the imaginary parts of the diagonal elements need not be set , they are assumed to be zero , and on exit they are set to zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: ap (*) Contents Variables i info ix iy j jx jy k kk kx ky temp1 temp2 zero Source Code zhpr2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: iy integer, public :: j integer, public :: jx integer, public :: jy integer, public :: k integer, public :: kk integer, public :: kx integer, public :: ky complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zhpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ix = kx iy = ky do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) ap ( kk ) = dble ( ap ( kk )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo else ap ( kk ) = dble ( ap ( kk )) endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ap ( kk ) = dble ( ap ( kk )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else ap ( kk ) = dble ( ap ( kk )) endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif end subroutine zhpr2","tags":"","loc":"proc/zhpr2.html"},{"title":"zrotg – M_blas","text":"public  subroutine zrotg(a, b, c, s) NAME zrotg ( 3 f ) - [ BLAS : COMPLEX16_BLAS_LEVEL1 ] constructs a plane rotation SYNOPSIS subroutine zrotg( a, b, c, s )\n\n   .. Scalar Arguments ..\n   real(wp),intent(out)      :: c\n   complex(wp),intent(in)    :: b\n   complex(wp),intent(out)   :: s\n   complex(wp),intent(inout) :: a\n   .. DEFINITION ZROTG constructs a plane rotation [ c s ] [ a ] = [ r ] [ - conjg ( s ) c ] [ b ] [ 0 ] where c is real, s ic complex, and c* 2 + conjg(s) s = 1. The computation uses the formulas | x | = sqrt ( Re ( x ) ** 2 + Im ( x ) ** 2 ) sgn ( x ) = x / | x | if x /= 0 = 1 if x = 0 c = | a | / sqrt ( | a |** 2 + | b |** 2 ) s = sgn ( a ) * conjg ( b ) / sqrt ( | a |** 2 + | b |** 2 ) When a and b are real and r /= 0, the formulas simplify to r = sgn(a)*sqrt(|a|**2 + |b|**2)\n c = a / r\n s = b / r the same as in ZROTG when |a| > |b|. When |b| >= |a|, the\n  sign of c and s will be different from those computed by ZROTG\n  if the signs of a and b are not the same. OPTIONS A A is DOUBLE COMPLEX On entry , the scalar a . On exit , the scalar r . B B is DOUBLE COMPLEX\n       The scalar b. C C is DOUBLE PRECISION\n       The scalar c. S S is DOUBLE PRECISION\n       The scalar s. AUTHORS Edward Anderson, Lockheed Martin \\par Contributors: Weslley Pereira, University of Colorado Denver, USA FURTHER DETAILS Anderson E. (2017)\n   Algorithm 978: Safe Scaling in the Level 1 BLAS\n   ACM Trans Math Softw 44:1–28\n   https://doi.org/10.1145/3061665 SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s Contents Variables abssq czero d f f1 f2 fs g g1 g2 gs h2 one p r rtmax rtmin safmax safmin t u uu v vv w wp zero Variables Type Visibility Attributes Name Initial real(kind=wp), public :: abssq complex(kind=wp), public, parameter :: czero = 0.0_wp real(kind=wp), public :: d complex(kind=wp), public :: f real(kind=wp), public :: f1 real(kind=wp), public :: f2 complex(kind=wp), public :: fs complex(kind=wp), public :: g real(kind=wp), public :: g1 real(kind=wp), public :: g2 complex(kind=wp), public :: gs real(kind=wp), public :: h2 real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public :: p complex(kind=wp), public :: r real(kind=wp), public, parameter :: rtmax = sqrt(real(radix(0._wp), wp)**max(1-minexponent(0._wp), maxexponent(0._wp)-1)*epsilon(0._wp)) real(kind=wp), public, parameter :: rtmin = sqrt(real(radix(0._wp), wp)**max(minexponent(0._wp)-1, 1-maxexponent(0._wp))/epsilon(0._wp)) real(kind=wp), public, parameter :: safmax = real(radix(0._wp), wp)**max(1-minexponent(0._wp), maxexponent(0._wp)-1) real(kind=wp), public, parameter :: safmin = real(radix(0._wp), wp)**max(minexponent(0._wp)-1, 1-maxexponent(0._wp)) complex(kind=wp), public :: t real(kind=wp), public :: u real(kind=wp), public :: uu real(kind=wp), public :: v real(kind=wp), public :: vv real(kind=wp), public :: w integer, public, parameter :: wp = kind(1.d0) real(kind=wp), public, parameter :: zero = 0.0_wp","tags":"","loc":"proc/zrotg.html"},{"title":"zscal – M_blas","text":"public  subroutine zscal(n, za, zx, incx) NAME zscal(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS subroutine zscal(n,za,zx,incx)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: za\n   integer,intent(in)                 :: incx,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(inout) :: zx(*)\n   .. DEFINITION ZSCAL scales a vector by a constant . OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZA ZA is complex(kind=real64)\n        On entry, ZA specifies the scalar alpha. ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra , 3 / 11 / 78 . modified 3 / 93 to return if incx . le . 0 . modified 12 / 3 / 93 , array ( 1 ) declarations changed to array ( * ) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx Contents Variables i nincx Source Code zscal Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nincx Source Code subroutine zscal ( n , za , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: za integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n zx ( i ) = za * zx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx zx ( i ) = za * zx ( i ) enddo endif end subroutine zscal","tags":"","loc":"proc/zscal.html"},{"title":"zswap – M_blas","text":"public  subroutine zswap(n, zx, incx, zy, incy) NAME zswap(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] SYNOPSIS subroutine zswap(n,zx,incx,zy,incy)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,incy,n\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(inout) :: zx(*),zy(*)\n   .. DEFINITION ZSWAP interchanges two vectors. OPTIONS N N is INTEGER\n      number of elements in input vector(s) ZX ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) INCX INCX is INTEGER\n      storage spacing between elements of ZX ZY ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) INCY INCY is INTEGER\n      storage spacing between elements of ZY AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:November 2017 FURTHER DETAILS jack dongarra, 3/11/78.\n  modified 12/3/93, array(1) declarations changed to array(*) SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy Contents Variables i ix iy ztemp Source Code zswap Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy complex(kind=real64), public :: ztemp Source Code subroutine zswap ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ), zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ( kind = real64 ) :: ztemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 do i = 1 , n ztemp = zx ( i ) zx ( i ) = zy ( i ) zy ( i ) = ztemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ztemp = zx ( ix ) zx ( ix ) = zy ( iy ) zy ( iy ) = ztemp ix = ix + incx iy = iy + incy enddo endif end subroutine zswap","tags":"","loc":"proc/zswap.html"},{"title":"zsymm – M_blas","text":"public  subroutine zsymm(side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) NAME zsymm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: lda,ldb,ldc,m,n\n   character,intent(in)               :: side,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZSYMM performs one of the matrix-matrix operations C := alpha * A * B + beta * C , or C := alpha * B * A + beta * C , where alpha and beta are scalars, A is a symmetric matrix and B and\n  C are m by n matrices. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether the symmetric matrix A appears on the left or right in the operation as follows : SIDE = ' L ' or ' l ' C := alpha * A * B + beta * C , SIDE = ' R ' or ' r ' C := alpha * B * A + beta * C , UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the symmetric matrix A is to be\n        referenced as follows:\n\n           UPLO = 'U' or 'u'   Only the upper triangular part of the\n                               symmetric matrix is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the lower triangular part of the\n                               symmetric matrix is to be referenced. M M is INTEGER\n        On entry, M specifies the number of rows of the matrix C.\n        M must be at least zero. N N is INTEGER\n        On entry, N specifies the number of columns of the matrix C.\n        N must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        m when SIDE = 'L' or 'l' and is n otherwise.\n        Before entry with SIDE = 'L' or 'l', the m by m part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading m by m upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading m by m lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced.\n        Before entry with SIDE = 'R' or 'r', the n by n part of\n        the array A must contain the symmetric matrix, such that\n        when UPLO = 'U' or 'u', the leading n by n upper triangular\n        part of the array A must contain the upper triangular part\n        of the symmetric matrix and the strictly lower triangular\n        part of A is not referenced, and when UPLO = 'L' or 'l',\n        the leading n by n lower triangular part of the array A\n        must contain the lower triangular part of the symmetric\n        matrix and the strictly upper triangular part of A is not\n        referenced. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , otherwise LDA must be at least max ( 1 , n ) . B B is complex(kind=real64) array, dimension ( LDB, N )\n        Before entry, the leading m by n part of the array B must\n        contain the matrix B. LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). BETA BETA is complex ( kind = real64 ) On entry , BETA specifies the scalar beta . When BETA is supplied as zero then C need not be set on input . C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry , the leading m by n part of the array C must contain the matrix C , except when beta is zero , in which case C need not be set on entry . On exit , the array C is overwritten by the m by n updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j k nrowa one temp1 temp2 upper zero Source Code zsymm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zsymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif end subroutine zsymm","tags":"","loc":"proc/zsymm.html"},{"title":"zsyr2k – M_blas","text":"public  subroutine zsyr2k(uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) NAME zsyr2k(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha,beta\n   integer,intent(in)                 :: k,lda,ldb,ldc,n\n   character,intent(in)               :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZSYR2K performs one of the symmetric rank 2k operations C := alpha * A * B ** T + alpha * B * A ** T + beta * C , or C := alpha * A ** T * B + alpha * B ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A and B are n by k matrices in the first case and k by n\n  matrices in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * B ** T + alpha * B * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * B + alpha * B ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrices A and B, and on entry with\n        TRANS = 'T' or 't', K specifies the number of rows of the\n        matrices A and B. K must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . B B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array B must contain the matrix B, otherwise\n        the leading k by n part of the array B must contain the\n        matrix B. LDB LDB is INTEGER On entry , LDB specifies the first dimension of B as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDB must be at least max ( 1 , n ) , otherwise LDB must be at least max ( 1 , k ) . BETA BETA is complex(kind=real64)\n        On entry, BETA specifies the scalar beta. C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp1 temp2 upper zero Source Code zsyr2k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp1 complex(kind=real64), public :: temp2 logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zsyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + a ( 1 : j , l ) * temp1 + b ( 1 : j , l ) * temp2 endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + a ( j : n , l ) * temp1 + b ( j : n , l ) * temp2 endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif end subroutine zsyr2k","tags":"","loc":"proc/zsyr2k.html"},{"title":"zsyrk – M_blas","text":"public  subroutine zsyrk(uplo, trans, n, k, alpha, a, lda, beta, c, ldc) NAME zsyrk(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine zsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(inout) :: alpha,beta\n   integer,intent(in)                 :: k,lda,ldc,n\n   character,intent(in)               :: trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: c(ldc,*)\n   .. DEFINITION ZSYRK performs one of the symmetric rank k operations C := alpha * A * A ** T + beta * C , or C := alpha * A ** T * A + beta * C , where alpha and beta are scalars, C is an n by n symmetric matrix\n  and A is an n by k matrix in the first case and a k by n matrix\n  in the second case. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the upper or lower\n        triangular part of the array C is to be referenced as\n        follows:\n\n           UPLO = 'U' or 'u'   Only the  upper triangular part of  C\n                               is to be referenced.\n\n           UPLO = 'L' or 'l'   Only the  lower triangular part of  C\n                               is to be referenced. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' C := alpha * A * A ** T + beta * C . TRANS = ' T ' or ' t ' C := alpha * A ** T * A + beta * C . N N is INTEGER\n        On entry, N specifies the order of the matrix C. N must be\n        at least zero. K K is INTEGER\n        On entry with TRANS = 'N' or 'n', K specifies the number\n        of columns of the matrix A, and on entry with\n        TRANS = 'T' or 't', K specifies the number of rows of the\n        matrix A. K must be at least zero. ALPHA ALPHA is complex(kind=real64)\n        On entry, ALPHA specifies the scalar alpha. A A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is\n        k when TRANS = 'N' or 'n', and is n otherwise.\n        Before entry with TRANS = 'N' or 'n', the leading n by k\n        part of the array A must contain the matrix A, otherwise\n        the leading k by n part of the array A must contain the\n        matrix A. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When TRANS = ' N ' or ' n ' then LDA must be at least max ( 1 , n ) , otherwise LDA must be at least max ( 1 , k ) . BETA BETA is complex(kind=real64)\n        On entry, BETA specifies the scalar beta. C C is complex ( kind = real64 ) array , dimension ( LDC , N ) Before entry with UPLO = ' U ' or ' u ' , the leading n by n upper triangular part of the array C must contain the upper triangular part of the symmetric matrix and the strictly lower triangular part of C is not referenced . On exit , the upper triangular part of the array C is overwritten by the upper triangular part of the updated matrix . Before entry with UPLO = ' L ' or ' l ' , the leading n by n lower triangular part of the array C must contain the lower triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced . On exit , the lower triangular part of the array C is overwritten by the lower triangular part of the updated matrix . LDC LDC is INTEGER\n        On entry, LDC specifies the first dimension of C as declared\n        in the calling (sub) program. LDC must be at least\n        max( 1, n ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(inout) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc Contents Variables i info j l nrowa one temp upper zero Source Code zsyrk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: l integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine zsyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( inout ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + temp * a ( j : n , l ) endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine zsyrk","tags":"","loc":"proc/zsyrk.html"},{"title":"ztbmv – M_blas","text":"public  subroutine ztbmv(uplo, trans, diag, n, k, a, lda, x, incx) NAME ztbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine ztbmv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,k,lda,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTBMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular band matrix, with ( k + 1 ) diagonals. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is complex ( kind = real64 ) array , dimension ( LDA , N ) . Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l noconj nounit temp zero Source Code ztbmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + dconjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo else if ( nounit ) temp = temp * dconjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + dconjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo else if ( nounit ) temp = temp * dconjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine ztbmv","tags":"","loc":"proc/ztbmv.html"},{"title":"ztbsv – M_blas","text":"public  subroutine ztbsv(uplo, trans, diag, n, k, a, lda, x, incx) NAME ztbsv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine ztbsv(uplo,trans,diag,n,k,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,k,lda,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTBSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular band matrix, with ( k + 1 )\n  diagonals. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. K K is INTEGER\n        On entry with UPLO = 'U' or 'u', K specifies the number of\n        super-diagonals of the matrix A.\n        On entry with UPLO = 'L' or 'l', K specifies the number of\n        sub-diagonals of the matrix A.\n        K must satisfy 0 .le. K. A A is complex ( kind = real64 ) array , dimension ( LDA , N ) Before entry with UPLO = ' U ' or ' u ' , the leading ( k + 1 ) by n part of the array A must contain the upper triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row ( k + 1 ) of the array , the first super - diagonal starting at position 2 in row k , and so on . The top left k by k triangle of the array A is not referenced . The following program segment will transfer an upper triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = K + 1 - J DO 10 , I = MAX ( 1 , J - K ) , J A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Before entry with UPLO = ' L ' or ' l ' , the leading ( k + 1 ) by n part of the array A must contain the lower triangular band part of the matrix of coefficients , supplied column by column , with the leading diagonal of the matrix in row 1 of the array , the first sub - diagonal starting at position 1 in row 2 , and so on . The bottom right k by k triangle of the array A is not referenced . The following program segment will transfer a lower triangular band matrix from conventional full matrix storage to band storage : DO 20 , J = 1 , N M = 1 - J DO 10 , I = J , MIN ( N , J + K ) A ( M + I , J ) = matrix ( I , J ) 10 CONTINUE 20 CONTINUE Note that when DIAG = ' U ' or ' u ' the elements of the array A corresponding to the diagonal elements of the matrix are not referenced , but are assumed to be unity . LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        ( k + 1 ). X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kplus1 kx l noconj nounit temp zero Source Code ztbsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kplus1 integer, public :: kx integer, public :: l logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( kplus1 , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( a ( kplus1 , j )) endif x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( 1 , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( a ( 1 , j )) endif x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif end subroutine ztbsv","tags":"","loc":"proc/ztbsv.html"},{"title":"ztpmv – M_blas","text":"public  subroutine ztpmv(uplo, trans, diag, n, ap, x, incx) NAME ztpmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine ztpmv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: ap(*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTPMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix, supplied in packed form. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is complex(kind=real64) array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx noconj nounit temp zero Source Code ztpmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk - 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do i = j - 1 , 1 , - 1 temp = temp + dconjg ( ap ( k )) * x ( i ) k = k - 1 enddo endif x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + dconjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk + 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do i = j + 1 , n temp = temp + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo endif x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + dconjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif end subroutine ztpmv","tags":"","loc":"proc/ztpmv.html"},{"title":"ztpsv – M_blas","text":"public  subroutine ztpsv(uplo, trans, diag, n, ap, x, incx) NAME ztpsv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine ztpsv(uplo,trans,diag,n,ap,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: ap(*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTPSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix, supplied in packed form. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER*1\n        On entry, TRANS specifies the equations to be solved as\n        follows:\n\n           TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. AP AP is complex(kind=real64) array, dimension at least\n        ( ( n*( n + 1 ) )/2 ).\n        Before entry with UPLO = 'U' or 'u', the array AP must\n        contain the upper triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )\n        respectively, and so on.\n        Before entry with UPLO = 'L' or 'l', the array AP must\n        contain the lower triangular matrix packed sequentially,\n        column by column, so that AP( 1 ) contains a( 1, 1 ),\n        AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )\n        respectively, and so on.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced, but are assumed to be unity. X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx k kk kx noconj nounit temp zero Source Code ztpsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: k integer, public :: kk integer, public :: kx logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk if ( noconj ) then do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do i = 1 , j - 1 temp = temp - dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / dconjg ( ap ( kk + j - 1 )) endif x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do k = kk , kk + j - 2 temp = temp - dconjg ( ap ( k )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( ap ( kk + j - 1 )) endif x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( ap ( k )) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / dconjg ( ap ( kk - n + j )) endif x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - dconjg ( ap ( k )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( ap ( kk - n + j )) endif x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif end subroutine ztpsv","tags":"","loc":"proc/ztpsv.html"},{"title":"ztrmm – M_blas","text":"public  subroutine ztrmm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME ztrmm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] SYNOPSIS subroutine ztrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: lda,ldb,m,n\n   character,intent(in)               :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: b(ldb,*)\n   .. DEFINITION ZTRMM performs one of the matrix-matrix operations B := alpha * op ( A ) * B , or B := alpha * B * op ( A ) where alpha is a scalar, B is an m by n matrix, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. OPTIONS SIDE SIDE is CHARACTER * 1 On entry , SIDE specifies whether op ( A ) multiplies B from the left or right as follows : SIDE = ' L ' or ' l ' B := alpha * op ( A ) * B . SIDE = ' R ' or ' r ' B := alpha * B * op ( A ) . UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**H. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is complex ( kind = real64 ) On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is complex(kind=real64) array, dimension ( LDA, k ), where k is m\n        when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is complex ( kind = real64 ) array , dimension ( LDB , N ) . Before entry , the leading m by n part of the array B must contain the matrix B , and on exit is overwritten by the transformed matrix . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside noconj nounit nrowa one temp upper zero Source Code ztrmm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: noconj logical, public :: nounit integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n do i = 1 , m b ( i , j ) = zero enddo enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * dconjg ( a ( i , i )) do k = 1 , i - 1 temp = temp + dconjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * dconjg ( a ( i , i )) do k = i + 1 , m temp = temp + dconjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * dconjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * dconjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * dconjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * dconjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif end subroutine ztrmm","tags":"","loc":"proc/ztrmm.html"},{"title":"ztrmv – M_blas","text":"public  subroutine ztrmv(uplo, trans, diag, n, a, lda, x, incx) NAME ztrmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] SYNOPSIS subroutine ztrmv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,lda,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTRMV performs one of the matrix-vector operations x := A * x , or x := A ** T * x , or x := A ** H * x , where x is an n element vector and A is an n by n unit, or non-unit,\n  upper or lower triangular matrix. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS TRANS is CHARACTER * 1 On entry , TRANS specifies the operation to be performed as follows : TRANS = ' N ' or ' n ' x := A * x . TRANS = ' T ' or ' t ' x := A ** T * x . TRANS = ' C ' or ' c ' x := A ** H * x . DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit\n        triangular as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N N is INTEGER\n        On entry, N specifies the order of the matrix A.\n        N must be at least zero. A A is complex(kind=real64) array, dimension ( LDA, N ).\n        Before entry with UPLO = 'U' or 'u', the leading n by n\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading n by n\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element vector x . On exit , X is overwritten with the transformed vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine.\n   The vector and matrix arguments are not referenced when N = 0, or M = 0 – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx noconj nounit temp zero Source Code ztrmv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j - 1 , 1 , - 1 temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + dconjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j + 1 , n temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j + 1 , n ix = ix + incx temp = temp + dconjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine ztrmv","tags":"","loc":"proc/ztrmv.html"},{"title":"ztrsm – M_blas","text":"public  subroutine ztrsm(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) NAME ztrsm(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL3] SYNOPSIS subroutine ztrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)\n\n   .. Scalar Arguments ..\n   complex(kind=real64),intent(in)    :: alpha\n   integer,intent(in)                 :: lda,ldb,m,n\n   character,intent(in)               :: diag,side,transa,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: b(ldb,*)\n   .. DEFINITION ZTRSM solves one of the matrix equations op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where alpha is a scalar, X and B are m by n matrices, A is a unit, or\n  non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. The matrix X is overwritten on B. OPTIONS SIDE SIDE is CHARACTER*1\n        On entry, SIDE specifies whether op( A ) appears on the left\n        or right of X as follows:\n\n           SIDE = 'L' or 'l'   op( A )*X = alpha*B.\n\n           SIDE = 'R' or 'r'   X*op( A ) = alpha*B. UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix A is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANSA TRANSA is CHARACTER*1\n        On entry, TRANSA specifies the form of op( A ) to be used in\n        the matrix multiplication as follows:\n\n           TRANSA = 'N' or 'n'   op( A ) = A.\n\n           TRANSA = 'T' or 't'   op( A ) = A**T.\n\n           TRANSA = 'C' or 'c'   op( A ) = A**H. DIAG DIAG is CHARACTER*1\n        On entry, DIAG specifies whether or not A is unit triangular\n        as follows:\n\n           DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. M M is INTEGER\n        On entry, M specifies the number of rows of B. M must be at\n        least zero. N N is INTEGER\n        On entry, N specifies the number of columns of B. N must be\n        at least zero. ALPHA ALPHA is complex ( kind = real64 ) On entry , ALPHA specifies the scalar alpha . When alpha is zero then A is not referenced and B need not be set before entry . A A is complex(kind=real64) array, dimension ( LDA, k ),\n        where k is m when SIDE = 'L' or 'l'\n          and k is n when SIDE = 'R' or 'r'.\n        Before entry with UPLO = 'U' or 'u', the leading k by k\n        upper triangular part of the array A must contain the upper\n        triangular matrix and the strictly lower triangular part of\n        A is not referenced.\n        Before entry with UPLO = 'L' or 'l', the leading k by k\n        lower triangular part of the array A must contain the lower\n        triangular matrix and the strictly upper triangular part of\n        A is not referenced.\n        Note that when DIAG = 'U' or 'u', the diagonal elements of\n        A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER On entry , LDA specifies the first dimension of A as declared in the calling ( sub ) program . When SIDE = ' L ' or ' l ' then LDA must be at least max ( 1 , m ) , when SIDE = ' R ' or ' r ' then LDA must be at least max ( 1 , n ) . B B is complex ( kind = real64 ) array , dimension ( LDB , N ) Before entry , the leading m by n part of the array B must contain the right - hand side matrix B , and on exit is overwritten by the solution matrix X . LDB LDB is INTEGER\n        On entry, LDB specifies the first dimension of B as declared\n        in the calling (sub) program. LDB must be at least\n        max( 1, m ). AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 3 Blas routine. – Written on 8-February-1989.\n      Jack Dongarra, Argonne National Laboratory.\n      Iain Duff, AERE Harwell.\n      Jeremy Du Croz, Numerical Algorithms Group Ltd.\n      Sven Hammarling, Numerical Algorithms Group Ltd. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb Contents Variables i info j k lside noconj nounit nrowa one temp upper zero Source Code ztrsm Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k logical, public :: lside logical, public :: noconj logical, public :: nounit integer, public :: nrowa complex(kind=real64), public, parameter :: one = (1.0d+0,0.0d+0) complex(kind=real64), public :: temp logical, public :: upper complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n do i = 1 , m b ( i , j ) = zero enddo enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) if ( noconj ) then do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = 1 , i - 1 temp = temp - dconjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / dconjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) if ( noconj ) then do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = i + 1 , m temp = temp - dconjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / dconjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then do i = 1 , m b ( i , j ) = b ( i , j ) - a ( k , j ) * b ( i , k ) enddo endif enddo if ( nounit ) then temp = one / a ( j , j ) do i = 1 , m b ( i , j ) = temp * b ( i , j ) enddo endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then do i = 1 , m b ( i , j ) = b ( i , j ) - a ( k , j ) * b ( i , k ) enddo endif enddo if ( nounit ) then temp = one / a ( j , j ) do i = 1 , m b ( i , j ) = temp * b ( i , j ) enddo endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / dconjg ( a ( k , k )) endif do i = 1 , m b ( i , k ) = temp * b ( i , k ) enddo endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = dconjg ( a ( j , k )) endif do i = 1 , m b ( i , j ) = b ( i , j ) - temp * b ( i , k ) enddo endif enddo if ( alpha . ne . one ) then do i = 1 , m b ( i , k ) = alpha * b ( i , k ) enddo endif enddo else do k = 1 , n if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / dconjg ( a ( k , k )) endif do i = 1 , m b ( i , k ) = temp * b ( i , k ) enddo endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = dconjg ( a ( j , k )) endif do i = 1 , m b ( i , j ) = b ( i , j ) - temp * b ( i , k ) enddo endif enddo if ( alpha . ne . one ) then do i = 1 , m b ( i , k ) = alpha * b ( i , k ) enddo endif enddo endif endif endif end subroutine ztrsm","tags":"","loc":"proc/ztrsm.html"},{"title":"ztrsv – M_blas","text":"public  subroutine ztrsv(uplo, trans, diag, n, a, lda, x, incx) NAME ztrsv(3f) - [BLAS:COMPLEX16_BLAS_LEVEL2] SYNOPSIS subroutine ztrsv(uplo,trans,diag,n,a,lda,x,incx)\n\n   .. Scalar Arguments ..\n   integer,intent(in)                 :: incx,lda,n\n   character,intent(in)               :: diag,trans,uplo\n   ..\n   .. Array Arguments ..\n   complex(kind=real64),intent(in)    :: a(lda,*)\n   complex(kind=real64),intent(inout) :: x(*)\n   .. DEFINITION ZTRSV solves one of the systems of equations A*x = b,   or   A**T*x = b,   or   A**H*x = b, where b and x are n element vectors and A is an n by n unit, or\n  non-unit, upper or lower triangular matrix. No test for singularity or near-singularity is included in this\n  routine. Such tests must be performed before calling this routine. OPTIONS UPLO UPLO is CHARACTER*1\n        On entry, UPLO specifies whether the matrix is an upper or\n        lower triangular matrix as follows:\n\n           UPLO = 'U' or 'u'   A is an upper triangular matrix.\n\n           UPLO = 'L' or 'l'   A is a lower triangular matrix. TRANS\n            On entry, TRANS specifies the equations to be solved as\n            follows: TRANS = 'N' or 'n'   A*x = b.\n\n           TRANS = 'T' or 't'   A**T*x = b.\n\n           TRANS = 'C' or 'c'   A**H*x = b. DIAG\n            On entry, DIAG specifies whether or not A is unit\n            triangular as follows: DIAG = 'U' or 'u'   A is assumed to be unit triangular.\n\n           DIAG = 'N' or 'n'   A is not assumed to be unit\n                               triangular. N\n            On entry, N specifies the order of the matrix A.\n            N must be at least zero. A\n            A is complex(kind=real64) array, dimension ( LDA, N )\n            Before entry with UPLO = ‘U’ or ‘u’, the leading n by n\n            upper triangular part of the array A must contain the upper\n            triangular matrix and the strictly lower triangular part of\n            A is not referenced.\n            Before entry with UPLO = ‘L’ or ‘l’, the leading n by n\n            lower triangular part of the array A must contain the lower\n            triangular matrix and the strictly upper triangular part of\n            A is not referenced.\n            Note that when DIAG = ‘U’ or ‘u’, the diagonal elements of\n            A are not referenced either, but are assumed to be unity. LDA LDA is INTEGER\n        On entry, LDA specifies the first dimension of A as declared\n        in the calling (sub) program. LDA must be at least\n        max( 1, n ). X X is complex ( kind = real64 ) array , dimension at least ( 1 + ( n - 1 ) * abs ( INCX ) ) . Before entry , the incremented array X must contain the n element right - hand side vector b . On exit , X is overwritten with the solution vector x . INCX INCX is INTEGER On entry , INCX specifies the increment for the elements of X . INCX must not be zero . AUTHORS Univ. of Tennessee Univ. of California Berkeley Univ. of Colorado Denver NAG Ltd. date:December 2016 FURTHER DETAILS Level 2 Blas routine. – Written on 22-October-1986.\n      Jack Dongarra, Argonne National Lab.\n      Jeremy Du Croz, Nag Central Office.\n      Sven Hammarling, Nag Central Office.\n      Richard Hanson, Sandia National Labs. SEE ALSO Online html documentation available at\nhttp://www.netlib.org/lapack/explore-html/ Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx Contents Variables i info ix j jx kx noconj nounit temp zero Source Code ztrsv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: ix integer, public :: j integer, public :: jx integer, public :: kx logical, public :: noconj logical, public :: nounit complex(kind=real64), public :: temp complex(kind=real64), public, parameter :: zero = (0.0d+0,0.0d+0) Source Code subroutine ztrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - dconjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n ix = kx temp = x ( jx ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 ix = kx temp = x ( jx ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( a ( i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine ztrsv","tags":"","loc":"proc/ztrsv.html"},{"title":"M_blas – M_blas","text":"Uses iso_fortran_env Contents Variables xerbla Abstract Interfaces xerbla_interface Functions cdotc cdotu dasum dcabs1 ddot dnrm2 dsdot dzasum dznrm2 icamax idamax isamax izamax lsame sasum scabs1 scasum scnrm2 sdot sdsdot snrm2 zdotc zdotu Subroutines caxpy ccopy cgbmv cgemm cgemv cgerc cgeru chbmv chemm chemv cher cher2 cher2k cherk chpmv chpr chpr2 crotg cscal csrot csscal cswap csymm csyr2k csyrk ctbmv ctbsv ctpmv ctpsv ctrmm ctrmv ctrsm ctrsv daxpy dcopy dgbmv dgemm dgemv dger drot drotg drotm drotmg dsbmv dscal dspmv dspr dspr2 dswap dsymm dsymv dsyr dsyr2 dsyr2k dsyrk dtbmv dtbsv dtpmv dtpsv dtrmm dtrmv dtrsm dtrsv saxpy scopy set_xerbla sgbmv sgemm sgemv sger srot srotg srotm srotmg ssbmv sscal sspmv sspr sspr2 sswap ssymm ssymv ssyr ssyr2 ssyr2k ssyrk stbmv stbsv stpmv stpsv strmm strmv strsm strsv xerbla_array zaxpy zcopy zdrot zdscal zgbmv zgemm zgemv zgerc zgeru zhbmv zhemm zhemv zher zher2 zher2k zherk zhpmv zhpr zhpr2 zrotg zscal zswap zsymm zsyr2k zsyrk ztbmv ztbsv ztpmv ztpsv ztrmm ztrmv ztrsm ztrsv Variables Type Visibility Attributes Name Initial procedure( xerbla_interface ), public, pointer :: xerbla => std_xerbla Abstract Interfaces abstract interface public  subroutine xerbla_interface(srname, info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(in) :: info Functions public  function cdotc (n, cx, incx, cy, incy) CDOTC forms the dot product of two complex vectors Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(in) :: cy (*) integer, intent(in) :: incy Return Value complex public  function cdotu (n, cx, incx, cy, incy) CDOTU forms the dot product of two complex vectors Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(in) :: cy (*) integer, intent(in) :: incy Return Value complex public pure function dasum (n, dx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx Return Value doubleprecision public pure function dcabs1 (z) DCABS1 computes |Re(.)| + |Im(.)| of a double complex number Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: z Return Value doubleprecision public pure function ddot (n, dx, incx, dy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(in) :: dy (*) integer, intent(in) :: incy Return Value doubleprecision public pure function dnrm2 (n, x, incx) DNRM2 returns the euclidean norm of a vector via the function\n  name, so that Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public pure function dsdot (n, sx, incx, sy, incy) Compute the inner product of two vectors with extended\n  precision accumulation and result. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value doubleprecision public  function dzasum (n, zx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx Return Value doubleprecision public pure function dznrm2 (n, x, incx) DZNRM2 returns the euclidean norm of a vector via the function\n  name, so that Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public pure function icamax (n, cx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx Return Value integer public pure function idamax (n, dx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx Return Value integer public  function isamax (n, sx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx Return Value integer public pure function izamax (n, zx, incx) N       number of elements in input vector(s)\n  ZX      array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n  INCX    storage spacing between elements of ZX Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx Return Value integer public pure function lsame (ca, cb) LSAME returns .TRUE. if CA is the same letter as CB regardless of\n  case. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ca character(len=1), intent(in) :: cb Return Value logical public pure function sasum (n, sx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx Return Value real public pure elemental function scabs1 (z) SCABS1 computes |Re(.)| + |Im(.)| of a complex number Read more… Arguments Type Intent Optional Attributes Name complex, intent(in) :: z Return Value real public  function scasum (n, cx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx Return Value real public pure function scnrm2 (n, x, incx) SCNRM2 returns the euclidean norm of a vector via the function\n  name, so that Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public pure function sdot (n, sx, incx, sy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value real public pure function sdsdot (n, sb, sx, incx, sy, incy) SDSDOT := SUM SX * SY (accumulated double precision, returned single) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sb real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(in) :: sy (*) integer, intent(in) :: incy Return Value real public  function snrm2 (n, x, incx) SNRM2 := square root of sum of SX(I)**2 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (*) integer, intent(in) :: incx Return Value real(kind=wp) public pure function zdotc (n, zx, incx, zy, incy) ZDOTC forms the dot product of two complex vectors\n       ZDOTC = X&#94;H * Y Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: zy (*) integer, intent(in) :: incy Return Value complex(kind=real64) public pure function zdotu (n, zx, incx, zy, incy) ZDOTU forms the dot product of two complex vectors\n       ZDOTU = X&#94;T * Y Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: zy (*) integer, intent(in) :: incy Return Value complex(kind=real64) Subroutines public  subroutine caxpy (n, ca, cx, incx, cy, incy) November 2017 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: ca complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy public  subroutine ccopy (n, cx, incx, cy, incy) date:November 2017 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: cx (*) integer, intent(in) :: incx complex, intent(out) :: cy (*) integer, intent(in) :: incy public  subroutine cgbmv (trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) CGBMV  performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine cgemm (transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) CGEMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine cgemv (trans, m, n, alpha, a, lda, x, incx, beta, y, incy) CGEMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine cgerc (m, n, alpha, x, incx, y, incy, a, lda) CGERC performs the rank 1 operation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine cgeru (m, n, alpha, x, incx, y, incy, a, lda) CGERU performs the rank 1 operation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine chbmv (uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) CHBMV(3f) performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine chemm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) CHEMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine chemv (uplo, n, alpha, a, lda, x, incx, beta, y, incy) CHEMV  performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine cher (uplo, n, alpha, x, incx, a, lda) CHER performs the hermitian rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine cher2 (uplo, n, alpha, x, incx, y, incy, a, lda) CHER2 performs the hermitian rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine cher2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) CHER2K performs one of the hermitian rank 2k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine cherk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) C:=alpha A TRANSPOSE(A)+beta*C, C hermitian. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine chpmv (uplo, n, alpha, ap, x, incx, beta, y, incy) CY := alpha A CX + beta*CY, A a (square) hermitian packed matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: ap (*) complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: beta complex, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine chpr (uplo, n, alpha, x, incx, ap) A := A + alpha CX CONJUGATE-TRANSPOSE(CX), a a (square) hermitian packed. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(inout) :: ap (*) public  subroutine chpr2 (uplo, n, alpha, x, incx, y, incy, ap) A := A + alpha CX CONJUGATE-TRANSPOSE(CY)n + CONJUGATE(ALPHA) CY CONJUGATE-TRANSPOSE(CX),n A a (square) hermitian packed matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: x (*) integer, intent(in) :: incx complex, intent(in) :: y (*) integer, intent(in) :: incy complex, intent(inout) :: ap (*) public  subroutine crotg (a, b, c, s) CROTG constructs a plane rotation Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s public  subroutine cscal (n, ca, cx, incx) CX:=CA*CX (complex multiplier) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(in) :: ca complex, intent(inout) :: cx (*) integer, intent(in) :: incx public  subroutine csrot (n, cx, incx, cy, incy, c, s) CSROT applies a plane rotation, where the cos and sin (c and s) are real\n  and the vectors cx and cy are complex.\n  jack dongarra, linpack, 3/11/78. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy real, intent(in) :: c real, intent(in) :: s public  subroutine csscal (n, sa, cx, incx) CX:=SA*CX (real multiplier). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa complex, intent(inout) :: cx (*) integer, intent(in) :: incx public  subroutine cswap (n, cx, incx, cy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex, intent(inout) :: cx (*) integer, intent(in) :: incx complex, intent(inout) :: cy (*) integer, intent(in) :: incy public  subroutine csymm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) C:=alpha A B+beta*C, A symmetric, B, C rectangular. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine csyr2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) C:=alpha A TRANSPOSE(B)+alpha B TRANSPOSE(A)+beta*C, C symmetric. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine csyrk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) C:=alpha A TRANSPOSE(A)+beta*C, C symmetric. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(in) :: beta complex, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine ctbmv (uplo, trans, diag, n, k, a, lda, x, incx) CX := A*CX, A is a triangular band matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ctbsv (uplo, trans, diag, n, k, a, lda, x, incx) CX := INVERSE(A)*CX, where A is a triangular band matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ctpmv (uplo, trans, diag, n, ap, x, incx) CX := A*CX, A is a packed triangular band matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: ap (*) complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ctpsv (uplo, trans, diag, n, ap, x, incx) CX := INVERSE(A)*CX, where A is a packed triangular band matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: ap (*) complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ctrmm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) B:=A B or B:=B A, A triangular, B rectangular. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine ctrmv (uplo, trans, diag, n, a, lda, x, incx) CX := A*CX, A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ctrsm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) B:=INVERSE(A) C or B:=C INVERSE(A), B, C rectangular, A triangular. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex, intent(in) :: alpha complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine ctrsv (uplo, trans, diag, n, a, lda, x, incx) CX := INVERSE(A)*CX, where A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex, intent(in) :: a (lda,*) integer, intent(in) :: lda complex, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine daxpy (n, da, dx, incx, dy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy public  subroutine dcopy (n, dx, incx, dy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: dx (*) integer, intent(in) :: incx double precision, intent(out) :: dy (*) integer, intent(in) :: incy public  subroutine dgbmv (trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) DGBMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine dgemm (transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) DGEMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine dgemv (trans, m, n, alpha, a, lda, x, incx, beta, y, incy) DGEMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine dger (m, n, alpha, x, incx, y, incy, a, lda) DGER performs the rank 1 operation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine drot (n, dx, incx, dy, incy, c, s) N\n          number of elements in input vector(s)\n   DX\n           array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy double precision, intent(in) :: c double precision, intent(in) :: s public  subroutine drotg (a, b, c, s) DROTG constructs a plane rotation Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s public  subroutine drotm (n, dx, incx, dy, incy, dparam) N\n          number of elements in input vector(s)\n   DX\n           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy double precision, intent(in) :: dparam (5) public  subroutine drotmg (dd1, dd2, dx1, dy1, dparam) DD1 Read more… Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: dd1 double precision, intent(inout) :: dd2 double precision, intent(inout) :: dx1 double precision, intent(in) :: dy1 double precision, intent(out) :: dparam (5) public  subroutine dsbmv (uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) DSBMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine dscal (n, da, dx, incx) N\n           number of elements in input vector(s)\n   DA\n           On entry, DA specifies the scalar alpha.\n   DX\n           array, dimension ( 1 + ( N - 1 )*abs( INCX ) )\n   INCX\n           storage spacing between elements of DX Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da double precision, intent(inout) :: dx (*) integer, intent(in) :: incx public  subroutine dspmv (uplo, n, alpha, ap, x, incx, beta, y, incy) DSPMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: ap (*) double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine dspr (uplo, n, alpha, x, incx, ap) DSPR performs the symmetric rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(inout) :: ap (*) public  subroutine dspr2 (uplo, n, alpha, x, incx, y, incy, ap) DSPR2 performs the symmetric rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: ap (*) public  subroutine dswap (n, dx, incx, dy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(inout) :: dx (*) integer, intent(in) :: incx double precision, intent(inout) :: dy (*) integer, intent(in) :: incy public  subroutine dsymm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) DSYMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine dsymv (uplo, n, alpha, a, lda, x, incx, beta, y, incy) DSYMV performs the matrix-vector  operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: beta double precision, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine dsyr (uplo, n, alpha, x, incx, a, lda) DSYR performs the symmetric rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine dsyr2 (uplo, n, alpha, x, incx, y, incy, a, lda) DSYR2 performs the symmetric rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: x (*) integer, intent(in) :: incx double precision, intent(in) :: y (*) integer, intent(in) :: incy double precision, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine dsyr2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) DSYR2K performs one of the symmetric rank 2k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine dsyrk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) DSYRK performs one of the symmetric rank k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: beta double precision, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine dtbmv (uplo, trans, diag, n, k, a, lda, x, incx) DTBMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine dtbsv (uplo, trans, diag, n, k, a, lda, x, incx) DTBSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine dtpmv (uplo, trans, diag, n, ap, x, incx) DTPMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: ap (*) double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine dtpsv (uplo, trans, diag, n, ap, x, incx) DTPSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: ap (*) double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine dtrmm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) DTRMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine dtrmv (uplo, trans, diag, n, a, lda, x, incx) DTRMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine dtrsm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) DTRSM solves one of the matrix equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n double precision, intent(in) :: alpha double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine dtrsv (uplo, trans, diag, n, a, lda, x, incx) DTRSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n double precision, intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine saxpy (n, sa, sx, incx, sy, incy) N\n          number of elements in input vector(s)\n   SA\n          On entry, SA specifies the scalar alpha.\n   SX\n          SX is REAL array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX\n          storage spacing between elements of SX\n   SY\n          SY is REAL array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY\n          storage spacing between elements of SY Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy public  subroutine scopy (n, sx, incx, sy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sx (*) integer, intent(in) :: incx real, intent(out) :: sy (*) integer, intent(in) :: incy public  subroutine set_xerbla (proc) Arguments Type Intent Optional Attributes Name procedure( xerbla_interface ) :: proc public  subroutine sgbmv (trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) SY:=alpha A SX+beta*SY, A a band matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine sgemm (transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) C:=alpha A B+beta*C, A, B, C rectangular. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine sgemv (trans, m, n, alpha, a, lda, x, incx, beta, y, incy) SY:=alpha A SX+beta*SY, A a rectangular matrix. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine sger (m, n, alpha, x, incx, y, incy, a, lda) A:=A+alpha SX TRANSPOSE(SY), rank 1 update, A a rectangular matrix. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine srot (n, sx, incx, sy, incy, c, s) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy real, intent(in) :: c real, intent(in) :: s public  subroutine srotg (a, b, c, s) subroutine srotg( a, b, c, s ) Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s public  subroutine srotm (n, sx, incx, sy, incy, sparam) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy real, intent(in) :: sparam (5) public  subroutine srotmg (sd1, sd2, sx1, sy1, sparam) SD1 Read more… Arguments Type Intent Optional Attributes Name real, intent(inout) :: sd1 real, intent(inout) :: sd2 real, intent(inout) :: sx1 real, intent(in) :: sy1 real, intent(out) :: sparam (5) public  subroutine ssbmv (uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) SSBMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine sscal (n, sa, sx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: sa real, intent(inout) :: sx (*) integer, intent(in) :: incx public  subroutine sspmv (uplo, n, alpha, ap, x, incx, beta, y, incy) SSPMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: ap (*) real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine sspr (uplo, n, alpha, x, incx, ap) SSPR performs the symmetric rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(inout) :: ap (*) public  subroutine sspr2 (uplo, n, alpha, x, incx, y, incy, ap) SSPR2 performs the symmetric rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: ap (*) public  subroutine sswap (n, sx, incx, sy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: sx (*) integer, intent(in) :: incx real, intent(inout) :: sy (*) integer, intent(in) :: incy public  subroutine ssymm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) SSYMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine ssymv (uplo, n, alpha, a, lda, x, incx, beta, y, incy) SSYMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: beta real, intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine ssyr (uplo, n, alpha, x, incx, a, lda) SSYR performs the symmetric rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine ssyr2 (uplo, n, alpha, x, incx, y, incy, a, lda) SSYR2 performs the symmetric rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x (*) integer, intent(in) :: incx real, intent(in) :: y (*) integer, intent(in) :: incy real, intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine ssyr2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) SSYR2K performs one of the symmetric rank 2k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: b (ldb,*) integer, intent(in) :: ldb real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine ssyrk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) SSYRK performs one of the symmetric rank k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(in) :: beta real, intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine stbmv (uplo, trans, diag, n, k, a, lda, x, incx) STBMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine stbsv (uplo, trans, diag, n, k, a, lda, x, incx) STBSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine stpmv (uplo, trans, diag, n, ap, x, incx) STPMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: ap (*) real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine stpsv (uplo, trans, diag, n, ap, x, incx) STPSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: ap (*) real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine strmm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) STRMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine strmv (uplo, trans, diag, n, a, lda, x, incx) STRMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine strsm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) STRSM solves one of the matrix equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine strsv (uplo, trans, diag, n, a, lda, x, incx) STRSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n real, intent(in) :: a (lda,*) integer, intent(in) :: lda real, intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine xerbla_array (srname_array, srname_len, info) XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK\n  and BLAS error handler. Rather than taking a Fortran string argument\n  as the function’s name, XERBLA_ARRAY takes an array of single\n  characters along with the array’s length. XERBLA_ARRAY then copies\n  up to 32 characters of that array into a Fortran string and passes\n  that to XERBLA. If called with a non-positive SRNAME_LEN,\n  XERBLA_ARRAY will call XERBLA with a string of all blank characters. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname_array (srname_len) integer, intent(in) :: srname_len integer, intent(in) :: info public  subroutine zaxpy (n, za, zx, incx, zy, incy) N      number of elements in input vector(s)\n   ZA     On entry, ZA specifies the scalar alpha.\n   ZX     ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 ) abs( INCX ) )\n   INCX   storage spacing between elements of ZX\n   ZY     ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 ) abs( INCY ) )\n   INCY   storage spacing between elements of ZY Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy public  subroutine zcopy (n, zx, incx, zy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(out) :: zy (*) integer, intent(in) :: incy public  subroutine zdrot (n, zx, incx, zy, incy, c, s) Applies a plane rotation, where the cos and sin (c and s) are real\n  and the vectors cx and cy are complex.\n  jack dongarra, linpack, 3/11/78. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy double precision, intent(in) :: c double precision, intent(in) :: s public  subroutine zdscal (n, da, zx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: da complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx public  subroutine zgbmv (trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) ZGBMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: kl integer, intent(in) :: ku complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine zgemm (transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) ZGEMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zgemv (trans, m, n, alpha, a, lda, x, incx, beta, y, incy) ZGEMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine zgerc (m, n, alpha, x, incx, y, incy, a, lda) ZGERC performs the rank 1 operation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine zgeru (m, n, alpha, x, incx, y, incy, a, lda) ZGERU performs the rank 1 operation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine zhbmv (uplo, n, k, alpha, a, lda, x, incx, beta, y, incy) ZHBMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine zhemm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) ZHEMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zhemv (uplo, n, alpha, a, lda, x, incx, beta, y, incy) ZHEMV performs the matrix-vector  operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine zher (uplo, n, alpha, x, incx, a, lda) ZHER performs the hermitian rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine zher2 (uplo, n, alpha, x, incx, y, incy, a, lda) ZHER2 performs the hermitian rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: a (lda,*) integer, intent(in) :: lda public  subroutine zher2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) ZHER2K performs one of the hermitian rank 2k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb double precision, intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zherk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) ZHERK performs one of the hermitian rank k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda double precision, intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zhpmv (uplo, n, alpha, ap, x, incx, beta, y, incy) ZHPMV performs the matrix-vector operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer, intent(in) :: incy public  subroutine zhpr (uplo, n, alpha, x, incx, ap) ZHPR performs the hermitian rank 1 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n double precision, intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: ap (*) public  subroutine zhpr2 (uplo, n, alpha, x, incx, y, incy, ap) ZHPR2 performs the hermitian rank 2 operation Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: x (*) integer, intent(in) :: incx complex(kind=real64), intent(in) :: y (*) integer, intent(in) :: incy complex(kind=real64), intent(inout) :: ap (*) public  subroutine zrotg (a, b, c, s) ZROTG constructs a plane rotation Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(inout) :: a complex(kind=wp), intent(in) :: b real(kind=wp), intent(out) :: c complex(kind=wp), intent(out) :: s public  subroutine zscal (n, za, zx, incx) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx public  subroutine zswap (n, zx, incx, zy, incy) N Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=real64), intent(inout) :: zx (*) integer, intent(in) :: incx complex(kind=real64), intent(inout) :: zy (*) integer, intent(in) :: incy public  subroutine zsymm (side, uplo, m, n, alpha, a, lda, b, ldb, beta, c, ldc) ZSYMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zsyr2k (uplo, trans, n, k, alpha, a, lda, b, ldb, beta, c, ldc) ZSYR2K performs one of the symmetric rank 2k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer, intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine zsyrk (uplo, trans, n, k, alpha, a, lda, beta, c, ldc) ZSYRK performs one of the symmetric rank k operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(inout) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer, intent(in) :: ldc public  subroutine ztbmv (uplo, trans, diag, n, k, a, lda, x, incx) ZTBMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ztbsv (uplo, trans, diag, n, k, a, lda, x, incx) ZTBSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n integer, intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ztpmv (uplo, trans, diag, n, ap, x, incx) ZTPMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ztpsv (uplo, trans, diag, n, ap, x, incx) ZTPSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: ap (*) complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ztrmm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) ZTRMM performs one of the matrix-matrix operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine ztrmv (uplo, trans, diag, n, a, lda, x, incx) ZTRMV performs one of the matrix-vector operations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx public  subroutine ztrsm (side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) ZTRSM solves one of the matrix equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer, intent(in) :: m integer, intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb public  subroutine ztrsv (uplo, trans, diag, n, a, lda, x, incx) ZTRSV solves one of the systems of equations Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer, intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer, intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer, intent(in) :: incx","tags":"","loc":"module/m_blas.html"},{"title":"compatible.f90 – M_blas","text":"Contents Functions CDOTC CDOTU DASUM DCABS1 DDOT DNRM2 DSDOT DZASUM DZNRM2 ICAMAX IDAMAX ISAMAX IZAMAX LSAME SASUM scabs1 SCASUM SCNRM2 SDOT SDSDOT SNRM2 ZDOTC ZDOTU Subroutines caxpy CCOPY CGBMV CGEMM CGEMV CGERC CGERU CHBMV CHEMM CHEMV CHER2 CHER2K CHER CHERK CHPMV CHPR2 CHPR CROTG CSCAL CSROT CSSCAL CSWAP CSYMM CSYR2K CSYRK CTBMV CTBSV CTPMV CTPSV CTRMM CTRMV CTRSM CTRSV DAXPY DCOPY DGBMV DGEMM DGEMV DGER DROT DROTG DROTM DROTMG DSBMV DSCAL DSPMV DSPR2 DSPR DSWAP DSYMM DSYMV DSYR2 DSYR2K DSYR DSYRK DTBMV DTBSV DTPMV DTPSV DTRMM DTRMV DTRSM DTRSV SAXPY SCOPY SGBMV SGEMM SGEMV SGER SROT SROTG SROTM SROTMG SSBMV SSCAL SSPMV SSPR2 SSPR SSWAP SSYMM SSYMV SSYR2 SSYR2K SSYR SSYRK STBMV STBSV STPMV STPSV STRMM STRMV STRSM STRSV XERBLA_ARRAY XERBLA ZAXPY ZCOPY ZDROT ZDSCAL ZGBMV ZGEMM ZGEMV ZGERC ZGERU ZHBMV ZHEMM ZHEMV ZHER2 ZHER2K ZHER ZHERK ZHPMV ZHPR2 ZHPR ZROTG ZSCAL ZSWAP ZSYMM ZSYR2K ZSYRK ZTBMV ZTBSV ZTPMV ZTPSV ZTRMM ZTRMV ZTRSM ZTRSV Source Code compatible.f90 Source Code subroutine caxpy ( n , ca , cx , incx , cy , incy ) ! COMMENT --file caxpy.3m_blas.man !> \\brief \\b CAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CAXPY(N,CA,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       COMPLEX CA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CAXPY constant times a vector plus a vector. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CA !> \\verbatim !>          CA is COMPLEX !>           On entry, CA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! ! END use m_blas , only : caxpy_ => caxpy implicit none complex :: ca integer :: incx , incy , n complex :: cx ( * ) complex :: cy ( * ) call caxpy_ ( n , ca , cx , incx , cy , incy ) end subroutine caxpy subroutine CCOPY ( N , CX , INCX , CY , INCY ) ! COMMENT --file ccopy.3m_blas.man !> \\brief \\b CCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CCOPY(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CCOPY copies a vector x to a vector y. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : ccopy_ => CCOPY implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) call CCOPY_ ( N , CX , INCX , CY , INCY ) end subroutine CCOPY COMPLEX FUNCTION CDOTC ( N , CX , INCX , CY , INCY ) ! COMMENT --file cdotc.3m_blas.man !> \\brief \\b CDOTC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX FUNCTION CDOTC(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CDOTC forms the dot product of two complex vectors !>      CDOTC = X&#94;H * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack,  3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : cdotc_ => CDOTC implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) cdotc = CDOTC_ ( N , CX , INCX , CY , INCY ) END FUNCTION CDOTC COMPLEX FUNCTION CDOTU ( N , CX , INCX , CY , INCY ) ! COMMENT --file cdotu.3m_blas.man !> \\brief \\b CDOTU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX FUNCTION CDOTU(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CDOTU forms the dot product of two complex vectors !>      CDOTU = X&#94;T * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : cdotu_ => CDOTU implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) cdotu = CDOTU_ ( N , CX , INCX , CY , INCY ) END FUNCTION CDOTU subroutine CGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file cgbmv.3m_blas.man !> \\brief \\b CGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of CGBMV . ! ! END use M_blas , only : cgbmv_ => CGBMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CGBMV subroutine CGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file cgemm.3m_blas.man !> \\brief \\b CGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**H. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**H. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and  NROWB  as the number of rows of  A  and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**H*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**H + beta*C. ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**H*B**H + beta*C. ! ! !           Form  C := alpha*A**H*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**H + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of CGEMM . ! ! END use M_blas , only : cgemm_ => CGEMM implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CGEMM subroutine CGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file cgemv.3m_blas.man !> \\brief \\b CGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGEMV performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of CGEMV . ! ! END use M_blas , only : cgemv_ => CGEMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CGEMV subroutine CGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cgerc.3m_blas.man !> \\brief \\b CGERC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGERC(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGERC  performs the rank 1 operation !> !>    A := alpha*x*y**H + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of CGERC . ! ! END use M_blas , only : cgerc_ => CGERC implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGERC_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CGERC subroutine CGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cgeru.3m_blas.man !> \\brief \\b CGERU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CGERU(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CGERU  performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of CGERU . ! ! END use M_blas , only : cgeru_ => CGERU implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CGERU_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CGERU subroutine CHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file chbmv.3m_blas.man !> \\brief \\b CHBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of CHBMV . ! ! END use M_blas , only : chbmv_ => CHBMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CHBMV subroutine CHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file chemm.3m_blas.man !> \\brief \\b CHEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHEMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars, A is an hermitian matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  hermitian matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  hermitian  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  hermitian matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  hermitian matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Note that the imaginary parts  of the diagonal elements need !>           not be set, they are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of CHEMM . ! ! END use M_blas , only : chemm_ => CHEMM implicit none COMPLEX ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CHEMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CHEMM subroutine CHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file chemv.3m_blas.man !> \\brief \\b CHEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHEMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHEMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of CHEMV . ! ! END use M_blas , only : chemv_ => CHEMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHEMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine CHEMV subroutine CHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file cher2.3m_blas.man !> \\brief \\b CHER2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of CHER2 . ! ! END use M_blas , only : cher2_ => CHER2 implicit none COMPLEX ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ), Y ( * ) call CHER2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine CHER2 subroutine CHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file cher2k.3m_blas.man !> \\brief \\b CHER2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       REAL BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER2K  performs one of the hermitian rank 2k operations !> !>    C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !> !> where  alpha and beta  are scalars with  beta  real,  C is an  n by n !> hermitian matrix and  A and B  are  n by k matrices in the first case !> and  k by n  matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**H          + !>                                         conjg( alpha )*B*A**H + !>                                         beta*C. !> !>              TRANS = 'C' or 'c'    C := alpha*A**H*B          + !>                                         conjg( alpha )*B**H*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! ! ! !     End of CHER2K. ! ! END use M_blas , only : cher2k_ => CHER2K implicit none COMPLEX ALPHA REAL BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CHER2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CHER2K subroutine CHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file cher.3m_blas.man !> \\brief \\b CHER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHER(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHER   performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of CHER  . ! ! END use M_blas , only : cher_ => CHER implicit none REAL ALPHA INTEGER INCX , LDA , N CHARACTER UPLO COMPLEX A ( LDA , * ), X ( * ) call CHER_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine CHER subroutine CHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file cherk.3m_blas.man !> \\brief \\b CHERK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHERK  performs one of the hermitian rank k operations !> !>    C := alpha*A*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*A + beta*C, !> !> where  alpha and beta  are  real scalars,  C is an  n by n  hermitian !> matrix and  A  is an  n by k  matrix in the  first case and a  k by n !> matrix in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**H + beta*C. ! ! !        Form  C := alpha*A**H*A + beta*C. ! ! ! !     End of CHERK . ! ! END use M_blas , only : cherk_ => CHERK implicit none REAL ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), C ( LDC , * ) call CHERK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine CHERK subroutine CHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file chpmv.3m_blas.man !> \\brief \\b CHPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of CHPMV . ! ! END use M_blas , only : chpmv_ => CHPMV implicit none COMPLEX ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ), Y ( * ) call CHPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine CHPMV subroutine CHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file chpr2.3m_blas.man !> \\brief \\b CHPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPR2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of CHPR2 . ! ! END use M_blas , only : chpr2_ => CHPR2 implicit none COMPLEX ALPHA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ), Y ( * ) call CHPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine CHPR2 subroutine CHPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file chpr.3m_blas.man !> \\brief \\b CHPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CHPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CHPR    performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of CHPR  . ! ! END use M_blas , only : chpr_ => CHPR implicit none REAL ALPHA INTEGER INCX , N CHARACTER UPLO COMPLEX AP ( * ), X ( * ) call CHPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine CHPR subroutine CROTG ( CA , CB , C , S ) ! COMMENT --file crotg.3m_blas.man !> \\brief \\b CROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CROTG(CA,CB,C,S) ! !       .. Scalar Arguments .. !       COMPLEX CA,CB,S !       REAL C !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CROTG determines a complex Givens rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] CA !> \\verbatim !>          CA is COMPLEX !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is COMPLEX !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is COMPLEX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : crotg_ => CROTG implicit none COMPLEX CA , CB , S REAL C call CROTG_ ( CA , CB , C , S ) end subroutine CROTG subroutine CSCAL ( N , CA , CX , INCX ) ! COMMENT --file cscal.3m_blas.man !> \\brief \\b CSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSCAL(N,CA,CX,INCX) ! !       .. Scalar Arguments .. !       COMPLEX CA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CA !> \\verbatim !>          CA is COMPLEX !>           On entry, CA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack,  3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : cscal_ => CSCAL implicit none COMPLEX CA INTEGER INCX , N COMPLEX CX ( * ) call CSCAL_ ( N , CA , CX , INCX ) end subroutine CSCAL subroutine CSROT ( N , CX , INCX , CY , INCY , C , S ) ! COMMENT --file csrot.3m_blas.man !> \\brief \\b CSROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSROT( N, CX, INCX, CY, INCY, C, S ) ! !       .. Scalar Arguments .. !       INTEGER           INCX, INCY, N !       REAL              C, S !       .. !       .. Array Arguments .. !       COMPLEX           CX( * ), CY( * ) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSROT applies a plane rotation, where the cos and sin (c and s) are real !> and the vectors cx and cy are complex. !> jack dongarra, linpack, 3/11/78. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the vectors cx and cy. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCX ) ). !>           Before entry, the incremented array CX must contain the n !>           element vector cx. On exit, CX is overwritten by the updated !>           vector cx. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           CX. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCY ) ). !>           Before entry, the incremented array CY must contain the n !>           element vector cy. On exit, CY is overwritten by the updated !>           vector cy. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           CY. INCY must not be zero. !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is REAL !>           On entry, C specifies the cosine, cos. !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is REAL !>           On entry, S specifies the sine, sin. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Executable Statements .. ! ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments not equal !          to 1 ! ! END use M_blas , only : csrot_ => CSROT implicit none INTEGER INCX , INCY , N REAL C , S COMPLEX CX ( * ), CY ( * ) call CSROT_ ( N , CX , INCX , CY , INCY , C , S ) end subroutine CSROT subroutine CSSCAL ( N , SA , CX , INCX ) ! COMMENT --file csscal.3m_blas.man !> \\brief \\b CSSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSSCAL(N,SA,CX,INCX) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CSSCAL scales a complex vector by a real constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : csscal_ => CSSCAL implicit none REAL SA INTEGER INCX , N COMPLEX CX ( * ) call CSSCAL_ ( N , SA , CX , INCX ) end subroutine CSSCAL subroutine CSWAP ( N , CX , INCX , CY , INCY ) ! COMMENT --file cswap.3m_blas.man !> \\brief \\b CSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSWAP(N,CX,INCX,CY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*),CY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>   CSWAP interchanges two vectors. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim !> !> \\param[in,out] CY !> \\verbatim !>          CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of CY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : cswap_ => CSWAP implicit none INTEGER INCX , INCY , N COMPLEX CX ( * ), CY ( * ) call CSWAP_ ( N , CX , INCX , CY , INCY ) end subroutine CSWAP subroutine CSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file csymm.3m_blas.man !> \\brief \\b CSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where  alpha and beta are scalars, A is a symmetric matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of CSYMM . ! ! END use M_blas , only : csymm_ => CSYMM implicit none COMPLEX ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CSYMM subroutine CSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file csyr2k.3m_blas.man !> \\brief \\b CSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !>                                         beta*C. !> !>              TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of CSYR2K. ! ! END use M_blas , only : csyr2k_ => CSYR2K implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call CSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine CSYR2K subroutine CSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file csyrk.3m_blas.man !> \\brief \\b CSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of CSYRK . ! ! END use M_blas , only : csyrk_ => CSYRK implicit none COMPLEX ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX A ( LDA , * ), C ( LDC , * ) call CSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine CSYRK subroutine CTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ctbmv.3m_blas.man !> \\brief \\b CTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ). !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTBMV . ! ! END use M_blas , only : ctbmv_ => CTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine CTBMV subroutine CTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ctbsv.3m_blas.man !> \\brief \\b CTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTBSV . ! ! END use M_blas , only : ctbsv_ => CTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine CTBSV subroutine CTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ctpmv.3m_blas.man !> \\brief \\b CTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTPMV . ! ! END use M_blas , only : ctpmv_ => CTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX AP ( * ), X ( * ) call CTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine CTPMV subroutine CTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ctpsv.3m_blas.man !> \\brief \\b CTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTPSV . ! ! END use M_blas , only : ctpsv_ => CTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX AP ( * ), X ( * ) call CTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine CTPSV subroutine CTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ctrmm.3m_blas.man !> \\brief \\b CTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ). !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! ! ! !     End of CTRMM . ! ! END use M_blas , only : ctrmm_ => CTRMM implicit none COMPLEX ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ) call CTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine CTRMM subroutine CTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ctrmv.3m_blas.man !> \\brief \\b CTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ). !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of CTRMV . ! ! END use M_blas , only : ctrmv_ => CTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine CTRMV subroutine CTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ctrsm.3m_blas.man !> \\brief \\b CTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! ! ! !     End of CTRSM . ! ! END use M_blas , only : ctrsm_ => CTRSM implicit none COMPLEX ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX A ( LDA , * ), B ( LDB , * ) call CTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine CTRSM subroutine CTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ctrsv.3m_blas.man !> \\brief \\b CTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE CTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> CTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of CTRSV . ! ! END use M_blas , only : ctrsv_ => CTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX A ( LDA , * ), X ( * ) call CTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine CTRSV DOUBLE PRECISION FUNCTION DASUM ( N , DX , INCX ) ! COMMENT --file dasum.3m_blas.man !> \\brief \\b DASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DASUM takes the sum of the absolute values. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dasum_ => DASUM implicit none INTEGER INCX , N DOUBLE PRECISION DX ( * ) dasum = DASUM_ ( N , DX , INCX ) END FUNCTION DASUM subroutine DAXPY ( N , DA , DX , INCX , DY , INCY ) ! COMMENT --file daxpy.3m_blas.man !> \\brief \\b DAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DAXPY constant times a vector plus a vector. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : daxpy_ => DAXPY implicit none DOUBLE PRECISION DA INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DAXPY_ ( N , DA , DX , INCX , DY , INCY ) end subroutine DAXPY DOUBLE PRECISION FUNCTION DCABS1 ( Z ) ! COMMENT --file dcabs1.3m_blas.man !> \\brief \\b DCABS1 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DCABS1(Z) ! !       .. Scalar Arguments .. !       COMPLEX*16 Z !       .. !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DCABS1 computes |Re(.)| + |Im(.)| of a double complex number !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] Z !> \\verbatim !>          Z is COMPLEX*16 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. !  ===================================================================== ! !     .. Intrinsic Functions .. ! ! END use M_blas , only : dcabs1_ => DCABS1 implicit none COMPLEX * 16 Z dcabs1 = DCABS1_ ( Z ) END FUNCTION DCABS1 subroutine DCOPY ( N , DX , INCX , DY , INCY ) ! COMMENT --file dcopy.3m_blas.man !> \\brief \\b DCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DCOPY(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DCOPY copies a vector, x, to a vector, y. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : dcopy_ => DCOPY implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DCOPY_ ( N , DX , INCX , DY , INCY ) end subroutine DCOPY DOUBLE PRECISION FUNCTION DDOT ( N , DX , INCX , DY , INCY ) ! COMMENT --file ddot.3m_blas.man !> \\brief \\b DDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DDOT forms the dot product of two vectors. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : ddot_ => DDOT implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) ddot = DDOT_ ( N , DX , INCX , DY , INCY ) END FUNCTION DDOT subroutine DGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dgbmv.3m_blas.man !> \\brief \\b DGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of DGBMV . ! ! END use M_blas , only : dgbmv_ => DGBMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) END SUBROUTINE DGBMV subroutine DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dgemm.3m_blas.man !> \\brief \\b DGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**T. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**T. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And if  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of DGEMM . ! ! END use M_blas , only : dgemm_ => DGEMM implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DGEMM subroutine DGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dgemv.3m_blas.man !> \\brief \\b DGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of DGEMV . ! ! END use M_blas , only : dgemv_ => DGEMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DGEMV subroutine DGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file dger.3m_blas.man !> \\brief \\b DGER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DGER   performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of DGER  . ! ! END use M_blas , only : dger_ => DGER implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , LDA , M , N DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DGER_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine DGER DOUBLE PRECISION FUNCTION DNRM2 ( N , X , INCX ) ! COMMENT --file dnrm2.3m_blas.man !> \\brief \\b DNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    DNRM2 := sqrt( x'*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to DLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL DLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of DNRM2. ! ! END use M_blas , only : dnrm2_ => DNRM2 implicit none INTEGER INCX , N DOUBLE PRECISION X ( * ) dnrm2 = DNRM2_ ( N , X , INCX ) END FUNCTION DNRM2 subroutine DROT ( N , DX , INCX , DY , INCY , C , S ) ! COMMENT --file drot.3m_blas.man !> \\brief \\b DROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION C,S !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DROT applies a plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is DOUBLE PRECISION !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : drot_ => DROT implicit none DOUBLE PRECISION C , S INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DROT_ ( N , DX , INCX , DY , INCY , C , S ) end subroutine DROT subroutine DROTG ( DA , DB , C , S ) ! COMMENT --file drotg.3m_blas.man !> \\brief \\b DROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTG(DA,DB,C,S) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION C,DA,DB,S !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DROTG construct givens plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] DA !> \\verbatim !>          DA is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DB !> \\verbatim !>          DB is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is DOUBLE PRECISION !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : drotg_ => DROTG implicit none DOUBLE PRECISION C , DA , DB , S call DROTG_ ( DA , DB , C , S ) end subroutine DROTG subroutine DROTM ( N , DX , INCX , DY , INCY , DPARAM ) ! COMMENT --file drotm.3m_blas.man !> \\brief \\b DROTM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTM(N,DX,INCX,DY,INCY,DPARAM) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DPARAM(5),DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX !> !>    (DX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN !>    (DY**T) !> !>    DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE !>    LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY. !>    WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !> !>      (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !>    H=(          )    (          )    (          )    (          ) !>      (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !>    SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim !> !> \\param[in] DPARAM !> \\verbatim !>          DPARAM is DOUBLE PRECISION array, dimension (5) !>     DPARAM(1)=DFLAG !>     DPARAM(2)=DH11 !>     DPARAM(3)=DH21 !>     DPARAM(4)=DH12 !>     DPARAM(5)=DH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Data statements .. !     .. ! ! ! ! END use M_blas , only : drotm_ => DROTM implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DPARAM ( 5 ), DX ( * ), DY ( * ) call DROTM_ ( N , DX , INCX , DY , INCY , DPARAM ) end subroutine DROTM subroutine DROTMG ( DD1 , DD2 , DX1 , DY1 , DPARAM ) ! COMMENT --file drotmg.3m_blas.man !> \\brief \\b DROTMG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DROTMG(DD1,DD2,DX1,DY1,DPARAM) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DD1,DD2,DX1,DY1 !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DPARAM(5) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS !>    THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*>    DY2)**T. !>    WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !> !>      (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !>    H=(          )    (          )    (          )    (          ) !>      (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !>    LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22 !>    RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE !>    VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.) !> !>    THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE !>    INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE !>    OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] DD1 !> \\verbatim !>          DD1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DD2 !> \\verbatim !>          DD2 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in,out] DX1 !> \\verbatim !>          DX1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[in] DY1 !> \\verbatim !>          DY1 is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] DPARAM !> \\verbatim !>          DPARAM is DOUBLE PRECISION array, dimension (5) !>     DPARAM(1)=DFLAG !>     DPARAM(2)=DH11 !>     DPARAM(3)=DH21 !>     DPARAM(4)=DH12 !>     DPARAM(5)=DH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Data statements .. ! !     .. !        GO ZERO-H-D-AND-DX1.. ! !        CASE-DD1-NONNEGATIVE !        REGULAR-CASE.. ! ! ! !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 ! !              GO ZERO-H-D-AND-DX1.. ! !     PROCEDURE..SCALE-CHECK ! END use M_blas , only : drotmg_ => DROTMG implicit none DOUBLE PRECISION DD1 , DD2 , DX1 , DY1 DOUBLE PRECISION DPARAM ( 5 ) call DROTMG_ ( DD1 , DD2 , DX1 , DY1 , DPARAM ) end subroutine DROTMG subroutine DSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dsbmv.3m_blas.man !> \\brief \\b DSBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of DSBMV . ! ! END use M_blas , only : dsbmv_ => DSBMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DSBMV subroutine DSCAL ( N , DA , DX , INCX ) ! COMMENT --file dscal.3m_blas.man !> \\brief \\b DSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSCAL(N,DA,DX,INCX) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DSCAL scales a vector by a constant. !>    uses unrolled loops for increment equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dscal_ => DSCAL implicit none DOUBLE PRECISION DA INTEGER INCX , N DOUBLE PRECISION DX ( * ) call DSCAL_ ( N , DA , DX , INCX ) end subroutine DSCAL DOUBLE PRECISION FUNCTION DSDOT ( N , SX , INCX , SY , INCY ) ! COMMENT --file dsdot.3m_blas.man !> \\brief \\b DSDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DSDOT(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! !    AUTHORS !    ======= !    Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !    Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> Compute the inner product of two vectors with extended !> precision accumulation and result. !> !> Returns D.P. dot product accumulated in D.P., for S.P. SX and SY !> DSDOT = sum for I = 0 to N-1 of  SX(LX+I*INCX) * SY(LY+I*INCY), !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !> defined in a similar way using INCY. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension(N) !>         single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>          storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension(N) !>         single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\result DSDOT !> \\verbatim !>          DSDOT is DOUBLE PRECISION !>         DSDOT  double precision dot product (zero if N.LE.0) !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> \\endverbatim ! !> \\par References: !  ================ !> !> \\verbatim !> !> !>  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !>  Krogh, Basic linear algebra subprograms for Fortran !>  usage, Algorithm No. 539, Transactions on Mathematical !>  Software 5, 3 (September 1979), pp. 308-323. !> !>  REVISION HISTORY  (YYMMDD) !> !>  791001  DATE WRITTEN !>  890831  Modified array declarations.  (WRB) !>  890831  REVISION DATE from Version 3.2 !>  891214  Prologue converted to Version 4.0 format.  (BAB) !>  920310  Corrected definition of LX in DESCRIPTION.  (WRB) !>  920501  Reformatted the REFERENCES section.  (WRB) !>  070118  Reformat to LAPACK style (JL) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  Authors: !  ======== !  Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !  Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Code for equal, positive, non-unit increments. ! ! !     Code for unequal or nonpositive increments. ! ! END use M_blas , only : dsdot_ => DSDOT implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) dsdot = DSDOT_ ( N , SX , INCX , SY , INCY ) END FUNCTION DSDOT subroutine DSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file dspmv.3m_blas.man !> \\brief \\b DSPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of DSPMV . ! ! END use M_blas , only : dspmv_ => DSPMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ), Y ( * ) call DSPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine DSPMV subroutine DSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file dspr2.3m_blas.man !> \\brief \\b DSPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of DSPR2 . ! ! END use M_blas , only : dspr2_ => DSPR2 implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ), Y ( * ) call DSPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine DSPR2 subroutine DSPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file dspr.3m_blas.man !> \\brief \\b DSPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSPR    performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of DSPR  . ! ! END use M_blas , only : dspr_ => DSPR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , N CHARACTER UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DSPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine DSPR subroutine DSWAP ( N , DX , INCX , DY , INCY ) ! COMMENT --file dswap.3m_blas.man !> \\brief \\b DSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSWAP(N,DX,INCX,DY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*),DY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DSWAP interchanges two vectors. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim !> !> \\param[in,out] DY !> \\verbatim !>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of DY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !       code for both increments equal to 1 ! ! !       clean-up loop ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : dswap_ => DSWAP implicit none INTEGER INCX , INCY , N DOUBLE PRECISION DX ( * ), DY ( * ) call DSWAP_ ( N , DX , INCX , DY , INCY ) end subroutine DSWAP subroutine DSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dsymm.3m_blas.man !> \\brief \\b DSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars,  A is a symmetric matrix and  B and !> C are  m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is  n otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of DSYMM . ! ! END use M_blas , only : dsymm_ => DSYMM implicit none DOUBLE PRECISION ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DSYMM subroutine DSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file dsymv.3m_blas.man !> \\brief \\b DSYMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of DSYMV . ! ! END use M_blas , only : dsymv_ => DSYMV implicit none DOUBLE PRECISION ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSYMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine DSYMV subroutine DSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file dsyr2.3m_blas.man !> \\brief \\b DSYR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of DSYR2 . ! ! END use M_blas , only : dsyr2_ => DSYR2 implicit none DOUBLE PRECISION ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ), Y ( * ) call DSYR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine DSYR2 subroutine DSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file dsyr2k.3m_blas.man !> \\brief \\b DSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !>                                        beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrices  A and B.  K must be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of DSYR2K. ! ! END use M_blas , only : dsyr2k_ => DSYR2K implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call DSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine DSYR2K subroutine DSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file dsyr.3m_blas.man !> \\brief \\b DSYR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYR(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYR   performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of DSYR  . ! ! END use M_blas , only : dsyr_ => DSYR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , LDA , N CHARACTER UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DSYR_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine DSYR subroutine DSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file dsyrk.3m_blas.man !> \\brief \\b DSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrix  A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is DOUBLE PRECISION array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of DSYRK . ! ! END use M_blas , only : dsyrk_ => DSYRK implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), C ( LDC , * ) call DSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine DSYRK subroutine DTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file dtbmv.3m_blas.man !> \\brief \\b DTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTBMV . ! ! END use M_blas , only : dtbmv_ => DTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine DTBMV subroutine DTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file dtbsv.3m_blas.man !> \\brief \\b DTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T)*x. ! ! ! !     End of DTBSV . ! ! END use M_blas , only : dtbsv_ => DTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine DTBSV subroutine DTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file dtpmv.3m_blas.man !> \\brief \\b DTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTPMV . ! ! END use M_blas , only : dtpmv_ => DTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine DTPMV subroutine DTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file dtpsv.3m_blas.man !> \\brief \\b DTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is DOUBLE PRECISION array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of DTPSV . ! ! END use M_blas , only : dtpsv_ => DTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION AP ( * ), X ( * ) call DTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine DTPSV subroutine DTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file dtrmm.3m_blas.man !> \\brief \\b DTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>           A is DOUBLE PRECISION array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T. ! ! ! !     End of DTRMM . ! ! END use M_blas , only : dtrmm_ => DTRMM implicit none DOUBLE PRECISION ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ) call DTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine DTRMM subroutine DTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file dtrmv.3m_blas.man !> \\brief \\b DTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of DTRMV . ! ! END use M_blas , only : dtrmv_ => DTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine DTRMV subroutine DTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file dtrsm.3m_blas.man !> \\brief \\b DTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is DOUBLE PRECISION array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ). ! ! ! !     End of DTRSM . ! ! END use M_blas , only : dtrsm_ => DTRSM implicit none DOUBLE PRECISION ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO DOUBLE PRECISION A ( LDA , * ), B ( LDB , * ) call DTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine DTRSM subroutine DTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file dtrsv.3m_blas.man !> \\brief \\b DTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE DTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       DOUBLE PRECISION A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is DOUBLE PRECISION array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is DOUBLE PRECISION array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup double_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of DTRSV . ! ! END use M_blas , only : dtrsv_ => DTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO DOUBLE PRECISION A ( LDA , * ), X ( * ) call DTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine DTRSV DOUBLE PRECISION FUNCTION DZASUM ( N , ZX , INCX ) ! COMMENT --file dzasum.3m_blas.man !> \\brief \\b DZASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DZASUM(N,ZX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !>    returns a double precision result. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : dzasum_ => DZASUM implicit none INTEGER INCX , N COMPLEX * 16 ZX ( * ) dzasum = DZASUM_ ( N , ZX , INCX ) END FUNCTION DZASUM DOUBLE PRECISION FUNCTION DZNRM2 ( N , X , INCX ) ! COMMENT --file dznrm2.3m_blas.man !> \\brief \\b DZNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       DOUBLE PRECISION FUNCTION DZNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> DZNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    DZNRM2 := sqrt( x**H*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension (N) !>         complex vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of X !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup double_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to ZLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL ZLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of DZNRM2. ! ! END use M_blas , only : dznrm2_ => DZNRM2 implicit none INTEGER INCX , N COMPLEX * 16 X ( * ) dznrm2 = DZNRM2_ ( N , X , INCX ) END FUNCTION DZNRM2 INTEGER FUNCTION ICAMAX ( N , CX , INCX ) ! COMMENT --file icamax.3m_blas.man !> \\brief \\b ICAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION ICAMAX(N,CX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of CX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : icamax_ => ICAMAX implicit none INTEGER INCX , N COMPLEX CX ( * ) icamax = ICAMAX_ ( N , CX , INCX ) END FUNCTION ICAMAX INTEGER FUNCTION IDAMAX ( N , DX , INCX ) ! COMMENT --file idamax.3m_blas.man !> \\brief \\b IDAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION IDAMAX(N,DX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       DOUBLE PRECISION DX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    IDAMAX finds the index of the first element having maximum absolute value. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DX !> \\verbatim !>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of DX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : idamax_ => IDAMAX implicit none INTEGER INCX , N DOUBLE PRECISION DX ( * ) idamax = IDAMAX_ ( N , DX , INCX ) END FUNCTION IDAMAX INTEGER FUNCTION ISAMAX ( N , SX , INCX ) ! COMMENT --file isamax.3m_blas.man !> \\brief \\b ISAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION ISAMAX(N,SX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ISAMAX finds the index of the first element having maximum absolute value. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : isamax_ => ISAMAX implicit none INTEGER INCX , N REAL SX ( * ) isamax = ISAMAX_ ( N , SX , INCX ) END FUNCTION ISAMAX INTEGER FUNCTION IZAMAX ( N , ZX , INCX ) ! COMMENT --file izamax.3m_blas.man !> \\brief \\b IZAMAX ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       INTEGER FUNCTION IZAMAX(N,ZX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    IZAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup aux_blas ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 1/15/85. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : izamax_ => IZAMAX implicit none INTEGER INCX , N COMPLEX * 16 ZX ( * ) izamax = IZAMAX_ ( N , ZX , INCX ) END FUNCTION IZAMAX LOGICAL FUNCTION LSAME ( CA , CB ) ! COMMENT --file lsame.3m_blas.man !> \\brief \\b LSAME ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       LOGICAL FUNCTION LSAME(CA,CB) ! !       .. Scalar Arguments .. !       CHARACTER CA,CB !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> LSAME returns .TRUE. if CA is the same letter as CB regardless of !> case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] CA !> \\verbatim !>          CA is CHARACTER*1 !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is CHARACTER*1 !>          CA and CB specify the single characters to be compared. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. ! ! ===================================================================== ! !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. ! !     Test if the characters are equal ! ! !     Now test for equivalence if both characters are alphabetic. ! ! !     Use 'Z' rather than 'A' so that ASCII can be detected on Prime !     machines, on which ICHAR returns a value with bit 8 set. !     ICHAR('A') on Prime machines returns 193 which is the same as !     ICHAR('A') on an EBCDIC machine. ! ! ! !        ASCII is assumed - ZCODE is the ASCII code of either lower or !        upper case 'Z'. ! ! ! !        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or !        upper case 'Z'. ! ! ! !        ASCII is assumed, on Prime machines - ZCODE is the ASCII code !        plus 128 of either lower or upper case 'Z'. ! ! !     RETURN ! !     End of LSAME ! ! END use M_blas , only : lsame_ => LSAME implicit none CHARACTER CA , CB lsame = LSAME_ ( CA , CB ) END FUNCTION LSAME REAL FUNCTION SASUM ( N , SX , INCX ) ! COMMENT --file sasum.3m_blas.man !> \\brief \\b SASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SASUM(N,SX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SASUM takes the sum of the absolute values. !>    uses unrolled loops for increment equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : sasum_ => SASUM implicit none INTEGER INCX , N REAL SX ( * ) sasum = SASUM_ ( N , SX , INCX ) END FUNCTION SASUM subroutine SAXPY ( N , SA , SX , INCX , SY , INCY ) ! COMMENT --file saxpy.3m_blas.man !> \\brief \\b SAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SAXPY constant times a vector plus a vector. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : saxpy_ => SAXPY implicit none REAL SA INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SAXPY_ ( N , SA , SX , INCX , SY , INCY ) end subroutine SAXPY real function scabs1 ( z ) ! COMMENT --file scabs1.3m_blas.man !> \\brief \\b SCABS1 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCABS1(Z) ! !       .. Scalar Arguments .. !       COMPLEX Z !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SCABS1 computes |Re(.)| + |Im(.)| of a complex number !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] Z !> \\verbatim !>          Z is COMPLEX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : scabs1_ => SCAbs1 implicit none complex , intent ( in ) :: z scabs1 = scabs1_ ( z ) end function scabs1 REAL FUNCTION SCASUM ( N , CX , INCX ) ! COMMENT --file scasum.3m_blas.man !> \\brief \\b SCASUM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCASUM(N,CX,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX CX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !>    returns a single precision result. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] CX !> \\verbatim !>          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : scasum_ => SCASUM implicit none INTEGER INCX , N COMPLEX CX ( * ) scasum = SCASUM_ ( N , CX , INCX ) END FUNCTION SCASUM REAL FUNCTION SCNRM2 ( N , X , INCX ) ! COMMENT --file scnrm2.3m_blas.man !> \\brief \\b SCNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SCNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SCNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    SCNRM2 := sqrt( x**H*x ) !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX array, dimension (N) !>         complex vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of X !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to CLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL CLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of SCNRM2. ! ! END use M_blas , only : scnrm2_ => SCNRM2 implicit none INTEGER INCX , N COMPLEX X ( * ) scnrm2 = SCNRM2_ ( N , X , INCX ) END FUNCTION SCNRM2 subroutine SCOPY ( N , SX , INCX , SY , INCY ) ! COMMENT --file scopy.3m_blas.man !> \\brief \\b SCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SCOPY(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SCOPY copies a vector, x, to a vector, y. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : scopy_ => SCOPY implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SCOPY_ ( N , SX , INCX , SY , INCY ) end subroutine SCOPY REAL FUNCTION SDOT ( N , SX , INCX , SY , INCY ) ! COMMENT --file sdot.3m_blas.man !> \\brief \\b SDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SDOT(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SDOT forms the dot product of two vectors. !>    uses unrolled loops for increments equal to one. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        clean-up loop ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : sdot_ => SDOT implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) sdot = SDOT_ ( N , SX , INCX , SY , INCY ) END FUNCTION SDOT REAL FUNCTION SDSDOT ( N , SB , SX , INCX , SY , INCY ) ! COMMENT --file sdsdot.3m_blas.man !> \\brief \\b SDSDOT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SDSDOT(N,SB,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       REAL SB !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>   Compute the inner product of two vectors with extended !>   precision accumulation. !> !>   Returns S.P. result with dot product accumulated in D.P. !>   SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I*INCX)*SY(LY+I*INCY), !>   where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !>   defined in a similar way using INCY. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>          number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SB !> \\verbatim !>          SB is REAL !>          single precision scalar to be added to inner product !> \\endverbatim !> !> \\param[in] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !>          single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>          storage spacing between elements of SX !> \\endverbatim !> !> \\param[in] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !>          single precision vector with N elements !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>          storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !> \\author Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>    REFERENCES !> !>    C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !>    Krogh, Basic linear algebra subprograms for Fortran !>    usage, Algorithm No. 539, Transactions on Mathematical !>    Software 5, 3 (September 1979), pp. 308-323. !> !>    REVISION HISTORY  (YYMMDD) !> !>    791001  DATE WRITTEN !>    890531  Changed all specific intrinsics to generic.  (WRB) !>    890831  Modified array declarations.  (WRB) !>    890831  REVISION DATE from Version 3.2 !>    891214  Prologue converted to Version 4.0 format.  (BAB) !>    920310  Corrected definition of LX in DESCRIPTION.  (WRB) !>    920501  Reformatted the REFERENCES section.  (WRB) !>    070118  Reformat to LAPACK coding style !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Code for equal and positive increments. ! ! !     Code for unequal or nonpositive increments. ! ! END use M_blas , only : sdsdot_ => SDSDOT implicit none REAL SB INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) sdsdot = SDSDOT_ ( N , SB , SX , INCX , SY , INCY ) END FUNCTION SDSDOT subroutine SGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file sgbmv.3m_blas.man !> \\brief \\b SGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of SGBMV . ! ! END use M_blas , only : sgbmv_ => SGBMV implicit none CHARACTER ( len = 1 ), intent ( in ) :: TRANS REAL ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N REAL A ( LDA , * ), X ( * ), Y ( * ) call SGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SGBMV subroutine SGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file sgemm.3m_blas.man !> \\brief \\b SGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**T. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**T. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And if  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of SGEMM . ! ! END use M_blas , only : sgemm_ => SGEMM implicit none REAL ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SGEMM subroutine SGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file sgemv.3m_blas.man !> \\brief \\b SGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y. ! ! ! !     End of SGEMV . ! ! END use M_blas , only : sgemv_ => SGEMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS REAL A ( LDA , * ), X ( * ), Y ( * ) call SGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SGEMV subroutine SGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file sger.3m_blas.man !> \\brief \\b SGER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SGER   performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of SGER  . ! ! END use M_blas , only : sger_ => SGER implicit none REAL ALPHA INTEGER INCX , INCY , LDA , M , N REAL A ( LDA , * ), X ( * ), Y ( * ) call SGER_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine SGER REAL FUNCTION SNRM2 ( N , X , INCX ) ! COMMENT --file snrm2.3m_blas.man !> \\brief \\b SNRM2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       REAL FUNCTION SNRM2(N,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SNRM2 returns the euclidean norm of a vector via the function !> name, so that !> !>    SNRM2 := sqrt( x'*x ). !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  -- This version written on 25-October-1982. !>     Modified on 14-October-1993 to inline the call to SLASSQ. !>     Sven Hammarling, Nag Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !        The following loop is equivalent to this call to the LAPACK !        auxiliary routine: !        CALL SLASSQ( N, X, INCX, SCALE, SSQ ) ! ! ! !     End of SNRM2. ! ! END use M_blas , only : snrm2_ => SNRM2 implicit none INTEGER INCX , N REAL X ( * ) snrm2 = SNRM2_ ( N , X , INCX ) END FUNCTION SNRM2 subroutine SROT ( N , SX , INCX , SY , INCY , C , S ) ! COMMENT --file srot.3m_blas.man !> \\brief \\b SROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROT(N,SX,INCX,SY,INCY,C,S) ! !       .. Scalar Arguments .. !       REAL C,S !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    applies a plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is REAL !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : srot_ => SROT implicit none REAL C , S INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SROT_ ( N , SX , INCX , SY , INCY , C , S ) end subroutine SROT subroutine SROTG ( SA , SB , C , S ) ! COMMENT --file srotg.3m_blas.man !> \\brief \\b SROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTG(SA,SB,C,S) ! !       .. Scalar Arguments .. !       REAL C,S,SA,SB !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SROTG construct givens plane rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] SA !> \\verbatim !>          SA is REAL !> \\endverbatim !> !> \\param[in,out] SB !> \\verbatim !>          SB is REAL !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is REAL !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is REAL !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : srotg_ => SROTG implicit none REAL C , S , SA , SB call SROTG_ ( SA , SB , C , S ) end subroutine SROTG subroutine SROTM ( N , SX , INCX , SY , INCY , SPARAM ) ! COMMENT --file srotm.3m_blas.man !> \\brief \\b SROTM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTM(N,SX,INCX,SY,INCY,SPARAM) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SPARAM(5),SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX !> !>    (SX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN !>    (SX**T) !> !>    SX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE !>    LX = (-INCX)*N, AND SIMILARLY FOR SY USING USING LY AND INCY. !>    WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !> !>      (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !>    H=(          )    (          )    (          )    (          ) !>      (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !>    SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim !> !> \\param[in] SPARAM !> \\verbatim !>          SPARAM is REAL array, dimension (5) !>     SPARAM(1)=SFLAG !>     SPARAM(2)=SH11 !>     SPARAM(3)=SH21 !>     SPARAM(4)=SH12 !>     SPARAM(5)=SH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Data statements .. !     .. ! ! ! ! END use M_blas , only : srotm_ => SROTM implicit none INTEGER INCX , INCY , N REAL SPARAM ( 5 ), SX ( * ), SY ( * ) call SROTM_ ( N , SX , INCX , SY , INCY , SPARAM ) end subroutine SROTM subroutine SROTMG ( SD1 , SD2 , SX1 , SY1 , SPARAM ) ! COMMENT --file srotmg.3m_blas.man !> \\brief \\b SROTMG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SROTMG(SD1,SD2,SX1,SY1,SPARAM) ! !       .. Scalar Arguments .. !       REAL SD1,SD2,SX1,SY1 !       .. !       .. Array Arguments .. !       REAL SPARAM(5) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS !>    THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(SD1)*SX1,SQRT(SD2)*>    SY2)**T. !>    WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !> !>    SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !> !>      (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !>    H=(          )    (          )    (          )    (          ) !>      (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !>    LOCATIONS 2-4 OF SPARAM CONTAIN SH11,SH21,SH12, AND SH22 !>    RESPECTIVELY. (VALUES OF 1.E0, -1.E0, OR 0.E0 IMPLIED BY THE !>    VALUE OF SPARAM(1) ARE NOT STORED IN SPARAM.) !> !>    THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE !>    INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE !>    OF SD1 AND SD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM. !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] SD1 !> \\verbatim !>          SD1 is REAL !> \\endverbatim !> !> \\param[in,out] SD2 !> \\verbatim !>          SD2 is REAL !> \\endverbatim !> !> \\param[in,out] SX1 !> \\verbatim !>          SX1 is REAL !> \\endverbatim !> !> \\param[in] SY1 !> \\verbatim !>          SY1 is REAL !> \\endverbatim !> !> \\param[out] SPARAM !> \\verbatim !>          SPARAM is REAL array, dimension (5) !>     SPARAM(1)=SFLAG !>     SPARAM(2)=SH11 !>     SPARAM(3)=SH21 !>     SPARAM(4)=SH12 !>     SPARAM(5)=SH22 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Data statements .. ! !     .. !        GO ZERO-H-D-AND-SX1.. ! !        CASE-SD1-NONNEGATIVE !        REGULAR-CASE.. ! ! ! !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 ! !              GO ZERO-H-D-AND-SX1.. ! !     PROCEDURE..SCALE-CHECK ! END use M_blas , only : srotmg_ => SROTMG implicit none REAL SD1 , SD2 , SX1 , SY1 REAL SPARAM ( 5 ) call SROTMG_ ( SD1 , SD2 , SX1 , SY1 , SPARAM ) end subroutine SROTMG subroutine SSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file ssbmv.3m_blas.man !> \\brief \\b SSBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the symmetric matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a symmetric band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of SSBMV . ! ! END use M_blas , only : ssbmv_ => SSBMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SSBMV subroutine SSCAL ( N , SA , SX , INCX ) ! COMMENT --file sscal.3m_blas.man !> \\brief \\b SSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSCAL(N,SA,SX,INCX) ! !       .. Scalar Arguments .. !       REAL SA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       REAL SX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SSCAL scales a vector by a constant. !>    uses unrolled loops for increment equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] SA !> \\verbatim !>          SA is REAL !>           On entry, SA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        clean-up loop ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : sscal_ => SSCAL implicit none REAL SA INTEGER INCX , N REAL SX ( * ) call SSCAL_ ( N , SA , SX , INCX ) end subroutine SSCAL subroutine SSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file sspmv.3m_blas.man !> \\brief \\b SSPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of SSPMV . ! ! END use M_blas , only : sspmv_ => SSPMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO REAL AP ( * ), X ( * ), Y ( * ) call SSPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine SSPMV subroutine SSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file sspr2.3m_blas.man !> \\brief \\b SSPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of SSPR2 . ! ! END use M_blas , only : sspr2_ => SSPR2 implicit none REAL ALPHA INTEGER INCX , INCY , N CHARACTER UPLO REAL AP ( * ), X ( * ), Y ( * ) call SSPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine SSPR2 subroutine SSPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file sspr.3m_blas.man !> \\brief \\b SSPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSPR    performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the symmetric matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of SSPR  . ! ! END use M_blas , only : sspr_ => SSPR implicit none REAL ALPHA INTEGER INCX , N CHARACTER UPLO REAL AP ( * ), X ( * ) call SSPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine SSPR subroutine SSWAP ( N , SX , INCX , SY , INCY ) ! COMMENT --file sswap.3m_blas.man !> \\brief \\b SSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSWAP(N,SX,INCX,SY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       REAL SX(*),SY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    SSWAP interchanges two vectors. !>    uses unrolled loops for increments equal to 1. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] SX !> \\verbatim !>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of SX !> \\endverbatim !> !> \\param[in,out] SY !> \\verbatim !>          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of SY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup single_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !       code for both increments equal to 1 ! ! !       clean-up loop ! ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : sswap_ => SSWAP implicit none INTEGER INCX , INCY , N REAL SX ( * ), SY ( * ) call SSWAP_ ( N , SX , INCX , SY , INCY ) end subroutine SSWAP subroutine SSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file ssymm.3m_blas.man !> \\brief \\b SSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars,  A is a symmetric matrix and  B and !> C are  m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is  n otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of SSYMM . ! ! END use M_blas , only : ssymm_ => SSYMM implicit none REAL ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SSYMM subroutine SSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file ssymv.3m_blas.man !> \\brief \\b SSYMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of SSYMV . ! ! END use M_blas , only : ssymv_ => SSYMV implicit none REAL ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSYMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine SSYMV subroutine SSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file ssyr2.3m_blas.man !> \\brief \\b SSYR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR2  performs the symmetric rank 2 operation !> !>    A := alpha*x*y**T + alpha*y*x**T + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of SSYR2 . ! ! END use M_blas , only : ssyr2_ => SSYR2 implicit none REAL ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ), Y ( * ) call SSYR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine SSYR2 subroutine SSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file ssyr2k.3m_blas.man !> \\brief \\b SSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !>                                        beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !>                                        beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrices  A and B.  K must be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is REAL array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of SSYR2K. ! ! END use M_blas , only : ssyr2k_ => SSYR2K implicit none REAL ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO REAL A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call SSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine SSYR2K subroutine SSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file ssyr.3m_blas.man !> \\brief \\b SSYR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYR(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYR   performs the symmetric rank 1 operation !> !>    A := alpha*x*x**T + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n symmetric matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the symmetric matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the symmetric matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of SSYR  . ! ! END use M_blas , only : ssyr_ => SSYR implicit none REAL ALPHA INTEGER INCX , LDA , N CHARACTER UPLO REAL A ( LDA , * ), X ( * ) call SSYR_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine SSYR subroutine SSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file ssyrk.3m_blas.man !> \\brief \\b SSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE SSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       REAL ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> SSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number !>           of rows of the matrix  A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is REAL !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is REAL array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of SSYRK . ! ! END use M_blas , only : ssyrk_ => SSYRK implicit none REAL ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO REAL A ( LDA , * ), C ( LDC , * ) call SSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine SSYRK subroutine STBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file stbmv.3m_blas.man !> \\brief \\b STBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STBMV . ! ! END use M_blas , only : stbmv_ => STBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine STBMV subroutine STBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file stbsv.3m_blas.man !> \\brief \\b STBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T)*x. ! ! ! !     End of STBSV . ! ! END use M_blas , only : stbsv_ => STBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine STBSV subroutine STPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file stpmv.3m_blas.man !> \\brief \\b STPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STPMV . ! ! END use M_blas , only : stpmv_ => STPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO REAL AP ( * ), X ( * ) call STPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine STPMV subroutine STPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file stpsv.3m_blas.man !> \\brief \\b STPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is REAL array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of STPSV . ! ! END use M_blas , only : stpsv_ => STPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO REAL AP ( * ), X ( * ) call STPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine STPSV subroutine STRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file strmm.3m_blas.man !> \\brief \\b STRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T. ! ! ! !     End of STRMM . ! ! END use M_blas , only : strmm_ => STRMM implicit none REAL ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO REAL A ( LDA , * ), B ( LDB , * ) call STRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine STRMM subroutine STRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file strmv.3m_blas.man !> \\brief \\b STRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**T*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x. ! ! ! !     End of STRMV . ! ! END use M_blas , only : strmv_ => STRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine STRMV subroutine STRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file strsm.3m_blas.man !> \\brief \\b STRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       REAL ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**T. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is REAL !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is REAL array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ). ! ! ! !     End of STRSM . ! ! END use M_blas , only : strsm_ => STRSM implicit none REAL ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO REAL A ( LDA , * ), B ( LDB , * ) call STRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine STRSM subroutine STRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file strsv.3m_blas.man !> \\brief \\b STRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE STRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       REAL A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> STRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**T*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is REAL array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is REAL array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup single_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x. ! ! ! !     End of STRSV . ! ! END use M_blas , only : strsv_ => STRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO REAL A ( LDA , * ), X ( * ) call STRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine STRSV subroutine XERBLA_ARRAY ( SRNAME_ARRAY , SRNAME_LEN , INFO ) ! COMMENT --file xerbla_array.3m_blas.man !> \\brief \\b XERBLA_ARRAY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE XERBLA_ARRAY(SRNAME_ARRAY, SRNAME_LEN, INFO) ! !       .. Scalar Arguments .. !       INTEGER SRNAME_LEN, INFO !       .. !       .. Array Arguments .. !       CHARACTER(*) SRNAME_ARRAY(SRNAME_LEN) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK !> and BLAS error handler.  Rather than taking a Fortran string argument !> as the function's name, XERBLA_ARRAY takes an array of single !> characters along with the array's length.  XERBLA_ARRAY then copies !> up to 32 characters of that array into a Fortran string and passes !> that to XERBLA.  If called with a non-positive SRNAME_LEN, !> XERBLA_ARRAY will call XERBLA with a string of all blank characters. !> !> Say some macro or other device makes XERBLA_ARRAY available to C99 !> by a name lapack_xerbla and with a common Fortran calling convention. !> Then a C99 program could invoke XERBLA via: !>    { !>      int flen = strlen(__func__); !>      lapack_xerbla(__func__, &flen, &info); !>    } !> !> Providing XERBLA_ARRAY is not necessary for intercepting LAPACK !> errors.  XERBLA_ARRAY calls XERBLA. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SRNAME_ARRAY !> \\verbatim !>          SRNAME_ARRAY is CHARACTER(*) array, dimension (SRNAME_LEN) !>          The name of the routine which called XERBLA_ARRAY. !> \\endverbatim !> !> \\param[in] SRNAME_LEN !> \\verbatim !>          SRNAME_LEN is INTEGER !>          The length of the name in SRNAME_ARRAY. !> \\endverbatim !> !> \\param[in] INFO !> \\verbatim !>          INFO is INTEGER !>          The position of the invalid parameter in the parameter list !>          of the calling routine. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! ! ===================================================================== ! !     .. !     .. Local Scalars .. !     .. !     .. Local Arrays .. !     .. !     .. Intrinsic Functions .. !     .. !     .. External Functions .. !     .. !     .. Executable Statements .. ! END use M_blas , only : xerbla_array_ => XERBLA_ARRAY implicit none INTEGER SRNAME_LEN , INFO CHARACTER ( len = 1 ) SRNAME_ARRAY ( SRNAME_LEN ) call XERBLA_ARRAY_ ( SRNAME_ARRAY , SRNAME_LEN , INFO ) end subroutine XERBLA_ARRAY subroutine XERBLA ( SRNAME , INFO ) ! COMMENT --file xerbla.3m_blas.man !> \\brief \\b XERBLA ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE XERBLA( SRNAME, INFO ) ! !       .. Scalar Arguments .. !       CHARACTER*(*)      SRNAME !       INTEGER            INFO !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> XERBLA  is an error handler for the LAPACK routines. !> It is called by an LAPACK routine if an input parameter has an !> invalid value.  A message is printed and execution stops. !> !> Installers may consider modifying the STOP statement in order to !> call system-specific exception-handling facilities. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SRNAME !> \\verbatim !>          SRNAME is CHARACTER*(*) !>          The name of the routine which called XERBLA. !> \\endverbatim !> !> \\param[in] INFO !> \\verbatim !>          INFO is INTEGER !>          The position of the invalid parameter in the parameter list !>          of the calling routine. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup aux_blas ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. ! ! ===================================================================== ! !     .. Intrinsic Functions .. !     .. !     .. Executable Statements .. ! ! ! ! !     End of XERBLA ! ! END use M_blas , only : xerbla_ => XERBLA implicit none CHARACTER ( len =* ), intent ( in ) :: SRNAME INTEGER , intent ( in ) :: INFO call XERBLA_ ( SRNAME , INFO ) END SUBROUTINE XERBLA subroutine ZAXPY ( N , ZA , ZX , INCX , ZY , INCY ) ! COMMENT --file zaxpy.3m_blas.man !> \\brief \\b ZAXPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZAXPY(N,ZA,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ZA !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZAXPY constant times a vector plus a vector. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZA !> \\verbatim !>          ZA is COMPLEX*16 !>           On entry, ZA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! ! END use M_blas , only : zaxpy_ => ZAXPY implicit none COMPLEX * 16 ZA INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZAXPY_ ( N , ZA , ZX , INCX , ZY , INCY ) end subroutine ZAXPY subroutine ZCOPY ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zcopy.3m_blas.man !> \\brief \\b ZCOPY ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZCOPY(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZCOPY copies a vector, x, to a vector, y. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, linpack, 4/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zcopy_ => ZCOPY implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZCOPY_ ( N , ZX , INCX , ZY , INCY ) end subroutine ZCOPY COMPLEX * 16 FUNCTION ZDOTC ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zdotc.3m_blas.man !> \\brief \\b ZDOTC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX*16 FUNCTION ZDOTC(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZDOTC forms the dot product of two complex vectors !>      ZDOTC = X&#94;H * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zdotc_ => ZDOTC implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) zdotc = ZDOTC_ ( N , ZX , INCX , ZY , INCY ) END FUNCTION ZDOTC COMPLEX * 16 FUNCTION ZDOTU ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zdotu.3m_blas.man !> \\brief \\b ZDOTU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       COMPLEX*16 FUNCTION ZDOTU(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZDOTU forms the dot product of two complex vectors !>      ZDOTU = X&#94;T * Y !> !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments !          not equal to 1 ! ! END use M_blas , only : zdotu_ => ZDOTU implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) zdotu = ZDOTU_ ( N , ZX , INCX , ZY , INCY ) END FUNCTION ZDOTU subroutine ZDROT ( N , ZX , INCX , ZY , INCY , C , S ) ! COMMENT --file zdrot.3m_blas.man !> \\brief \\b ZDROT ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZDROT( N, ZX, INCX, ZY, INCY, C, S ) ! !       .. Scalar Arguments .. !       INTEGER            INCX, INCY, N !       DOUBLE PRECISION   C, S !       .. !       .. Array Arguments .. !       COMPLEX*16         ZX( * ), ZY( * ) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> Applies a plane rotation, where the cos and sin (c and s) are real !> and the vectors cx and cy are complex. !> jack dongarra, linpack, 3/11/78. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the vectors cx and cy. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCX ) ). !>           Before entry, the incremented array ZX must contain the n !>           element vector cx. On exit, ZX is overwritten by the updated !>           vector cx. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           ZX. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension at least !>           ( 1 + ( N - 1 )*abs( INCY ) ). !>           Before entry, the incremented array ZY must contain the n !>           element vector cy. On exit, ZY is overwritten by the updated !>           vector cy. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           ZY. INCY must not be zero. !> \\endverbatim !> !> \\param[in] C !> \\verbatim !>          C is DOUBLE PRECISION !>           On entry, C specifies the cosine, cos. !> \\endverbatim !> !> \\param[in] S !> \\verbatim !>          S is DOUBLE PRECISION !>           On entry, S specifies the sine, sin. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! ! ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Executable Statements .. ! ! !        code for both increments equal to 1 ! ! !        code for unequal increments or equal increments not equal !          to 1 ! ! END use M_blas , only : zdrot_ => ZDROT implicit none INTEGER INCX , INCY , N DOUBLE PRECISION C , S COMPLEX * 16 ZX ( * ), ZY ( * ) call ZDROT_ ( N , ZX , INCX , ZY , INCY , C , S ) end subroutine ZDROT subroutine ZDSCAL ( N , DA , ZX , INCX ) ! COMMENT --file zdscal.3m_blas.man !> \\brief \\b ZDSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZDSCAL(N,DA,ZX,INCX) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION DA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZDSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] DA !> \\verbatim !>          DA is DOUBLE PRECISION !>           On entry, DA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : zdscal_ => ZDSCAL implicit none DOUBLE PRECISION DA INTEGER INCX , N COMPLEX * 16 ZX ( * ) call ZDSCAL_ ( N , DA , ZX , INCX ) end subroutine ZDSCAL subroutine ZGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zgbmv.3m_blas.man !> \\brief \\b ZGBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,KL,KU,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGBMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n band matrix, with kl sub-diagonals and ku super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] KL !> \\verbatim !>          KL is INTEGER !>           On entry, KL specifies the number of sub-diagonals of the !>           matrix A. KL must satisfy  0 .le. KL. !> \\endverbatim !> !> \\param[in] KU !> \\verbatim !>          KU is INTEGER !>           On entry, KU specifies the number of super-diagonals of the !>           matrix A. KU must satisfy  0 .le. KU. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading ( kl + ku + 1 ) by n part of the !>           array A must contain the matrix of coefficients, supplied !>           column by column, with the leading diagonal of the matrix in !>           row ( ku + 1 ) of the array, the first super-diagonal !>           starting at position 2 in row ku, the first sub-diagonal !>           starting at position 1 in row ( ku + 2 ), and so on. !>           Elements in the array A that do not correspond to elements !>           in the band matrix (such as the top left ku by ku triangle) !>           are not referenced. !>           The following program segment will transfer a band matrix !>           from conventional full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    K = KU + 1 - J !>                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !>                       A( K + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( kl + ku + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of ZGBMV . ! ! END use M_blas , only : zgbmv_ => ZGBMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , KL , KU , LDA , M , N CHARACTER TRANS COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGBMV_ ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZGBMV subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zgemm.3m_blas.man !> \\brief \\b ZGEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,M,N !       CHARACTER TRANSA,TRANSB !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGEMM  performs one of the matrix-matrix operations !> !>    C := alpha*op( A )*op( B ) + beta*C, !> !> where  op( X ) is one of !> !>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !> !> alpha and beta are scalars, and A, B and C are matrices, with op( A ) !> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n',  op( A ) = A. !> !>              TRANSA = 'T' or 't',  op( A ) = A**T. !> !>              TRANSA = 'C' or 'c',  op( A ) = A**H. !> \\endverbatim !> !> \\param[in] TRANSB !> \\verbatim !>          TRANSB is CHARACTER*1 !>           On entry, TRANSB specifies the form of op( B ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSB = 'N' or 'n',  op( B ) = B. !> !>              TRANSB = 'T' or 't',  op( B ) = B**T. !> !>              TRANSB = 'C' or 'c',  op( B ) = B**H. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies  the number  of rows  of the  matrix !>           op( A )  and of the  matrix  C.  M  must  be at least  zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N  specifies the number  of columns of the matrix !>           op( B ) and the number of columns of the matrix C. N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry,  K  specifies  the number of columns of the matrix !>           op( A ) and the number of rows of the matrix op( B ). K must !>           be at least  zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. !>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by m  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. !>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  n by k  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then !>           LDB must be at least  max( 1, k ), otherwise  LDB must be at !>           least  max( 1, n ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n  matrix !>           ( alpha*op( A )*op( B ) + beta*C ). !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and NROWB  as the number of rows  of  A  and  B  respectively. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  C := alpha*A*B + beta*C. ! ! !           Form  C := alpha*A**H*B + beta*C. ! ! !           Form  C := alpha*A**T*B + beta*C ! ! !           Form  C := alpha*A*B**H + beta*C. ! ! !           Form  C := alpha*A*B**T + beta*C ! ! !           Form  C := alpha*A**H*B**H + beta*C. ! ! !           Form  C := alpha*A**H*B**T + beta*C ! ! !           Form  C := alpha*A**T*B**H + beta*C ! ! !           Form  C := alpha*A**T*B**T + beta*C ! ! ! !     End of ZGEMM . ! ! END use M_blas , only : zgemm_ => ZGEMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDB , LDC , M , N CHARACTER TRANSA , TRANSB COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZGEMM_ ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZGEMM subroutine ZGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zgemv.3m_blas.man !> \\brief \\b ZGEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,LDA,M,N !       CHARACTER TRANS !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGEMV  performs one of the matrix-vector operations !> !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !> !>    y := alpha*A**H*x + beta*y, !> !> where alpha and beta are scalars, x and y are vectors and A is an !> m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !> !>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !> !>              TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !>           and at least !>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !>           Before entry with BETA non-zero, the incremented array Y !>           must contain the vector y. On exit, Y is overwritten by the !>           updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y := alpha*A*x + y. ! ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! ! ! !     End of ZGEMV . ! ! END use M_blas , only : zgemv_ => ZGEMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , LDA , M , N CHARACTER TRANS COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGEMV_ ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZGEMV subroutine ZGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zgerc.3m_blas.man !> \\brief \\b ZGERC ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGERC(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGERC  performs the rank 1 operation !> !>    A := alpha*x*y**H + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of ZGERC . ! ! END use M_blas , only : zgerc_ => ZGERC implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGERC_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZGERC subroutine ZGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zgeru.3m_blas.man !> \\brief \\b ZGERU ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZGERU(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,M,N !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZGERU  performs the rank 1 operation !> !>    A := alpha*x*y**T + A, !> !> where alpha is a scalar, x is an m element vector, y is an n element !> vector and A is an m by n matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of the matrix A. !>           M must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( m - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the m !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry, the leading m by n part of the array A must !>           contain the matrix of coefficients. On exit, A is !>           overwritten by the updated matrix. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! ! !     End of ZGERU . ! ! END use M_blas , only : zgeru_ => ZGERU implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , M , N COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZGERU_ ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZGERU subroutine ZHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhbmv.3m_blas.man !> \\brief \\b ZHBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,K,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHBMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian band matrix, with k super-diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the band matrix A is being supplied as !>           follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  being supplied. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  being supplied. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry, K specifies the number of super-diagonals of the !>           matrix A. K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer the upper !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the hermitian matrix, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer the lower !>           triangular part of a hermitian band matrix from conventional !>           full matrix storage to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the !>           vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the !>           vector y. On exit, Y is overwritten by the updated vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! ! !        Form  y  when upper triangle of A is stored. ! ! !        Form  y  when lower triangle of A is stored. ! ! ! !     End of ZHBMV . ! ! END use M_blas , only : zhbmv_ => ZHBMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , K , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHBMV_ ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZHBMV subroutine ZHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zhemm.3m_blas.man !> \\brief \\b ZHEMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHEMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where alpha and beta are scalars, A is an hermitian matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  hermitian matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  hermitian  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  hermitian matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  hermitian matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  hermitian matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  hermitian matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  hermitian !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Note that the imaginary parts  of the diagonal elements need !>           not be set, they are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of ZHEMM . ! ! END use M_blas , only : zhemm_ => ZHEMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZHEMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZHEMM subroutine ZHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhemv.3m_blas.man !> \\brief \\b ZHEMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHEMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHEMV  performs the matrix-vector  operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! ! !        Form  y  when A is stored in upper triangle. ! ! !        Form  y  when A is stored in lower triangle. ! ! ! !     End of ZHEMV . ! ! END use M_blas , only : zhemv_ => ZHEMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHEMV_ ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) end subroutine ZHEMV subroutine ZHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) ! COMMENT --file zher2.3m_blas.man !> \\brief \\b ZHER2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an n !> by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in the upper triangle. ! ! !        Form  A  when A is stored in the lower triangle. ! ! ! !     End of ZHER2 . ! ! END use M_blas , only : zher2_ => ZHER2 implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ), Y ( * ) call ZHER2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) end subroutine ZHER2 subroutine ZHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zher2k.3m_blas.man !> \\brief \\b ZHER2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       DOUBLE PRECISION BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER2K  performs one of the hermitian rank 2k operations !> !>    C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !> !> where  alpha and beta  are scalars with  beta  real,  C is an  n by n !> hermitian matrix and  A and B  are  n by k matrices in the first case !> and  k by n  matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**H          + !>                                         conjg( alpha )*B*A**H + !>                                         beta*C. !> !>              TRANS = 'C' or 'c'    C := alpha*A**H*B          + !>                                         conjg( alpha )*B**H*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 . !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !>           Unchanged on exit. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION . !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! ! ! !     End of ZHER2K. ! ! END use M_blas , only : zher2k_ => ZHER2K implicit none COMPLEX * 16 ALPHA DOUBLE PRECISION BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZHER2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZHER2K subroutine ZHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) ! COMMENT --file zher.3m_blas.man !> \\brief \\b ZHER ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHER(UPLO,N,ALPHA,X,INCX,A,LDA) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,LDA,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHER   performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the array A is to be referenced as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of A !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of A !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular part of the hermitian matrix and the strictly !>           lower triangular part of A is not referenced. On exit, the !>           upper triangular part of the array A is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular part of the hermitian matrix and the strictly !>           upper triangular part of A is not referenced. On exit, the !>           lower triangular part of the array A is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! ! !        Form  A  when A is stored in upper triangle. ! ! !        Form  A  when A is stored in lower triangle. ! ! ! !     End of ZHER  . ! ! END use M_blas , only : zher_ => ZHER implicit none DOUBLE PRECISION ALPHA INTEGER INCX , LDA , N CHARACTER UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZHER_ ( UPLO , N , ALPHA , X , INCX , A , LDA ) end subroutine ZHER subroutine ZHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file zherk.3m_blas.man !> \\brief \\b ZHERK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHERK  performs one of the hermitian rank k operations !> !>    C := alpha*A*A**H + beta*C, !> !> or !> !>    C := alpha*A**H*A + beta*C, !> !> where  alpha and beta  are  real scalars,  C is an  n by n  hermitian !> matrix and  A  is an  n by k  matrix in the  first case and a  k by n !> matrix in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !> !>              TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'C' or 'c',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION . !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is DOUBLE PRECISION. !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  hermitian matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  hermitian matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set,  they are assumed to be zero,  and on exit they !>           are set to zero. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> !>  -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !>     Ed Anderson, Cray Research Inc. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**H + beta*C. ! ! !        Form  C := alpha*A**H*A + beta*C. ! ! ! !     End of ZHERK . ! ! END use M_blas , only : zherk_ => ZHERK implicit none DOUBLE PRECISION ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), C ( LDC , * ) call ZHERK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine ZHERK subroutine ZHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) ! COMMENT --file zhpmv.3m_blas.man !> \\brief \\b ZHPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPMV  performs the matrix-vector operation !> !>    y := alpha*A*x + beta*y, !> !> where alpha and beta are scalars, x and y are n element vectors and !> A is an n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. !>           Note that the imaginary parts of the diagonal elements need !>           not be set and are assumed to be zero. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. When BETA is !>           supplied as zero then Y need not be set on input. !> \\endverbatim !> !> \\param[in,out] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. On exit, Y is overwritten by the updated !>           vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in  X  and  Y. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! ! !        Form  y  when AP contains the upper triangle. ! ! !        Form  y  when AP contains the lower triangle. ! ! ! !     End of ZHPMV . ! ! END use M_blas , only : zhpmv_ => ZHPMV implicit none COMPLEX * 16 ALPHA , BETA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ), Y ( * ) call ZHPMV_ ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) end subroutine ZHPMV subroutine ZHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) ! COMMENT --file zhpr2.3m_blas.man !> \\brief \\b ZHPR2 ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER INCX,INCY,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*),Y(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPR2  performs the hermitian rank 2 operation !> !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !> !> where alpha is a scalar, x and y are n element vectors and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in] Y !> \\verbatim !>          Y is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCY ) ). !>           Before entry, the incremented array Y must contain the n !>           element vector y. !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>           On entry, INCY specifies the increment for the elements of !>           Y. INCY must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set up the start points in X and Y if the increments are not both !     unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of ZHPR2 . ! ! END use M_blas , only : zhpr2_ => ZHPR2 implicit none COMPLEX * 16 ALPHA INTEGER INCX , INCY , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ), Y ( * ) call ZHPR2_ ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) end subroutine ZHPR2 subroutine ZHPR ( UPLO , N , ALPHA , X , INCX , AP ) ! COMMENT --file zhpr.3m_blas.man !> \\brief \\b ZHPR ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZHPR(UPLO,N,ALPHA,X,INCX,AP) ! !       .. Scalar Arguments .. !       DOUBLE PRECISION ALPHA !       INTEGER INCX,N !       CHARACTER UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZHPR    performs the hermitian rank 1 operation !> !>    A := alpha*x*x**H + A, !> !> where alpha is a real scalar, x is an n element vector and A is an !> n by n hermitian matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the upper or lower !>           triangular part of the matrix A is supplied in the packed !>           array AP as follows: !> !>              UPLO = 'U' or 'u'   The upper triangular part of A is !>                                  supplied in AP. !> !>              UPLO = 'L' or 'l'   The lower triangular part of A is !>                                  supplied in AP. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is DOUBLE PRECISION. !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim !> !> \\param[in,out] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !>           and a( 2, 2 ) respectively, and so on. On exit, the array !>           AP is overwritten by the upper triangular part of the !>           updated matrix. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular part of the hermitian matrix !>           packed sequentially, column by column, so that AP( 1 ) !>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !>           and a( 3, 1 ) respectively, and so on. On exit, the array !>           AP is overwritten by the lower triangular part of the !>           updated matrix. !>           Note that the imaginary parts of the diagonal elements need !>           not be set, they are assumed to be zero, and on exit they !>           are set to zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     Set the start point in X if the increment is not unity. ! ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! ! !        Form  A  when upper triangle is stored in AP. ! ! !        Form  A  when lower triangle is stored in AP. ! ! ! !     End of ZHPR  . ! ! END use M_blas , only : zhpr_ => ZHPR implicit none DOUBLE PRECISION ALPHA INTEGER INCX , N CHARACTER UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZHPR_ ( UPLO , N , ALPHA , X , INCX , AP ) end subroutine ZHPR subroutine ZROTG ( CA , CB , C , S ) ! COMMENT --file zrotg.3m_blas.man !> \\brief \\b ZROTG ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZROTG(CA,CB,C,S) ! !       .. Scalar Arguments .. !       COMPLEX*16 CA,CB,S !       DOUBLE PRECISION C !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZROTG determines a double complex Givens rotation. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in,out] CA !> \\verbatim !>          CA is COMPLEX*16 !> \\endverbatim !> !> \\param[in] CB !> \\verbatim !>          CB is COMPLEX*16 !> \\endverbatim !> !> \\param[out] C !> \\verbatim !>          C is DOUBLE PRECISION !> \\endverbatim !> !> \\param[out] S !> \\verbatim !>          S is COMPLEX*16 !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. !     .. Intrinsic Functions .. !     .. ! END use M_blas , only : zrotg_ => ZROTG implicit none COMPLEX * 16 CA , CB , S DOUBLE PRECISION C call ZROTG_ ( CA , CB , C , S ) end subroutine ZROTG subroutine ZSCAL ( N , ZA , ZX , INCX ) ! COMMENT --file zscal.3m_blas.man !> \\brief \\b ZSCAL ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSCAL(N,ZA,ZX,INCX) ! !       .. Scalar Arguments .. !       COMPLEX*16 ZA !       INTEGER INCX,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZSCAL scales a vector by a constant. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in] ZA !> \\verbatim !>          ZA is COMPLEX*16 !>           On entry, ZA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 3/93 to return if incx .le. 0. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !        code for increment equal to 1 ! ! !        code for increment not equal to 1 ! ! END use M_blas , only : zscal_ => ZSCAL implicit none COMPLEX * 16 ZA INTEGER INCX , N COMPLEX * 16 ZX ( * ) call ZSCAL_ ( N , ZA , ZX , INCX ) end subroutine ZSCAL subroutine ZSWAP ( N , ZX , INCX , ZY , INCY ) ! COMMENT --file zswap.3m_blas.man !> \\brief \\b ZSWAP ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSWAP(N,ZX,INCX,ZY,INCY) ! !       .. Scalar Arguments .. !       INTEGER INCX,INCY,N !       .. !       .. Array Arguments .. !       COMPLEX*16 ZX(*),ZY(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !>    ZSWAP interchanges two vectors. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] N !> \\verbatim !>          N is INTEGER !>         number of elements in input vector(s) !> \\endverbatim !> !> \\param[in,out] ZX !> \\verbatim !>          ZX is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>         storage spacing between elements of ZX !> \\endverbatim !> !> \\param[in,out] ZY !> \\verbatim !>          ZY is COMPLEX*16 array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !> \\endverbatim !> !> \\param[in] INCY !> \\verbatim !>          INCY is INTEGER !>         storage spacing between elements of ZY !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date November 2017 ! !> \\ingroup complex16_blas_level1 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>     jack dongarra, 3/11/78. !>     modified 12/3/93, array(1) declarations changed to array(*) !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Local Scalars .. !     .. ! !       code for both increments equal to 1 ! !       code for unequal increments or equal increments not equal !         to 1 ! ! END use M_blas , only : zswap_ => ZSWAP implicit none INTEGER INCX , INCY , N COMPLEX * 16 ZX ( * ), ZY ( * ) call ZSWAP_ ( N , ZX , INCX , ZY , INCY ) end subroutine ZSWAP subroutine ZSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zsymm.3m_blas.man !> \\brief \\b ZSYMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER LDA,LDB,LDC,M,N !       CHARACTER SIDE,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYMM  performs one of the matrix-matrix operations !> !>    C := alpha*A*B + beta*C, !> !> or !> !>    C := alpha*B*A + beta*C, !> !> where  alpha and beta are scalars, A is a symmetric matrix and  B and !> C are m by n matrices. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE  specifies whether  the  symmetric matrix  A !>           appears on the  left or right  in the  operation as follows: !> !>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !> !>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of  the  symmetric  matrix   A  is  to  be !>           referenced as follows: !> !>              UPLO = 'U' or 'u'   Only the upper triangular part of the !>                                  symmetric matrix is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the lower triangular part of the !>                                  symmetric matrix is to be referenced. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry,  M  specifies the number of rows of the matrix  C. !>           M  must be at least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of the matrix C. !>           N  must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           m  when  SIDE = 'L' or 'l'  and is n  otherwise. !>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading m by m upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  m by m  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of !>           the array  A  must contain the  symmetric matrix,  such that !>           when  UPLO = 'U' or 'u', the leading n by n upper triangular !>           part of the array  A  must contain the upper triangular part !>           of the  symmetric matrix and the  strictly  lower triangular !>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l', !>           the leading  n by n  lower triangular part  of the  array  A !>           must  contain  the  lower triangular part  of the  symmetric !>           matrix and the  strictly upper triangular part of  A  is not !>           referenced. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then !>           LDA must be at least  max( 1, m ), otherwise  LDA must be at !>           least max( 1, n ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry, the leading  m by n part of the array  B  must !>           contain the matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is !>           supplied as zero then C need not be set on input. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry, the leading  m by n  part of the array  C must !>           contain the matrix  C,  except when  beta  is zero, in which !>           case C need not be set on entry. !>           On exit, the array  C  is overwritten by the  m by n updated !>           matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Set NROWA as the number of rows of A. ! ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B + beta*C. ! ! !        Form  C := alpha*B*A + beta*C. ! ! ! !     End of ZSYMM . ! ! END use M_blas , only : zsymm_ => ZSYMM implicit none COMPLEX * 16 ALPHA , BETA INTEGER LDA , LDB , LDC , M , N CHARACTER SIDE , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZSYMM_ ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZSYMM subroutine ZSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) ! COMMENT --file zsyr2k.3m_blas.man !> \\brief \\b ZSYR2K ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDB,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYR2K  performs one of the symmetric rank 2k operations !> !>    C := alpha*A*B**T + alpha*B*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*B + alpha*B**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A and B  are  n by k  matrices  in the  first  case  and  k by n !> matrices in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !>                                         beta*C. !> !>              TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !>                                         beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns  of the  matrices  A and B,  and on  entry  with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrices  A and B.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  B  must contain the matrix  B,  otherwise !>           the leading  k by n  part of the array  B  must contain  the !>           matrix B. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDB must be at least  max( 1, n ), otherwise  LDB must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! ! ! !     End of ZSYR2K. ! ! END use M_blas , only : zsyr2k_ => ZSYR2K implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDB , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ), C ( LDC , * ) call ZSYR2K_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) end subroutine ZSYR2K subroutine ZSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) ! COMMENT --file zsyrk.3m_blas.man !> \\brief \\b ZSYRK ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA,BETA !       INTEGER K,LDA,LDC,N !       CHARACTER TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),C(LDC,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZSYRK  performs one of the symmetric rank k operations !> !>    C := alpha*A*A**T + beta*C, !> !> or !> !>    C := alpha*A**T*A + beta*C, !> !> where  alpha and beta  are scalars,  C is an  n by n symmetric matrix !> and  A  is an  n by k  matrix in the first case and a  k by n  matrix !> in the second case. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On  entry,   UPLO  specifies  whether  the  upper  or  lower !>           triangular  part  of the  array  C  is to be  referenced  as !>           follows: !> !>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C !>                                  is to be referenced. !> !>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C !>                                  is to be referenced. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry,  TRANS  specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !> !>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry,  N specifies the order of the matrix C.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number !>           of  columns   of  the   matrix   A,   and  on   entry   with !>           TRANS = 'T' or 't',  K  specifies  the number of rows of the !>           matrix A.  K must be at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry, ALPHA specifies the scalar alpha. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is !>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise. !>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k !>           part of the array  A  must contain the matrix  A,  otherwise !>           the leading  k by n  part of the array  A  must contain  the !>           matrix A. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n' !>           then  LDA must be at least  max( 1, n ), otherwise  LDA must !>           be at least  max( 1, k ). !> \\endverbatim !> !> \\param[in] BETA !> \\verbatim !>          BETA is COMPLEX*16 !>           On entry, BETA specifies the scalar beta. !> \\endverbatim !> !> \\param[in,out] C !> \\verbatim !>          C is COMPLEX*16 array, dimension ( LDC, N ) !>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n !>           upper triangular part of the array C must contain the upper !>           triangular part  of the  symmetric matrix  and the strictly !>           lower triangular part of C is not referenced.  On exit, the !>           upper triangular part of the array  C is overwritten by the !>           upper triangular part of the updated matrix. !>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n !>           lower triangular part of the array C must contain the lower !>           triangular part  of the  symmetric matrix  and the strictly !>           upper triangular part of C is not referenced.  On exit, the !>           lower triangular part of the array  C is overwritten by the !>           lower triangular part of the updated matrix. !> \\endverbatim !> !> \\param[in] LDC !> \\verbatim !>          LDC is INTEGER !>           On entry, LDC specifies the first dimension of C as declared !>           in  the  calling  (sub)  program.   LDC  must  be  at  least !>           max( 1, n ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !        Form  C := alpha*A*A**T + beta*C. ! ! !        Form  C := alpha*A**T*A + beta*C. ! ! ! !     End of ZSYRK . ! ! END use M_blas , only : zsyrk_ => ZSYRK implicit none COMPLEX * 16 ALPHA , BETA INTEGER K , LDA , LDC , N CHARACTER TRANS , UPLO COMPLEX * 16 A ( LDA , * ), C ( LDC , * ) call ZSYRK_ ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) end subroutine ZSYRK subroutine ZTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ztbmv.3m_blas.man !> \\brief \\b ZTBMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTBMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular band matrix, with ( k + 1 ) diagonals. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ). !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !         Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTBMV . ! ! END use M_blas , only : ztbmv_ => ZTBMV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTBMV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine ZTBMV subroutine ZTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) ! COMMENT --file ztbsv.3m_blas.man !> \\brief \\b ZTBSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTBSV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,K,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTBSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular band matrix, with ( k + 1 ) !> diagonals. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] K !> \\verbatim !>          K is INTEGER !>           On entry with UPLO = 'U' or 'u', K specifies the number of !>           super-diagonals of the matrix A. !>           On entry with UPLO = 'L' or 'l', K specifies the number of !>           sub-diagonals of the matrix A. !>           K must satisfy  0 .le. K. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !>           by n part of the array A must contain the upper triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row !>           ( k + 1 ) of the array, the first super-diagonal starting at !>           position 2 in row k, and so on. The top left k by k triangle !>           of the array A is not referenced. !>           The following program segment will transfer an upper !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = K + 1 - J !>                    DO 10, I = MAX( 1, J - K ), J !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !>           by n part of the array A must contain the lower triangular !>           band part of the matrix of coefficients, supplied column by !>           column, with the leading diagonal of the matrix in row 1 of !>           the array, the first sub-diagonal starting at position 1 in !>           row 2, and so on. The bottom right k by k triangle of the !>           array A is not referenced. !>           The following program segment will transfer a lower !>           triangular band matrix from conventional full matrix storage !>           to band storage: !> !>                 DO 20, J = 1, N !>                    M = 1 - J !>                    DO 10, I = J, MIN( N, J + K ) !>                       A( M + I, J ) = matrix( I, J ) !>              10    CONTINUE !>              20 CONTINUE !> !>           Note that when DIAG = 'U' or 'u' the elements of the array A !>           corresponding to the diagonal elements of the matrix are not !>           referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           ( k + 1 ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTBSV . ! ! END use M_blas , only : ztbsv_ => ZTBSV implicit none INTEGER INCX , K , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTBSV_ ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) end subroutine ZTBSV subroutine ZTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ztpmv.3m_blas.man !> \\brief \\b ZTPMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTPMV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTPMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix, supplied in packed form. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x:= A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTPMV . ! ! END use M_blas , only : ztpmv_ => ZTPMV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZTPMV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine ZTPMV subroutine ZTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) ! COMMENT --file ztpsv.3m_blas.man !> \\brief \\b ZTPSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTPSV(UPLO,TRANS,DIAG,N,AP,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 AP(*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTPSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix, supplied in packed form. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] AP !> \\verbatim !>          AP is COMPLEX*16 array, dimension at least !>           ( ( n*( n + 1 ) )/2 ). !>           Before entry with  UPLO = 'U' or 'u', the array AP must !>           contain the upper triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !>           respectively, and so on. !>           Before entry with UPLO = 'L' or 'l', the array AP must !>           contain the lower triangular matrix packed sequentially, !>           column by column, so that AP( 1 ) contains a( 1, 1 ), !>           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !>           respectively, and so on. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced, but are assumed to be unity. !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTPSV . ! ! END use M_blas , only : ztpsv_ => ZTPSV implicit none INTEGER INCX , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 AP ( * ), X ( * ) call ZTPSV_ ( UPLO , TRANS , DIAG , N , AP , X , INCX ) end subroutine ZTPSV subroutine ZTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ztrmm.3m_blas.man !> \\brief \\b ZTRMM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRMM  performs one of the matrix-matrix operations !> !>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !> !> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry,  SIDE specifies whether  op( A ) multiplies B from !>           the left or right as follows: !> !>              SIDE = 'L' or 'l'   B := alpha*op( A )*B. !> !>              SIDE = 'R' or 'r'   B := alpha*B*op( A ). !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, k ), where k is m !>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ). !>           Before entry,  the leading  m by n part of the array  B must !>           contain the matrix  B,  and  on exit  is overwritten  by the !>           transformed matrix. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*A*B. ! ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! ! !           Form  B := alpha*B*A. ! ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! ! ! !     End of ZTRMM . ! ! END use M_blas , only : ztrmm_ => ZTRMM implicit none COMPLEX * 16 ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ) call ZTRMM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine ZTRMM subroutine ZTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ztrmv.3m_blas.man !> \\brief \\b ZTRMV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRMV  performs one of the matrix-vector operations !> !>    x := A*x,   or   x := A**T*x,   or   x := A**H*x, !> !> where x is an n element vector and  A is an n by n unit, or non-unit, !> upper or lower triangular matrix. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the operation to be performed as !>           follows: !> !>              TRANS = 'N' or 'n'   x := A*x. !> !>              TRANS = 'T' or 't'   x := A**T*x. !> !>              TRANS = 'C' or 'c'   x := A**H*x. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ). !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element vector x. On exit, X is overwritten with the !>           transformed vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !>  The vector and matrix arguments are not referenced when N = 0, or M = 0 !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := A*x. ! ! !        Form  x := A**T*x  or  x := A**H*x. ! ! ! !     End of ZTRMV . ! ! END use M_blas , only : ztrmv_ => ZTRMV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTRMV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine ZTRMV subroutine ZTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) ! COMMENT --file ztrsm.3m_blas.man !> \\brief \\b ZTRSM ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) ! !       .. Scalar Arguments .. !       COMPLEX*16 ALPHA !       INTEGER LDA,LDB,M,N !       CHARACTER DIAG,SIDE,TRANSA,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),B(LDB,*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRSM  solves one of the matrix equations !> !>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !> !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of !> !>    op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !> !> The matrix X is overwritten on B. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] SIDE !> \\verbatim !>          SIDE is CHARACTER*1 !>           On entry, SIDE specifies whether op( A ) appears on the left !>           or right of X as follows: !> !>              SIDE = 'L' or 'l'   op( A )*X = alpha*B. !> !>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !> \\endverbatim !> !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix A is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANSA !> \\verbatim !>          TRANSA is CHARACTER*1 !>           On entry, TRANSA specifies the form of op( A ) to be used in !>           the matrix multiplication as follows: !> !>              TRANSA = 'N' or 'n'   op( A ) = A. !> !>              TRANSA = 'T' or 't'   op( A ) = A**T. !> !>              TRANSA = 'C' or 'c'   op( A ) = A**H. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit triangular !>           as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] M !> \\verbatim !>          M is INTEGER !>           On entry, M specifies the number of rows of B. M must be at !>           least zero. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the number of columns of B.  N must be !>           at least zero. !> \\endverbatim !> !> \\param[in] ALPHA !> \\verbatim !>          ALPHA is COMPLEX*16 !>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is !>           zero then  A is not referenced and  B need not be set before !>           entry. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, k ), !>           where k is m when SIDE = 'L' or 'l' !>             and k is n when SIDE = 'R' or 'r'. !>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k !>           upper triangular part of the array  A must contain the upper !>           triangular matrix  and the strictly lower triangular part of !>           A is not referenced. !>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k !>           lower triangular part of the array  A must contain the lower !>           triangular matrix  and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of !>           A  are not referenced either,  but are assumed to be  unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then !>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' !>           then LDA must be at least max( 1, n ). !> \\endverbatim !> !> \\param[in,out] B !> \\verbatim !>          B is COMPLEX*16 array, dimension ( LDB, N ) !>           Before entry,  the leading  m by n part of the array  B must !>           contain  the  right-hand  side  matrix  B,  and  on exit  is !>           overwritten by the solution matrix  X. !> \\endverbatim !> !> \\param[in] LDB !> \\verbatim !>          LDB is INTEGER !>           On entry, LDB specifies the first dimension of B as declared !>           in  the  calling  (sub)  program.   LDB  must  be  at  least !>           max( 1, m ). !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level3 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 3 Blas routine. !> !>  -- Written on 8-February-1989. !>     Jack Dongarra, Argonne National Laboratory. !>     Iain Duff, AERE Harwell. !>     Jeremy Du Croz, Numerical Algorithms Group Ltd. !>     Sven Hammarling, Numerical Algorithms Group Ltd. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. !     .. Local Scalars .. !     .. !     .. Parameters .. !     .. ! !     Test the input parameters. ! ! ! !     Quick return if possible. ! ! !     And when  alpha.eq.zero. ! ! !     Start the operations. ! ! !           Form  B := alpha*inv( A )*B. ! ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! ! !           Form  B := alpha*B*inv( A ). ! ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! ! ! !     End of ZTRSM . ! ! END use M_blas , only : ztrsm_ => ZTRSM implicit none COMPLEX * 16 ALPHA INTEGER LDA , LDB , M , N CHARACTER DIAG , SIDE , TRANSA , UPLO COMPLEX * 16 A ( LDA , * ), B ( LDB , * ) call ZTRSM_ ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) end subroutine ZTRSM subroutine ZTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) ! COMMENT --file ztrsv.3m_blas.man !> \\brief \\b ZTRSV ! !  =========== DOCUMENTATION =========== ! ! Online html documentation available at !            http://www.netlib.org/lapack/explore-html/ ! !  Definition: !  =========== ! !       SUBROUTINE ZTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) ! !       .. Scalar Arguments .. !       INTEGER INCX,LDA,N !       CHARACTER DIAG,TRANS,UPLO !       .. !       .. Array Arguments .. !       COMPLEX*16 A(LDA,*),X(*) !       .. ! ! !> \\par Purpose: !  ============= !> !> \\verbatim !> !> ZTRSV  solves one of the systems of equations !> !>    A*x = b,   or   A**T*x = b,   or   A**H*x = b, !> !> where b and x are n element vectors and A is an n by n unit, or !> non-unit, upper or lower triangular matrix. !> !> No test for singularity or near-singularity is included in this !> routine. Such tests must be performed before calling this routine. !> \\endverbatim ! !  Arguments: !  ========== ! !> \\param[in] UPLO !> \\verbatim !>          UPLO is CHARACTER*1 !>           On entry, UPLO specifies whether the matrix is an upper or !>           lower triangular matrix as follows: !> !>              UPLO = 'U' or 'u'   A is an upper triangular matrix. !> !>              UPLO = 'L' or 'l'   A is a lower triangular matrix. !> \\endverbatim !> !> \\param[in] TRANS !> \\verbatim !>          TRANS is CHARACTER*1 !>           On entry, TRANS specifies the equations to be solved as !>           follows: !> !>              TRANS = 'N' or 'n'   A*x = b. !> !>              TRANS = 'T' or 't'   A**T*x = b. !> !>              TRANS = 'C' or 'c'   A**H*x = b. !> \\endverbatim !> !> \\param[in] DIAG !> \\verbatim !>          DIAG is CHARACTER*1 !>           On entry, DIAG specifies whether or not A is unit !>           triangular as follows: !> !>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. !> !>              DIAG = 'N' or 'n'   A is not assumed to be unit !>                                  triangular. !> \\endverbatim !> !> \\param[in] N !> \\verbatim !>          N is INTEGER !>           On entry, N specifies the order of the matrix A. !>           N must be at least zero. !> \\endverbatim !> !> \\param[in] A !> \\verbatim !>          A is COMPLEX*16 array, dimension ( LDA, N ) !>           Before entry with  UPLO = 'U' or 'u', the leading n by n !>           upper triangular part of the array A must contain the upper !>           triangular matrix and the strictly lower triangular part of !>           A is not referenced. !>           Before entry with UPLO = 'L' or 'l', the leading n by n !>           lower triangular part of the array A must contain the lower !>           triangular matrix and the strictly upper triangular part of !>           A is not referenced. !>           Note that when  DIAG = 'U' or 'u', the diagonal elements of !>           A are not referenced either, but are assumed to be unity. !> \\endverbatim !> !> \\param[in] LDA !> \\verbatim !>          LDA is INTEGER !>           On entry, LDA specifies the first dimension of A as declared !>           in the calling (sub) program. LDA must be at least !>           max( 1, n ). !> \\endverbatim !> !> \\param[in,out] X !> \\verbatim !>          X is COMPLEX*16 array, dimension at least !>           ( 1 + ( n - 1 )*abs( INCX ) ). !>           Before entry, the incremented array X must contain the n !>           element right-hand side vector b. On exit, X is overwritten !>           with the solution vector x. !> \\endverbatim !> !> \\param[in] INCX !> \\verbatim !>          INCX is INTEGER !>           On entry, INCX specifies the increment for the elements of !>           X. INCX must not be zero. !> \\endverbatim ! !  Authors: !  ======== ! !> \\author Univ. of Tennessee !> \\author Univ. of California Berkeley !> \\author Univ. of Colorado Denver !> \\author NAG Ltd. ! !> \\date December 2016 ! !> \\ingroup complex16_blas_level2 ! !> \\par Further Details: !  ===================== !> !> \\verbatim !> !>  Level 2 Blas routine. !> !>  -- Written on 22-October-1986. !>     Jack Dongarra, Argonne National Lab. !>     Jeremy Du Croz, Nag Central Office. !>     Sven Hammarling, Nag Central Office. !>     Richard Hanson, Sandia National Labs. !> \\endverbatim !> !  ===================================================================== ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. !     .. !     .. Array Arguments .. !     .. ! !  ===================================================================== ! !     .. Parameters .. !     .. !     .. Local Scalars .. !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. !     .. ! !     Test the input parameters. ! ! !     Quick return if possible. ! ! ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! ! !        Form  x := inv( A )*x. ! ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! ! ! !     End of ZTRSV . ! ! END use M_blas , only : ztrsv_ => ZTRSV implicit none INTEGER INCX , LDA , N CHARACTER DIAG , TRANS , UPLO COMPLEX * 16 A ( LDA , * ), X ( * ) call ZTRSV_ ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) end subroutine ZTRSV","tags":"","loc":"sourcefile/compatible.f90.html"},{"title":"M_blas.f90 – M_blas","text":"Contents Modules M_blas Source Code M_blas.f90 Source Code module M_blas use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 !============================================================================== ! xerbla needs a special version for the test programs to run ! so it is a pointer to the standard procedure, but allows for ! xerbla to point to a user-defined procedure for testing ! !    use M_blas, only : set_xerbla, std_xerbla !    call set_mysub(SUBROUTINE_NAME) public :: xerbla public :: set_xerbla private :: std_xerbla public :: xerbla_interface abstract interface subroutine xerbla_interface ( srname , info ) character ( len =* ), intent ( in ) :: srname integer , intent ( in ) :: info end subroutine xerbla_interface end interface procedure ( xerbla_interface ), pointer :: xerbla => std_xerbla !============================================================================== contains subroutine set_xerbla ( proc ) procedure ( xerbla_interface ) :: proc xerbla => proc end subroutine set_xerbla !> !!##NAME !!    xerbla_array(3f) - [BLAS:AUX_BLAS] call XERBLA(3f) with an array of characters instead of a string !! !!##SYNOPSIS !! !!     subroutine xerbla_array(srname_array, srname_len, info) !! !!        .. Scalar Arguments .. !!        integer srname_len, info !!        .. !!        .. Array Arguments .. !!        character(*) srname_array(srname_len) !!        .. !! !!##DEFINITION !! !!  XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK !!  and BLAS error handler. Rather than taking a Fortran string argument !!  as the function's name, XERBLA_ARRAY takes an array of single !!  characters along with the array's length. XERBLA_ARRAY then copies !!  up to 32 characters of that array into a Fortran string and passes !!  that to XERBLA. If called with a non-positive SRNAME_LEN, !!  XERBLA_ARRAY will call XERBLA with a string of all blank characters. !! !!  Say some macro or other device makes XERBLA_ARRAY available to C99 !!  by a name lapack_xerbla and with a common Fortran calling convention. !!  Then a C99 program could invoke XERBLA via: !!     { !!       int flen = strlen(__func__); !!       lapack_xerbla(__func__, &flen, &info); !!     } !! !!  Providing XERBLA_ARRAY is not necessary for intercepting LAPACK !!  errors. XERBLA_ARRAY calls XERBLA. !! !!##OPTIONS !! !!   SRNAME_ARRAY !! !!           SRNAME_ARRAY is CHARACTER(*) array, dimension (SRNAME_LEN) !!           The name of the routine which called XERBLA_ARRAY. !! !!   SRNAME_LEN !! !!           SRNAME_LEN is INTEGER !!           The length of the name in SRNAME_ARRAY. !! !!   INFO !! !!           INFO is INTEGER !!           The position of the invalid parameter in the parameter list !!           of the calling routine. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine xerbla_array ( srname_array , srname_len , info ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: srname_len , info !     .. !     .. Array Arguments .. character ( len =* ), intent ( in ) :: srname_array ( srname_len ) !     .. ! ! ===================================================================== ! !     .. !     .. Local Scalars .. integer i !     .. !     .. Local Arrays .. character * 32 srname !     .. !     .. Intrinsic Functions .. intrinsic min , len !     .. !     .. External Functions .. !      EXTERNAL XERBLA !     .. !     .. Executable Statements .. srname = '' do i = 1 , min ( srname_len , len ( srname ) ) srname ( i : i ) = srname_array ( i ) enddo call xerbla ( srname , info ) end subroutine xerbla_array !> !!##NAME !!    xerbla(3f) - [BLAS:AUX_BLAS] error handler routine for the BLAS/LAPACK routines !! !!##SYNOPSIS !! !!     subroutine xerbla( srname, info ) !! !!        .. Scalar Arguments .. !!        character(len=*),intent(in) :: srname !!        integer,intent(in)          :: info !!        .. !! !!##DEFINITION !! !!  XERBLA is an error handler for the LAPACK routines. !!  It is called by an LAPACK routine if an input parameter has an !!  invalid value. A message is printed and execution stops. !! !!  Installers may consider modifying the STOP statement in order to !!  call system-specific exception-handling facilities. !! !!##OPTIONS !! !!   SRNAME !! !!           SRNAME is character(len=*),intent(in) !!           The name of the routine which called XERBLA. !! !!   INFO !! !!           INFO is integer,intent(in) !!           The position of the invalid parameter in the parameter list !!           of the calling routine. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine std_xerbla ( srname , info ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. character ( len =* ), intent ( in ) :: srname integer , intent ( in ) :: info !     .. ! ===================================================================== !     .. Intrinsic Functions .. intrinsic trim !     .. !     .. Executable Statements .. ! write ( * , fmt = 9999 ) trim ( srname ), info stop 9999 format ( ' ** On entry to ' , a , ' parameter number ' , i2 , ' had ' , 'an illegal value' ) end subroutine std_xerbla !> !!##NAME !!     caxpy(3f) -- [BLAS:COMPLEX_BLAS_LEVEL1] CY:=CY+CA*CX (constant times a vector plus a vector) !! !!##SYNOPSIS !! !!    subroutine caxpy(n,ca,cx,incx,cy,incy) !! !!        .. Scalar Arguments .. !!        complex,intent(in)    :: ca !!        integer,intent(in)    :: incx,incy,n !!        .. !!        .. Array Arguments .. !!        complex,intent(in)    :: cx(*) !!        complex,intent(inout) :: cy(*) !! !!##DESCRIPTION !!     CAXPY constant times a vector plus a vector. !! !!##OPTIONS !!    N      number of elements in input vector(s) !!    CA     On entry, CA specifies the scalar alpha. !!    CX     CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!    INCX   storage spacing between elements of CX !!    CY     CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!    INCY   storage spacing between elements of CY !! !!##AUTHORS !! !!   + Univ. of Tennessee !!   + Univ. of California Berkeley !!   + Univ. of Colorado Denver !!   + NAG Ltd. !! !!  November 2017 !! !!  FURTHER DETAILS !! !!      Jack Dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine caxpy ( n , ca , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: ca integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) complex , intent ( inout ) :: cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer :: i , ix , iy !     .. !     .. External Functions .. !     .. if ( n . le . 0 ) return if ( scabs1 ( ca ). eq . 0.0e+0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n cy ( i ) = cy ( i ) + ca * cx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n cy ( iy ) = cy ( iy ) + ca * cx ( ix ) ix = ix + incx iy = iy + incy enddo endif ! end subroutine caxpy !> !!##NAME !!    ccopy(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] CY:=CX (copies elements of a vector x to a vector y) !! !!##SYNOPSIS !! !!    subroutine ccopy(n,cx,incx,cy,incy) !! !!     .. scalar arguments .. !!        integer,intent(in)  ::  incx,incy,n !!     .. !!     .. array arguments .. !!        complex,intent(in)  ::  cx(*) !!        complex,intent(out) ::  cy(*) !! !!##DESCRIPTION !!    CCOPY copies a vector x to a vector y. !! !!##OPTIONS !!    N     number of elements in input vector(s) !!    CX    dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!    INCX  storage spacing between elements of CX !!    CY    dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!    INCY  storage spacing between elements of CY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ccopy ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) complex , intent ( out ) :: cy ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then !        code for both increments equal to 1 cy ( 1 : n ) = cx ( 1 : n ) else !        code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n cy ( iy ) = cx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine ccopy ! JSU: N is not the size of X and Y it is the number of elements copied from X to Y ! JSU: as-is CY and CX are assumed of sufficient size for the copies to be in bounds ! JSU: for the simple case where the increments are 1 and N is the size of both arrays a statement of the form X=Y is OK in F90 !      and in other cases simple array syntax statements can replace a call to this procedure !> !!##NAME !!    cdotc(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] CDOTC := SUM CONJUGATE(CX) * CY (conjugated vector dot product) !! !!##SYNOPSIS !! !! !!     complex function cdotc(n,cx,incx,cy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) ::  incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex,intent(in) ::  cx(*),cy(*) !!       .. !! !!##DEFINITION !!  CDOTC forms the dot product of two complex vectors !! !!       CDOTC = X&#94;H * Y !! !!##OPTIONS !! !!   N     number of elements in input vector(s) !!   CX    array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX  storage spacing between elements of CX !!   CY    array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY  storage spacing between elements of CY !! !!##AUTHORS !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !!      jack dongarra, linpack,  3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== complex function cdotc ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ctemp = ( 0.0 , 0.0 ) cdotc = ( 0.0 , 0.0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = ctemp + conjg ( cx ( i )) * cy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = ctemp + conjg ( cx ( ix )) * cy ( iy ) ix = ix + incx iy = iy + incy enddo endif cdotc = ctemp end function cdotc !> !!##NAME !!    cdotu(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] CDOTU := SUM CX * CY  (unconjugated vector dot product) !! !!##SYNOPSIS !! !!     complex function cdotu(n,cx,incx,cy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) ::  incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex,intent(in) ::  cx(*),cy(*) !!       .. !! !!##DEFINITION !!  CDOTU forms the dot product of two complex vectors !! !!       CDOTU = X&#94;T * Y !! !!##OPTIONS !!   N !!          number of elements in input vector(s) !!   CX !!          array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !!          storage spacing between elements of CX !!   CY !!          array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY !!          storage spacing between elements of CY !! !!##AUTHORS !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== complex function cdotu ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. ctemp = ( 0.0 , 0.0 ) cdotu = ( 0.0 , 0.0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = ctemp + cx ( i ) * cy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = ctemp + cx ( ix ) * cy ( iy ) ix = ix + incx iy = iy + incy enddo endif cdotu = ctemp end function cdotu !> !!##NAME !!    cgbmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CY := alpha*A*CX + beta*CY; ==> A is a rectangular band matrix). !! !!##SYNOPSIS !! !! !!     subroutine cgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: incx,incy,kl,ku,lda,m,n !!       character,intent(in)  :: trans !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),x(*) !!       complex,intent(inout) :: y(*) !!       .. !! !!##DESCRIPTION !!  CGBMV  performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !! !!     y := alpha*A**H*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n band matrix, with kl sub-diagonals and ku super-diagonals. !! !!##OPTIONS !! !!   TRANS !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !! !!   M !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   KL !!            On entry, KL specifies the number of sub-diagonals of the !!            matrix A. KL must satisfy  0 .le. KL. !! !!   KU !!           On entry, KU specifies the number of super-diagonals of the !!           matrix A. KU must satisfy  0 .le. KU. !! !!   ALPHA !!           On entry, ALPHA specifies the scalar alpha. !! !!   A !!           A is COMPLEX array, dimension ( LDA, N ) !!           Before entry, the leading ( kl + ku + 1 ) by n part of the !!           array A must contain the matrix of coefficients, supplied !!           column by column, with the leading diagonal of the matrix in !!           row ( ku + 1 ) of the array, the first super-diagonal !!           starting at position 2 in row ku, the first sub-diagonal !!           starting at position 1 in row ( ku + 2 ), and so on. !! !!           Elements in the array A that do not correspond to elements !!           in the band matrix (such as the top left ku by ku triangle) !!           are not referenced. !! !!           The following program segment will transfer a band matrix !!           from conventional full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     K = KU + 1 - J !!                     DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !!                        A( K + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!   LDA !!           On entry, LDA specifies the first dimension of A as declared !!           in the calling (sub) program. LDA must be at least !!           ( kl + ku + 1 ). !! !!   X !!           X is COMPLEX array, dimension at least !!           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!           and at least !!           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!           Before entry, the incremented array X must contain the !!           vector x. !! !!   INCX !!           INCX is INTEGER !!           On entry, INCX specifies the increment for the elements of !!           X. INCX must not be zero. !! !!   BETA !!           BETA is COMPLEX !!           On entry, BETA specifies the scalar beta. When BETA is !!           supplied as zero then Y need not be set on input. !! !!  Y !!           Y is COMPLEX array, dimension at least !!           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!           and at least !!           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!           Before entry, the incremented array Y must contain the !!           vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !!           INCY is INTEGER !!           On entry, INCY specifies the increment for the elements of !!           Y. INCY must not be zero. !! !!##AUTHORS !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'CGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set LENX and LENY,the lengths of the vectors x and y, and set !     up the start points in X and Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then do i = 1 , leny y ( i ) = zero enddo else do i = 1 , leny y ( i ) = beta * y ( i ) enddo endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + conjg ( a ( k + i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + conjg ( a ( k + i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif end subroutine cgbmv !> !!##NAME !!    cgemm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] C:=alpha*A*B+beta*C; ==> A, B, C rectangular. !! !!##SYNOPSIS !! !! !!     subroutine cgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: k,lda,ldb,ldc,m,n !!       character,intent(in)  :: transa,transb !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),b(ldb,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CGEMM performs one of the matrix-matrix operations !! !!     C := alpha*op( A )*op( B ) + beta*C, !! !!  where op( X ) is one of !! !!     op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !! !!  alpha and beta are scalars, and A, B and C are matrices, with op( A ) !!  an m by k matrix,  op( B )  a K by N matrix and C an M by N matrix. !! !!##OPTIONS !! !!   TRANSA !! !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n',  op( A ) = A. !! !!               TRANSA = 'T' or 't',  op( A ) = A**T. !! !!               TRANSA = 'C' or 'c',  op( A ) = A**H. !! !!   TRANSB !! !!           TRANSB is CHARACTER*1 !!            On entry, TRANSB specifies the form of op( B ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSB = 'N' or 'n',  op( B ) = B. !! !!               TRANSB = 'T' or 't',  op( B ) = B**T. !! !!               TRANSB = 'C' or 'c',  op( B ) = B**H. !! !!   M !!            On entry, M specifies the number of rows of the matrix !!            op( A ) and of the matrix C. M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix !!            op( B ) and the number of columns of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of columns of the matrix !!            op( A ) and the number of rows of the matrix op( B ). K must !!            be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            k when TRANSA = 'N' or 'n', and is m otherwise. !!            Before entry with TRANSA = 'N' or 'n', the leading m by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by m part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANSA = 'N' or 'n' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, k ). !! !!   B !! !!           B is COMPLEX array, dimension ( LDB, kb ), where kb is !!            n when TRANSB = 'N' or 'n', and is k otherwise. !!            Before entry with TRANSB = 'N' or 'n', the leading k by n !!            part of the array B must contain the matrix B, otherwise !!            the leading n by k part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANSB = 'N' or 'n' then !!            LDB must be at least max( 1, k ), otherwise LDB must be at !!            least max( 1, n ). !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n matrix !!            ( alpha*op( A )*op( B ) + beta*C ). !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , l , nrowa , nrowb logical conja , conjb , nota , notb !     .. !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and  NROWB  as the number of rows of  A  and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) conja = lsame ( transa , 'C' ) conjb = lsame ( transb , 'C' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . conja ) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . conjb ) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'CGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n do i = 1 , m c ( i , j ) = zero enddo enddo else do j = 1 , n do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( l , j ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo elseif ( conja ) then ! !           Form  C := alpha*A**H*B + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif elseif ( nota ) then if ( conjb ) then ! !           Form  C := alpha*A*B**H + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * conjg ( b ( j , l )) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( j , l ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo endif elseif ( conja ) then if ( conjb ) then ! !           Form  C := alpha*A**H*B**H + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * conjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**H*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( conjb ) then ! !           Form  C := alpha*A**T*B**H + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * conjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! !     End of CGEMM . ! end subroutine cgemm !> !!##NAME !!    cgemv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CY := alpha*A*CX + beta*CY; ==> A a rectangular matrix. !! !!##SYNOPSIS !! !! !!     subroutine cgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       COMPLEX,intent(in)    :: ALPHA,BETA !!       INTEGER,intent(in)    :: INCX,INCY,LDA,M,N !!       CHARACTER,intent(in)  :: TRANS !!       .. !!       .. Array Arguments .. !!       COMPLEX,intent(in)    :: A(LDA,*),X(*) !!       COMPLEX,intent(inout) :: Y(*) !!       .. !! !!##DEFINITION !! !!  CGEMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !! !!     y := alpha*A**H*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n matrix. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry with BETA non-zero, the incremented array Y !!            must contain the vector y. On exit, Y is overwritten by the !!            updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex , parameter :: one = ( 1.0e+0 , 0.0e+0 ) complex , parameter :: zero = ( 0.0e+0 , 0.0e+0 ) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo else do i = 1 , m temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo else do i = 1 , m temp = temp + conjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! !     End of CGEMV . ! end subroutine cgemv !> !!##NAME !!    cgerc(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] A := A + alpha*CX*CONJUGATE-TRANSPOSE(CY); ==> A is a rectangular matrix. !! !!##SYNOPSIS !! !!     subroutine cgerc(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       integer,intent(in)    :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: a(lda,*) !!       complex,intent(in)    :: x(*),y(*) !!       .. !! !!##DEFINITION !! !!  CGERC performs the rank 1 operation !! !!     A := alpha*x*y**H + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the m !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. On exit, A is !!            overwritten by the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cgerc ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CGERC ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * conjg ( y ( jy )) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * conjg ( y ( jy )) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine cgerc !> !!##NAME !!    cgeru(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] A := A + alpha*CX*TRANSPOSE(CY); ==> A is a rectangular matrix. !! !!##SYNOPSIS !! !!     subroutine cgeru(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       integer,intent(in)    :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: a(lda,*) !!       complex,intent(in)    :: x(*),y(*) !!       .. !! !!##DEFINITION !! !!  CGERU performs the rank 1 operation !! !!     A := alpha*x*y**T + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the m !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. On exit, A is !!            overwritten by the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cgeru ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CGERU ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine cgeru !> !!##NAME !!    chbmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CY := alpha*A*CX + beta*CY; ==> A a (square) hermitian band matrix. !! !!##SYNOPSIS !! !!     subroutine chbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: incx,incy,k,lda,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),x(*) !!       complex,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  CHBMV(3f) performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian band matrix, with k super-diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the band matrix A is being supplied as !!            follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   being supplied. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   being supplied. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of super-diagonals of the !!            matrix A. K must satisfy 0 .le. K. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the hermitian matrix, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer the upper !!            triangular part of a hermitian band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the hermitian matrix, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer the lower !!            triangular part of a hermitian band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. !! !!  Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CHBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * real ( a ( kplus1 , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( a ( kplus1 , j )) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( a ( 1 , j )) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( a ( 1 , j )) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + conjg ( a ( l + i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! !     End of CHBMV . ! end subroutine chbmv !> !!##NAME !!    chemm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] C:=alpha*A*TRANSPOSE(A)+beta*C; ==> A hermitian, B, C rectangular. !! !!##SYNOPSIS !! !!     subroutine chemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: lda,ldb,ldc,m,n !!       character,intent(in)  :: side,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),b(ldb,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CHEMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is an hermitian matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the hermitian matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the hermitian matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   hermitian matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   hermitian matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the hermitian matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the hermitian matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the hermitian !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the hermitian matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the hermitian matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the hermitian !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is COMPLEX array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CHEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * conjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * real ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * real ( a ( i , i )) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * conjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * real ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * real ( a ( i , i )) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * real ( a ( j , j )) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * conjg ( a ( j , k )) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * conjg ( a ( j , k )) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! !     End of CHEMM . ! end subroutine chemm !> !!##NAME !!    chemv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] CY := alpha*A*CX + beta*CY; ==> A a (square) hermitian matrix. !! !!##SYNOPSIS !! !!     subroutine chemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: incx,incy,lda,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),x(*) !!       complex,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  CHEMV  performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CHEMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * real ( a ( j , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( a ( j , j )) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( a ( j , j )) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( a ( j , j )) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + conjg ( a ( i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine chemv !> !!##NAME !!    cher2(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] A := A + alpha*CX*CONJUGATE-TRANSPOSE(CY)n + CONJUGATE(alpha)*CY*CONJUGATE-TRANSPOSE(CX); !!    ==> n A a (square) hermitian matrix. !!    (performs the hermitian rank 2 operation) !! !!##SYNOPSIS !! !!     subroutine cher2(uplo,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex,intent(in)     :: alpha !!       integer,intent(in)     :: incx,incy,lda,n !!       character,intent(in)   :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(inout)  :: a(lda,*) !!       complex,intent(in)     :: x(*),y(*) !!       .. !! !!##DEFINITION !! !!  CHER2 performs the hermitian rank 2 operation !! !!     A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an n !!  by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CHER2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) else a ( j , j ) = real ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ix = kx iy = ky do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo else a ( j , j ) = real ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine cher2 !> !!##NAME !!    cher2k(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !!    C:=alpha*A*TRANSPOSE(B)+alpha*B*TRANSPOSE(A)+beta*C; ==> C hermitian. !!    (performs one of the hermitian rank 2k operations) !! !!##SYNOPSIS !! !!     subroutine cher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       real,intent(in)       :: beta !!       integer,intent(in)    :: k,lda,ldb,ldc,n !!       character,intent(in)  :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),b(ldb,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CHER2K performs one of the hermitian rank 2k operations !! !!     C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !! !!  or !! !!     C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !! !!  where alpha and beta are scalars with beta real, C is an n by n !!  hermitian matrix and A and B are n by k matrices in the first case !!  and k by n matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'    C := alpha*A*B**H          + !!                                          conjg( alpha )*B*A**H + !!                                          beta*C. !! !!               TRANS = 'C' or 'c'    C := alpha*A**H*B          + !!                                          conjg( alpha )*B**H*A + !!                                          beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'C' or 'c', K specifies the number of rows of the !!            matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is COMPLEX array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!   -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !!      Ed Anderson, Cray Research Inc. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha real , intent ( in ) :: beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one parameter ( one = 1.0e+0 ) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CHER2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . real ( zero )) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) enddo endif else if ( beta . eq . real ( zero )) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! if ( upper ) then do j = 1 , n if ( beta . eq . real ( zero )) then do i = 1 , j c ( i , j ) = zero enddo elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * conjg ( b ( j , l )) temp2 = conjg ( alpha * a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = real ( c ( j , j )) + real ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo else do j = 1 , n if ( beta . eq . real ( zero )) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * conjg ( b ( j , l )) temp2 = conjg ( alpha * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = real ( c ( j , j )) + real ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo endif else ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + conjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + conjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . real ( zero )) then c ( j , j ) = real ( alpha * temp1 + conjg ( alpha ) * temp2 ) else c ( j , j ) = beta * real ( c ( j , j )) + real ( alpha * temp1 + conjg ( alpha ) * temp2 ) endif else if ( beta . eq . real ( zero )) then c ( i , j ) = alpha * temp1 + conjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + conjg ( alpha ) * temp2 endif endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + conjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + conjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . real ( zero )) then c ( j , j ) = real ( alpha * temp1 + conjg ( alpha ) * temp2 ) else c ( j , j ) = beta * real ( c ( j , j )) + real ( alpha * temp1 + conjg ( alpha ) * temp2 ) endif else if ( beta . eq . real ( zero )) then c ( i , j ) = alpha * temp1 + conjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + conjg ( alpha ) * temp2 endif endif enddo enddo endif endif ! end subroutine cher2k !> !!##NAME !!    cher(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] A := A + alpha*CX*CONJUGATE-TRANSPOSE(CX); ==> A a (square) hermitian matrix. !!    (performs the hermitian rank 1 operation) !! !!##SYNOPSIS !! !!     subroutine cher(uplo,n,alpha,x,incx,a,lda) !! !!       .. Scalar Arguments .. !!       real,intent(in)       :: alpha !!       integer,intent(in)    :: incx,lda,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: a(lda,*) !!       complex,intent(in)    :: x(*) !!       .. !! !!##DEFINITION !! !!  CHER performs the hermitian rank 1 operation !! !!     A := alpha*x*x**H + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cher ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: a ( lda , * ) complex , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CHER  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . real ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( j ) * temp ) else a ( j , j ) = real ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ix = kx do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo a ( j , j ) = real ( a ( j , j )) + real ( x ( jx ) * temp ) else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) a ( j , j ) = real ( a ( j , j )) + real ( temp * x ( j )) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo else a ( j , j ) = real ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) a ( j , j ) = real ( a ( j , j )) + real ( temp * x ( jx )) ix = jx do i = j + 1 , n ix = ix + incx a ( i , j ) = a ( i , j ) + x ( ix ) * temp enddo else a ( j , j ) = real ( a ( j , j )) endif jx = jx + incx enddo endif endif ! end subroutine cher !> !!##NAME !!    cherk(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] performs one of the hermitian rank k operations !! C:=alpha*A*TRANSPOSE(A)+beta*C, C hermitian. !! !!##SYNOPSIS !! !!     subroutine cherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       real,intent(in)       :: alpha,beta !!       integer,intent(in)    :: k,lda,ldc,n !!       character,intent(in)  :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CHERK performs one of the hermitian rank k operations !! !!     C := alpha*A*A**H + beta*C, !! !!  or !! !!     C := alpha*A**H*A + beta*C, !! !!  where alpha and beta are real scalars, C is an n by n hermitian !!  matrix and A is an n by k matrix in the first case and a k by n !!  matrix in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrix A, and on entry with !!            TRANS = 'C' or 'c', K specifies the number of rows of the !!            matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!   -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1. !!      Ed Anderson, Cray Research Inc. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic cmplx , conjg , max , real !     .. !     .. Local Scalars .. complex temp real rtemp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CHERK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n do i = 1 , j c ( i , j ) = zero enddo enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) enddo endif else if ( beta . eq . zero ) then do j = 1 , n do i = j , n c ( i , j ) = zero enddo enddo else do j = 1 , n c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**H + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * real ( c ( j , j )) else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . cmplx ( zero )) then temp = alpha * conjg ( a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo c ( j , j ) = real ( c ( j , j )) + real ( temp * a ( i , l )) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then do i = j , n c ( i , j ) = zero enddo elseif ( beta . ne . one ) then c ( j , j ) = beta * real ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo else c ( j , j ) = real ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . cmplx ( zero )) then temp = alpha * conjg ( a ( j , l )) c ( j , j ) = real ( c ( j , j )) + real ( temp * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**H*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j - 1 temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo rtemp = zero do l = 1 , k rtemp = rtemp + conjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * real ( c ( j , j )) endif enddo else do j = 1 , n rtemp = zero do l = 1 , k rtemp = rtemp + conjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * real ( c ( j , j )) endif do i = j + 1 , n temp = zero do l = 1 , k temp = temp + conjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine cherk !> !!##NAME !!    chpmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CY := alpha*A*CX + beta*CY, A a (square) hermitian packed matrix. !! !!##SYNOPSIS !! !!     subroutine chpmv(uplo,n,alpha,ap,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: incx,incy,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: ap(*),x(*) !!       complex,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  CHPMV(3f) performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   AP !! !!           AP is COMPLEX array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ), x ( * ) complex , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CHPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * real ( ap ( kk + j - 1 )) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * real ( ap ( kk + j - 1 )) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * real ( ap ( kk )) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * real ( ap ( kk )) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + conjg ( ap ( k )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif ! end subroutine chpmv !> !!##NAME !!    chpr2(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] performs the hermitian rank 2 operation !! A := A + alpha*CX*CONJUGATE-TRANSPOSE(CY)n + CONJUGATE(ALPHA)*CY*CONJUGATE-TRANSPOSE(CX),n A a (square) hermitian packed matrix. !! !!##SYNOPSIS !! !!     subroutine chpr2(uplo,n,alpha,x,incx,y,incy,ap) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       integer,intent(in)    :: incx,incy,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: ap(*) !!       complex,intent(in)    :: x(*),y(*) !!       .. !! !!##DEFINITION !! !!  CHPR2 performs the hermitian rank 2 operation !! !!     A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an !!  n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  AP !! !!           AP is COMPLEX array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: ap ( * ) complex , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CHPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ix = kx iy = ky do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * conjg ( y ( j )) temp2 = conjg ( alpha * x ( j )) ap ( kk ) = real ( ap ( kk )) + real ( x ( j ) * temp1 + y ( j ) * temp2 ) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo else ap ( kk ) = real ( ap ( kk )) endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * conjg ( y ( jy )) temp2 = conjg ( alpha * x ( jx )) ap ( kk ) = real ( ap ( kk )) + real ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else ap ( kk ) = real ( ap ( kk )) endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif ! end subroutine chpr2 !> !!##NAME !!    chpr(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] performs the hermitian rank 1 operation !! A := A + alpha*CX*CONJUGATE-TRANSPOSE(CX), a a (square) hermitian packed. !! !!##SYNOPSIS !! !!     subroutine chpr(uplo,n,alpha,x,incx,ap) !! !!       .. Scalar Arguments .. !!       real,intent(in)       :: alpha !!       integer,intent(in)    :: incx,n !!       character,intent(in)  :: uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: ap(*) !!       complex,intent(in)    :: x(*) !!       .. !! !!##DEFINITION !! !!  CHPR performs the hermitian rank 1 operation !! !!     A := alpha*x*x**H + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  AP !! !!           AP is COMPLEX array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine chpr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex , intent ( inout ) :: ap ( * ) complex , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , real !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'CHPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . real ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( j ) * temp ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ix = kx do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) + real ( x ( jx ) * temp ) else ap ( kk + j - 1 ) = real ( ap ( kk + j - 1 )) endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * conjg ( x ( j )) ap ( kk ) = real ( ap ( kk )) + real ( temp * x ( j )) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo else ap ( kk ) = real ( ap ( kk )) endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * conjg ( x ( jx )) ap ( kk ) = real ( ap ( kk )) + real ( temp * x ( jx )) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx ap ( k ) = ap ( k ) + x ( ix ) * temp enddo else ap ( kk ) = real ( ap ( kk )) endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif ! end subroutine chpr !> !!##NAME !!    crotg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate a hermitian Given's rotation. !! !!##SYNOPSIS !! !!     subroutine CROTG( a, b, c, s ) !! !!      .. Scalar Arguments .. !!         complex(wp),intent(inout) :: a !!         complex(wp),intent(in)    :: b !!         real(wp),intent(out)      :: c !!         complex(wp),intent(out)   :: s !! !!##DESCRIPTION !!   CROTG constructs a plane rotation !! !!      [  c         s ] [ a ] = [ r ] !!      [ -conjg(s)  c ] [ b ]   [ 0 ] !! !!   where c is real, s ic complex, and c**2 + conjg(s)*s = 1. !! !!  The computation uses the formulas !! !!     |x| = sqrt( Re(x)**2 + Im(x)**2 ) !!     sgn(x) = x / |x|  if x /= 0 !!            = 1        if x  = 0 !!     c = |a| / sqrt(|a|**2 + |b|**2) !!     s = sgn(a) * conjg(b) / sqrt(|a|**2 + |b|**2) !! !!  When a and b are real and r /= 0, the formulas simplify to !! !!     r = sgn(a)*sqrt(|a|**2 + |b|**2) !!     c = a / r !!     s = b / r !! !!  the same as in CROTG when |a| > |b|. When |b| >= |a|, the !!  sign of c and s will be different from those computed by CROTG !!  if the signs of a and b are not the same. !! !!##OPTIONS !!    A  On entry, the scalar a. On exit, the scalar r. !!    B  The scalar b. !!    C  The scalar c. !!    S  The scalar s. !! !!##AUTHORS !!  + Edward Anderson, Lockheed Martin !! !!##CONTRIBUTORS !!  + Weslley Pereira, University of Colorado Denver, USA !! !!##FURTHER DETAILS !!     Anderson E. (2017) !!     Algorithm 978: Safe Scaling in the Level 1 BLAS !!     ACM Trans Math Softw 44:1--28 !!     https://doi.org/10.1145/3061665 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine crotg ( a , b , c , s ) integer , parameter :: wp = kind ( 1.e0 ) ! !  -- Reference BLAS level1 routine -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp complex ( wp ), parameter :: czero = 0.0_wp !  .. !  .. Scaling constants .. real ( wp ), parameter :: safmin = real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) real ( wp ), parameter :: safmax = real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) real ( wp ), parameter :: rtmin = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) / epsilon ( 0._wp ) ) real ( wp ), parameter :: rtmax = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) * epsilon ( 0._wp ) ) !  .. !  .. Scalar Arguments .. complex ( wp ), intent ( inout ) :: a complex ( wp ), intent ( in ) :: b real ( wp ), intent ( out ) :: c complex ( wp ), intent ( out ) :: s !  .. !  .. Local Scalars .. real ( wp ) :: d , f1 , f2 , g1 , g2 , h2 , p , u , uu , v , vv , w complex ( wp ) :: f , fs , g , gs , r , t !  .. !  .. Intrinsic Functions .. intrinsic :: abs , aimag , conjg , max , min , real , sqrt !  .. !  .. Statement Functions .. real ( wp ) :: abssq !  .. !  .. Statement Function definitions .. abssq ( t ) = real ( t ) ** 2 + aimag ( t ) ** 2 !  .. !  .. Executable Statements .. ! f = a g = b if ( g == czero ) then c = one s = czero r = f elseif ( f == czero ) then c = zero g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! g2 = abssq ( g ) d = sqrt ( g2 ) s = conjg ( g ) / d r = d else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) d = sqrt ( g2 ) s = conjg ( gs ) / d r = d * u endif else f1 = max ( abs ( real ( f )), abs ( aimag ( f )) ) g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( f1 > rtmin . and . f1 < rtmax . and . & g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! f2 = abssq ( f ) g2 = abssq ( g ) h2 = f2 + g2 if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = f2 * p s = conjg ( g ) * ( f * p ) r = f * ( h2 * p ) else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , f1 , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) if ( f1 * uu < rtmin ) then ! !           f is not well-scaled when scaled by g1. !           Use a different scaling for f. ! v = min ( safmax , max ( safmin , f1 ) ) vv = one / v w = v * uu fs = f * vv f2 = abssq ( fs ) h2 = f2 * w ** 2 + g2 else ! !           Otherwise use the same scaling for f and g. ! w = one fs = f * uu f2 = abssq ( fs ) h2 = f2 + g2 endif if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = ( f2 * p ) * w s = conjg ( gs ) * ( fs * p ) r = ( fs * ( h2 * p ) ) * u endif endif a = r end subroutine crotg !> !!##NAME !!    cscal(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] scales a vector by a constant. !! CX:=CA*CX (complex multiplier) !! !!##SYNOPSIS !! !! !!     subroutine cscal(n,ca,cx,incx) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: ca !!       integer,intent(in)    :: incx,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: cx(*) !!       .. !! !!##DEFINITION !! !!     CSCAL scales a vector by a constant. !! !!##OPTIONS !!   N !!          number of elements in input vector(s) !!   CA !!          On entry, CA specifies the scalar alpha. !!   CX !!          CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !!          storage spacing between elements of CX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cscal ( n , ca , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: ca integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n cx ( i ) = ca * cx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx cx ( i ) = ca * cx ( i ) enddo endif end subroutine cscal !> !!##NAME !!    csrot(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] Applies a real Given's rotation to complex vectors. !! !!##SYNOPSIS !! !! !!     subroutine csrot( n, cx, incx, cy, incy, c, s ) !! !!       .. Scalar Arguments .. !!       integer,intent(in)       :: incx, incy, n !!       real,intent(in)          :: c, s !!       .. !!       .. Array Arguments .. !!       complex,intent(inout)    :: cx( * ), cy( * ) !!       .. !! !!##DEFINITION !! !!  CSROT applies a plane rotation, where the cos and sin (c and s) are real !!  and the vectors cx and cy are complex. !!  jack dongarra, linpack, 3/11/78. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the vectors cx and cy. !!            N must be at least zero. !! !!  CX !! !!           CX is COMPLEX array, dimension at least !!            ( 1 + ( N - 1 )*abs( INCX ) ). !!            Before entry, the incremented array CX must contain the n !!            element vector cx. On exit, CX is overwritten by the updated !!            vector cx. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            CX. INCX must not be zero. !! !!  CY !! !!           CY is COMPLEX array, dimension at least !!            ( 1 + ( N - 1 )*abs( INCY ) ). !!            Before entry, the incremented array CY must contain the n !!            element vector cy. On exit, CY is overwritten by the updated !!            vector cy. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            CY. INCY must not be zero. !! !!   C !! !!           C is REAL !!            On entry, C specifies the cosine, cos. !! !!   S !! !!           S is REAL !!            On entry, S specifies the sine, sin. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine csrot ( n , cx , incx , cy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n real , intent ( in ) :: c , s !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy complex ctemp !     .. !     .. Executable Statements .. ! if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = c * cx ( i ) + s * cy ( i ) cy ( i ) = c * cy ( i ) - s * cx ( i ) cx ( i ) = ctemp enddo else ! !        code for unequal increments or equal increments not equal !          to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = c * cx ( ix ) + s * cy ( iy ) cy ( iy ) = c * cy ( iy ) - s * cx ( ix ) cx ( ix ) = ctemp ix = ix + incx iy = iy + incy enddo endif end subroutine csrot !> !!##NAME !!    csscal(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] CSSCAL scales a complex vector by a real constant. !! CX:=SA*CX (real multiplier). !! !!##SYNOPSIS !! !!     subroutine csscal(n,sa,cx,incx) !! !!       .. scalar arguments .. !!       real,intent(in)       :: sa !!       integer,intent(in)    :: incx,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: cx(*) !!       .. !! !!##DEFINITION !! !!     CSSCAL scales a complex vector by a real constant. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SA !! !!           SA is REAL !!            On entry, SA specifies the scalar alpha. !! !!  CX !! !!           CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of CX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine csscal ( n , sa , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic aimag , cmplx , real !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n cx ( i ) = cmplx ( sa * real ( cx ( i )), sa * aimag ( cx ( i ))) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx cx ( i ) = cmplx ( sa * real ( cx ( i )), sa * aimag ( cx ( i ))) enddo endif end subroutine csscal !> !!##NAME !!    cswap(3f) - [BLAS:COMPLEX_BLAS_LEVEL1] Interchange vectors CX and CY. !! !!##SYNOPSIS !! !!     subroutine cswap(n,cx,incx,cy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: cx(*),cy(*) !!       .. !! !!##DEFINITION !! !!    CSWAP interchanges two vectors. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  CX !! !!           CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of CX !! !!  CY !! !!           CY is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of CY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine cswap ( n , cx , incx , cy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ), cy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ctemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 do i = 1 , n ctemp = cx ( i ) cx ( i ) = cy ( i ) cy ( i ) = ctemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = cx ( ix ) cx ( ix ) = cy ( iy ) cy ( iy ) = ctemp ix = ix + incx iy = iy + incy enddo endif end subroutine cswap !> !!##NAME !!    csymm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !! C:=alpha*A*B+beta*C, A symmetric, B, C rectangular. !! !!##SYNOPSIS !! !!     subroutine csymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: lda,ldb,ldc,m,n !!       character,intent(in)  :: side,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),b(ldb,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CSYMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is a symmetric matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the symmetric matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the symmetric matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   symmetric matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   symmetric matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is COMPLEX array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine csymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! !     End of CSYMM . ! end subroutine csymm !> !!##NAME !!    csyr2k(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !! C:=alpha*A*TRANSPOSE(B)+alpha*B*TRANSPOSE(A)+beta*C, C symmetric. !! !!##SYNOPSIS !! !!     subroutine csyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: k,lda,ldb,ldc,n !!       character,intent(in)  :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*),b(ldb,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CSYR2K performs one of the symmetric rank 2k operations !! !!     C := alpha*A*B**T + alpha*B*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*B + alpha*B**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A and B are n by k matrices in the first case and k by n !!  matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !!                                          beta*C. !! !!               TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !!                                          beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'T' or 't', K specifies the number of rows of the !!            matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is COMPLEX array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine csyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'CSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif ! !     End of CSYR2K. ! end subroutine csyr2k !> !!##NAME !!    csyrk(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !! C:=alpha*A*TRANSPOSE(A)+beta*C, C symmetric. !! !!##SYNOPSIS !! !!     subroutine csyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha,beta !!       integer,intent(in)    :: k,lda,ldc,n !!       character,intent(in)  :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  CSYRK performs one of the symmetric rank k operations !! !!     C := alpha*A*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A is an n by k matrix in the first case and a k by n matrix !!  in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrix A, and on entry with !!            TRANS = 'T' or 't', K specifies the number of rows of the !!            matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is COMPLEX !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is COMPLEX array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine csyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'CSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : n , j ) = c ( 1 : n , j ) + temp * a ( 1 : n , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! !     End of CSYRK . ! end subroutine csyrk !> !!##NAME !!    ctbmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := A*CX, A is a triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine ctbmv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,k,lda,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTBMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular band matrix, with ( k + 1 ) diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ). !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + conjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo else if ( nounit ) temp = temp * conjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + conjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + conjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo else if ( nounit ) temp = temp * conjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif ! !     End of CTBMV . ! end subroutine ctbmv !> !!##NAME !!    ctbsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := INVERSE(A)*CX, where A is a triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine ctbsv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,k,lda,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTBSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular band matrix, with ( k + 1 ) !!  diagonals. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'CTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - conjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( kplus1 , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - conjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( a ( kplus1 , j )) endif x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - conjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( 1 , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - conjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( a ( 1 , j )) endif x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif ! !     End of CTBSV . ! end subroutine ctbsv !> !!##NAME !!    ctpmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := A*CX, A is a packed triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine ctpmv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: ap(*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTPMV  performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is COMPLEX array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk - 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do i = j - 1 , 1 , - 1 temp = temp + conjg ( ap ( k )) * x ( i ) k = k - 1 enddo endif x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + conjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk + 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do i = j + 1 , n temp = temp + conjg ( ap ( k )) * x ( i ) k = k + 1 enddo endif x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( ap ( kk )) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + conjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif ! !     End of CTPMV . ! end subroutine ctpmv !> !!##NAME !!    ctpsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := INVERSE(A)*CX, where A is a packed triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine ctpsv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: ap(*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTPSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix, supplied in packed form. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is COMPLEX array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: ap ( * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'CTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk if ( noconj ) then do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do i = 1 , j - 1 temp = temp - conjg ( ap ( k )) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / conjg ( ap ( kk + j - 1 )) endif x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do k = kk , kk + j - 2 temp = temp - conjg ( ap ( k )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( ap ( kk + j - 1 )) endif x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( ap ( k )) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / conjg ( ap ( kk - n + j )) endif x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - conjg ( ap ( k )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( ap ( kk - n + j )) endif x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif ! !     End of CTPSV . ! end subroutine ctpsv !> !!##NAME !!    ctrmm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !! B:=A*B or B:=B*A, A triangular, B rectangular. !! !!##SYNOPSIS !! !!     subroutine ctrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       integer,intent(in)    :: lda,ldb,m,n !!       character,intent(in)  :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  CTRMM performs one of the matrix-matrix operations !! !!     B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !! !!  where alpha is a scalar, B is an m by n matrix, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) multiplies B from !!            the left or right as follows: !! !!               SIDE = 'L' or 'l'   B := alpha*op( A )*B. !! !!               SIDE = 'R' or 'r'   B := alpha*B*op( A ). !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**H. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, k ), where k is m !!            when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is COMPLEX array, dimension ( LDB, N ). !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B, and on exit is overwritten by the !!            transformed matrix. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * conjg ( a ( i , i )) do k = 1 , i - 1 temp = temp + conjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * conjg ( a ( i , i )) do k = i + 1 , m temp = temp + conjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * conjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * conjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif ! !     End of CTRMM . ! end subroutine ctrmm !> !!##NAME !!    ctrmv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := A*CX, A is a triangular matrix. !! !!##SYNOPSIS !! !!     subroutine ctrmv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,lda,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTRMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ). !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'CTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j - 1 , 1 , - 1 temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + conjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j + 1 , n temp = temp + conjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * conjg ( a ( j , j )) do i = j + 1 , n ix = ix + incx temp = temp + conjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif ! !     End of CTRMV . ! end subroutine ctrmv !> !!##NAME !!    ctrsm(3f) - [BLAS:COMPLEX_BLAS_LEVEL3] !! B:=INVERSE(A)*C or B:=C*INVERSE(A), B, C rectangular, A triangular. !! !!##SYNOPSIS !! !!     subroutine ctrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       complex,intent(in)    :: alpha !!       integer,intent(in)    :: lda,ldb,m,n !!       character,intent(in)  :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  CTRSM solves one of the matrix equations !! !!     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !! !!  where alpha is a scalar, X and B are m by n matrices, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !! !!  The matrix X is overwritten on B. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) appears on the left !!            or right of X as follows: !! !!               SIDE = 'L' or 'l'   op( A )*X = alpha*B. !! !!               SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**H. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is COMPLEX !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, k ), !!            where k is m when SIDE = 'L' or 'l' !!              and k is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is COMPLEX array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the right-hand side matrix B, and on exit is !!            overwritten by the solution matrix X. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: b ( ldb , * ) !     .. !  ===================================================================== !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. !     .. Local Scalars .. complex temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex one parameter ( one = ( 1.0e+0 , 0.0e+0 )) complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'CTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) if ( noconj ) then do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = 1 , i - 1 temp = temp - conjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / conjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) if ( noconj ) then do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = i + 1 , m temp = temp - conjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / conjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / conjg ( a ( k , k )) endif b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / conjg ( a ( k , k )) endif b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = conjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif end subroutine ctrsm !> !!##NAME !!    ctrsv(3f) - [BLAS:COMPLEX_BLAS_LEVEL2] !! CX := INVERSE(A)*CX, where A is a triangular matrix. !! !!##SYNOPSIS !! !!     subroutine ctrsv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,lda,n !!       character,intent(in)  :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex,intent(in)    :: a(lda,*) !!       complex,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  CTRSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is COMPLEX array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is COMPLEX array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ctrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex , intent ( in ) :: a ( lda , * ) complex , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex zero parameter ( zero = ( 0.0e+0 , 0.0e+0 )) !     .. !     .. Local Scalars .. complex temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic conjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'CTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - conjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n ix = kx temp = x ( jx ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - conjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 ix = kx temp = x ( jx ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - conjg ( a ( i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / conjg ( a ( j , j )) endif x ( jx ) = temp jx = jx - incx enddo endif endif endif ! !     End of CTRSV . ! end subroutine ctrsv !> !!##NAME !!    dasum(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] takes the sum of the absolute values. !! !!##SYNOPSIS !! !!     double precision function dasum(n,dx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in) :: dx(*) !!       .. !! !!##DEFINITION !! !!     DASUM takes the sum of the absolute values. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure double precision function dasum ( n , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic dabs , mod !     .. dasum = 0.0d0 dtemp = 0.0d0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 6 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dtemp + dabs ( dx ( i )) enddo if ( n . lt . 6 ) then dasum = dtemp return endif endif mp1 = m + 1 do i = mp1 , n , 6 dtemp = dtemp + dabs ( dx ( i )) + dabs ( dx ( i + 1 )) + dabs ( dx ( i + 2 )) + dabs ( dx ( i + 3 )) + dabs ( dx ( i + 4 )) + dabs ( dx ( i + 5 )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx dtemp = dtemp + dabs ( dx ( i )) enddo endif dasum = dtemp end function dasum !> !!##NAME !!    daxpy(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] constant times a vector plus a vector. !! !!##SYNOPSIS !! !!     subroutine daxpy(n,da,dx,incx,dy,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: da !!       integer,intent(in)             :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: dx(*) !!       double precision,intent(inout) :: dy(*) !!       .. !! !!##DEFINITION !! !!     DAXPY constant times a vector plus a vector. !!     uses unrolled loops for increments equal to one. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DA !! !!           DA is DOUBLE PRECISION !!            On entry, DA specifies the scalar alpha. !! !!   DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!  DY !! !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of DY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) double precision , intent ( inout ) :: dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( da . eq . 0.0d0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 4 ) if ( m . ne . 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) enddo endif if ( n . lt . 4 ) return mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine daxpy !> !!##NAME !!    dcabs1(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] DCABS1 computes !!    |Re(.)| + |Im(.)| of a double complex number !! !!##SYNOPSIS !! !!     double precision function dcabs1(z) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in) ::  Z !!       .. !! !!##DEFINITION !! !!  DCABS1 computes |Re(.)| + |Im(.)| of a double complex number !! !!##OPTIONS !! !!   Z !! !!           Z is complex(kind=real64) !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure double precision function dcabs1 ( z ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: z !     .. !  ===================================================================== ! !     .. Intrinsic Functions .. intrinsic abs , dble , dimag ! dcabs1 = abs ( dble ( z )) + abs ( dimag ( z )) end function dcabs1 !> !!##NAME !!    dcopy(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] copies elements of a vector, !!                x, to a vector, y. !! !!##SYNOPSIS !! !!     subroutine dcopy(n,dx,incx,dy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in)           :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)  :: dx(*) !!       double precision,intent(out) :: dy(*) !!       .. !! !!##DEFINITION !! !!     DCOPY copies a vector, x, to a vector, y. !!     uses unrolled loops for increments equal to 1. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!   DY !! !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of DY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dcopy ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) double precision , intent ( out ) :: dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 7 ) if ( m . ne . 0 ) then do i = 1 , m dy ( i ) = dx ( i ) enddo if ( n . lt . 7 ) return endif mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine dcopy !> !!##NAME !!    ddot(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] forms the dot product of two vectors. !! !!##SYNOPSIS !! !!     double precision function ddot(n,dx,incx,dy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in) :: dx(*),dy(*) !!       .. !! !!##DEFINITION !! !!     DDOT forms the dot product of two vectors. !!     uses unrolled loops for increments equal to one. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!   DY !! !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of DY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure double precision function ddot ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. ddot = 0.0d0 dtemp = 0.0d0 if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) enddo if ( n . lt . 5 ) then ddot = dtemp return endif endif mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy enddo endif ddot = dtemp end function ddot !> !!##NAME !!    dgbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: incx,incy,kl,ku,lda,m,n !!       character,intent(in)           :: trans !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),x(*) !!       double precision,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  DGBMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n band matrix, with kl sub-diagonals and ku super-diagonals. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   KL !! !!           KL is INTEGER !!            On entry, KL specifies the number of sub-diagonals of the !!            matrix A. KL must satisfy 0 .le. KL. !! !!   KU !! !!           KU is INTEGER !!            On entry, KU specifies the number of super-diagonals of the !!            matrix A. KU must satisfy 0 .le. KU. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry, the leading ( kl + ku + 1 ) by n part of the !!            array A must contain the matrix of coefficients, supplied !!            column by column, with the leading diagonal of the matrix in !!            row ( ku + 1 ) of the array, the first super-diagonal !!            starting at position 2 in row ku, the first sub-diagonal !!            starting at position 1 in row ( ku + 2 ), and so on. !!            Elements in the array A that do not correspond to elements !!            in the band matrix (such as the top left ku by ku triangle) !!            are not referenced. !!            The following program segment will transfer a band matrix !!            from conventional full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     K = KU + 1 - J !!                     DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !!                        A( K + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( kl + ku + 1 ). !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'DGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif ! end subroutine dgbmv !> !!##NAME !!    dgemm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       DOUBLE PRECISION,intent(in)    :: ALPHA,BETA !!       integer,intent(in)             :: k,lda,ldb,ldc,m,n !!       character,intent(in)           :: transa,transb !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),b(ldb,*) !!       double precision,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  DGEMM performs one of the matrix-matrix operations !! !!     C := alpha*op( A )*op( B ) + beta*C, !! !!  where op( X ) is one of !! !!     op( X ) = X   or   op( X ) = X**T, !! !!  alpha and beta are scalars, and A, B and C are matrices, with op( A ) !!  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. !! !!##OPTIONS !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n',  op( A ) = A. !! !!               TRANSA = 'T' or 't',  op( A ) = A**T. !! !!               TRANSA = 'C' or 'c',  op( A ) = A**T. !! !!   TRANSB !! !!           TRANSB is CHARACTER*1 !!            On entry, TRANSB specifies the form of op( B ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSB = 'N' or 'n',  op( B ) = B. !! !!               TRANSB = 'T' or 't',  op( B ) = B**T. !! !!               TRANSB = 'C' or 'c',  op( B ) = B**T. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix !!            op( A ) and of the matrix C. M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix !!            op( B ) and the number of columns of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of columns of the matrix !!            op( A ) and the number of rows of the matrix op( B ). K must !!            be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !!            k when TRANSA = 'N' or 'n', and is m otherwise. !!            Before entry with TRANSA = 'N' or 'n', the leading m by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by m part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANSA = 'N' or 'n' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, k ). !! !!   B !! !!           B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !!            n when TRANSB = 'N' or 'n', and is k otherwise. !!            Before entry with TRANSB = 'N' or 'n', the leading k by n !!            part of the array B must contain the matrix B, otherwise !!            the leading n by k part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANSB = 'N' or 'n' then !!            LDB must be at least max( 1, k ), otherwise LDB must be at !!            least max( 1, n ). !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is DOUBLE PRECISION array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n matrix !!            ( alpha*op( A )*op( B ) + beta*C ). !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , l , nrowa , nrowb logical nota , notb !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . lsame ( transa , 'C' )) . and . (. not . lsame ( transa , 'T' ))) then info = 1 else if ((. not . notb ) . and . (. not . lsame ( transb , 'C' )) . and . (. not . lsame ( transb , 'T' ))) then info = 2 else if ( m . lt . 0 ) then info = 3 else if ( n . lt . 0 ) then info = 4 else if ( k . lt . 0 ) then info = 5 else if ( lda . lt . max ( 1 , nrowa )) then info = 8 else if ( ldb . lt . max ( 1 , nrowb )) then info = 10 else if ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'DGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And if  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero else if ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( nota ) then ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = zero enddo else if ( beta . ne . one ) then do i = 1 , m c ( i , j ) = beta * c ( i , j ) enddo endif do l = 1 , k temp = alpha * b ( j , l ) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine dgemm !> !!##NAME !!    dgemv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: incx,incy,lda,m,n !!       character,intent(in)           :: trans !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),x(*) !!       double precision,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  DGEMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n matrix. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry with BETA non-zero, the incremented array Y !!            must contain the vector y. On exit, Y is overwritten by the !!            updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 else if ( m . lt . 0 ) then info = 2 else if ( n . lt . 0 ) then info = 3 else if ( lda . lt . max ( 1 , m )) then info = 6 else if ( incx . eq . 0 ) then info = 8 else if ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) y ( 1 : m ) = y ( 1 : m ) + temp * a ( 1 : m , j ) jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! end subroutine dgemv !> !!##NAME !!    dger(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dger(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: x(*),y(*) !!       double precision,intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  DGER performs the rank 1 operation !! !!     A := alpha*x*y**T + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the m !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. On exit, A is !!            overwritten by the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dger ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: x ( * ), y ( * ) double precision , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DGER  ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif ! end subroutine dger !> !!##NAME !!    dnrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] returns the euclidean norm of !!    a vector via the function name !! !!##SYNOPSIS !! !!     double precision function dnrm2(n,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx, n !!       .. !!       .. Array Arguments .. !!       real(wp),intent(in) :: x(*) !!        .. !! !!##DEFINITION !! !!  DNRM2 returns the euclidean norm of a vector via the function !!  name, so that !! !!     DNRM2 := sqrt( x'*x ) !! !!##OPTIONS !!   N !!           number of elements in input vector(s) !!   X !!           X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !!           INCX is INTEGER, storage spacing between elements of X !! !!            If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n !!            If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n !!            If INCX = 0, x isn't a vector so there is no need to call !!            this subroutine. If you call it anyway, it will count x(1) !!            in the vector norm N times. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  date:August 2016 !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!   Blue, James L. (1978) !!   A Portable Fortran Program to Find the Euclidean Norm of a Vector !!   ACM Trans Math Softw 4:15--23 !!   https://doi.org/10.1145/355769.355771 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure function dnrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.d0 ) real ( wp ) :: dnrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. real ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! dnrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( x ( ix )) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif dnrm2 = scl * sqrt ( sumsq ) return end function !> !!##NAME !!    drot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] DROT applies a plane rotation. !! !!##SYNOPSIS !! !!     subroutine drot(n,dx,incx,dy,incy,c,s) applies a plane rotation. !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: c,s !!       integer,intent(in)             :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: dx(*),dy(*) !!       .. !! !!##DEFINITION !! !!     DROT applies a plane rotation. !! !!##OPTIONS !! !!   N !!          number of elements in input vector(s) !!   DX !!           array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !! !!          storage spacing between elements of DX !! !!   DY !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY !!          storage spacing between elements of DY !!   C !!   S !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  \\ingroup double_blas_level1 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine drot ( n , dx , incx , dy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: c , s integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! do i = 1 , n dtemp = c * dx ( i ) + s * dy ( i ) dy ( i ) = c * dy ( i ) - s * dx ( i ) dx ( i ) = dtemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = c * dx ( ix ) + s * dy ( iy ) dy ( iy ) = c * dy ( iy ) - s * dx ( ix ) dx ( ix ) = dtemp ix = ix + incx iy = iy + incy enddo endif end subroutine drot !> !!##NAME !!    drotg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] constructs a plane rotation !! !!##SYNOPSIS !! !!    subroutine DROTG( a, b, c, s ) !! !!     .. Scalar Arguments .. !!     real(wp),intent(inout) :: a, b !!     real(wp),intent(out)   :: c, s !! !!##DEFINITION !!   DROTG constructs a plane rotation !! !!      [  c  s ] [ a ] = [ r ] !!      [ -s  c ] [ b ]   [ 0 ] !! !!   satisfying c**2 + s**2 = 1. !! !!  The computation uses the formulas !! !!     sigma = sgn(a)    if |a| >  |b| !!           = sgn(b)    if |b| >= |a| !!     r = sigma*sqrt( a**2 + b**2 ) !!     c = 1; s = 0      if r = 0 !!     c = a/r; s = b/r  if r != 0 !! !!  The subroutine also computes !! !!     z = s    if |a| > |b|, !!       = 1/c  if |b| >= |a| and c != 0 !!       = 1    if c = 0 !! !!  This allows c and s to be reconstructed from z as follows: !! !!     If z = 1, set c = 0, s = 1. !!     If |z| < 1, set c = sqrt(1 - z**2) and s = z. !!     If |z| > 1, set c = 1/z and s = sqrt( 1 - c**2). !! !!##OPTIONS !! !!   A !!           On entry, the scalar a. !!           On exit, the scalar r. !! !!   B !!           On entry, the scalar b. !!           On exit, the scalar z. !! !!   C !!           The scalar c. !! !!   S !!           The scalar s. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  \\ingroup single_blas_level1 !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine drotg ( a , b , c , s ) integer , parameter :: wp = kind ( 1.d0 ) ! !  -- Reference BLAS level1 routine -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp !  .. !  .. Scaling constants .. real ( wp ), parameter :: safmin = real ( radix ( 0.0_wp ), wp ) ** max ( minexponent ( 0.0_wp ) - 1 , 1 - maxexponent ( 0.0_wp ) ) real ( wp ), parameter :: safmax = real ( radix ( 0.0_wp ), wp ) ** max ( 1 - minexponent ( 0.0_wp ), maxexponent ( 0.0_wp ) - 1 ) !  .. !  .. Scalar Arguments .. real ( wp ), intent ( inout ) :: a , b real ( wp ), intent ( out ) :: c , s !  .. !  .. Local Scalars .. real ( wp ) :: anorm , bnorm , scl , sigma , r , z !  .. anorm = abs ( a ) bnorm = abs ( b ) if ( bnorm == zero ) then c = one s = zero b = zero elseif ( anorm == zero ) then c = zero s = one a = b b = one else scl = min ( safmax , max ( safmin , anorm , bnorm ) ) if ( anorm > bnorm ) then sigma = sign ( one , a ) else sigma = sign ( one , b ) endif r = sigma * ( scl * sqrt (( a / scl ) ** 2 + ( b / scl ) ** 2 ) ) c = a / r s = b / r if ( anorm > bnorm ) then z = s elseif ( c /= zero ) then z = one / c else z = one endif a = r b = z endif return end subroutine !> !!##NAME !!    drotm(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply the Modified Givens !!    Transformation, H, to the 2 by N matrix !! !!##SYNOPSIS !! !!     subroutine drotm(n,dx,incx,dy,incy,dparam) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: dparam(5) !!       double precision,intent(inout) :: dx(*),dy(*) !!       .. !! !!##DEFINITION !! !!     Apply the Modified Givens Transformation, H, to the 2 by N matrix !! !!     (DX**T) , where **T indicates transpose. the elements of DX are in !!     (DY**T) !! !!     DX(LX+I*INCX), I = 0 to N-1, where LX = 1 if INCX .ge. 0, else !!     LX = (-INCX)*N, and similarly for SY using LY and INCY. !!     with DPARAM(1)=DFLAG, H has one of the following forms.. !! !!        DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !! !!          (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !!        H=(          )    (          )    (          )    (          ) !!          (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !! !!     SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM. !! !!##OPTIONS !!   N !!          number of elements in input vector(s) !!   DX !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !!          storage spacing between elements of DX !! !!   DY !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY !!          storage spacing between elements of DY !! !!   DPARAM !!           array, dimension (5) !! !!            DPARAM(1)=DFLAG !!            DPARAM(2)=DH11 !!            DPARAM(3)=DH21 !!            DPARAM(4)=DH12 !!            DPARAM(5)=DH22 !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  \\ingroup double_blas_level1 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine drotm ( n , dx , incx , dy , incy , dparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dparam ( 5 ) double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dflag , dh11 , dh12 , dh21 , dh22 , w , z integer i , kx , ky , nsteps !     .. doubleprecision , parameter :: zero = 0.0d0 doubleprecision , parameter :: two = 2.0d0 !     .. ! dflag = dparam ( 1 ) if ( n . le . 0 . or . ( dflag + two . eq . zero )) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! nsteps = n * incx if ( dflag . lt . zero ) then dh11 = dparam ( 2 ) dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) dh22 = dparam ( 5 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w * dh11 + z * dh12 dy ( i ) = w * dh21 + z * dh22 enddo elseif ( dflag . eq . zero ) then dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w + z * dh12 dy ( i ) = w * dh21 + z enddo else dh11 = dparam ( 2 ) dh22 = dparam ( 5 ) do i = 1 , nsteps , incx w = dx ( i ) z = dy ( i ) dx ( i ) = w * dh11 + z dy ( i ) = - w + dh22 * z enddo endif else kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy ! if ( dflag . lt . zero ) then dh11 = dparam ( 2 ) dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) dh22 = dparam ( 5 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w * dh11 + z * dh12 dy ( ky ) = w * dh21 + z * dh22 kx = kx + incx ky = ky + incy enddo elseif ( dflag . eq . zero ) then dh12 = dparam ( 4 ) dh21 = dparam ( 3 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w + z * dh12 dy ( ky ) = w * dh21 + z kx = kx + incx ky = ky + incy enddo else dh11 = dparam ( 2 ) dh22 = dparam ( 5 ) do i = 1 , n w = dx ( kx ) z = dy ( ky ) dx ( kx ) = w * dh11 + z dy ( ky ) = - w + dh22 * z kx = kx + incx ky = ky + incy enddo endif endif end subroutine drotm !> !!##NAME !!    drotmg(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine drotmg(dd1,dd2,dx1,dy1,dparam) !! !!       .. Scalar Arguments .. !!       double precision,intent(inout) :: dd1,dd2,dx1 !!       double precision,intent(in)    :: dy1 !!       .. !!       .. Array Arguments .. !!       double precision,intent(out)   :: dparam(5) !!       .. !! !!##DEFINITION !! !!     CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS !!     THE SECOND COMPONENT OF THE 2-VECTOR (DSQRT(DD1)*DX1,DSQRT(DD2)*> DY2)**T. !!     WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !! !!        DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0 !! !!          (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0) !!        H=(          )    (          )    (          )    (          ) !!          (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0). !! !!     LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22 !!     RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE !!     VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.) !! !!     THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE !!     INEXACT. THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE !!     OF DD1 AND DD2. ALL ACTUAL SCALING OF DATA IS DONE USING GAM. !! !!##OPTIONS !! !!  DD1 !! !!           DD1 is DOUBLE PRECISION !! !!  DD2 !! !!           DD2 is DOUBLE PRECISION !! !!  DX1 !! !!           DX1 is DOUBLE PRECISION !! !!   DY1 !! !!           DY1 is DOUBLE PRECISION !! !!   DPARAM !! !!           DPARAM is DOUBLE PRECISION array, dimension (5) !!      DPARAM(1)=DFLAG !!      DPARAM(2)=DH11 !!      DPARAM(3)=DH21 !!      DPARAM(4)=DH12 !!      DPARAM(5)=DH22 !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine drotmg ( dd1 , dd2 , dx1 , dy1 , dparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( inout ) :: dd1 , dd2 , dx1 double precision , intent ( in ) :: dy1 !     .. !     .. Array Arguments .. double precision , intent ( out ) :: dparam ( 5 ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dflag , dh11 , dh12 , dh21 , dh22 , dp1 , dp2 , dq1 , dq2 , dtemp , du !     .. !     .. Intrinsic Functions .. intrinsic dabs !     .. !     .. Data statements .. ! doubleprecision , parameter :: zero = 0.0d0 doubleprecision , parameter :: one = 1.0d0 doubleprecision , parameter :: two = 2.0d0 doubleprecision , parameter :: gam = 409 6.d0 doubleprecision , parameter :: gamsq = 1677721 6.d0 doubleprecision , parameter :: rgamsq = 5.9604645d-8 !     .. if ( dd1 . lt . zero ) then !        GO ZERO-H-D-AND-DX1.. dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero else !        CASE-DD1-NONNEGATIVE dp2 = dd2 * dy1 if ( dp2 . eq . zero ) then dflag = - two dparam ( 1 ) = dflag return endif !        REGULAR-CASE.. dp1 = dd1 * dx1 dq2 = dp2 * dy1 dq1 = dp1 * dx1 ! if ( dabs ( dq1 ). gt . dabs ( dq2 )) then dh21 = - dy1 / dx1 dh12 = dp2 / dp1 ! du = one - dh12 * dh21 ! if ( du . gt . zero ) then dflag = zero dd1 = dd1 / du dd2 = dd2 / du dx1 = dx1 * du else !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero endif else if ( dq2 . lt . zero ) then !              GO ZERO-H-D-AND-DX1.. dflag = - one dh11 = zero dh12 = zero dh21 = zero dh22 = zero ! dd1 = zero dd2 = zero dx1 = zero else dflag = one dh11 = dp1 / dp2 dh22 = dx1 / dy1 du = one + dh11 * dh22 dtemp = dd2 / du dd2 = dd1 / du dd1 = dtemp dx1 = dy1 * du endif endif !     PROCEDURE..SCALE-CHECK if ( dd1 . ne . zero ) then do while (( dd1 . le . rgamsq ) . or . ( dd1 . ge . gamsq )) if ( dflag . eq . zero ) then dh11 = one dh22 = one dflag = - one else dh21 = - one dh12 = one dflag = - one endif if ( dd1 . le . rgamsq ) then dd1 = dd1 * gam ** 2 dx1 = dx1 / gam dh11 = dh11 / gam dh12 = dh12 / gam else dd1 = dd1 / gam ** 2 dx1 = dx1 * gam dh11 = dh11 * gam dh12 = dh12 * gam endif enddo endif if ( dd2 . ne . zero ) then do while ( ( dabs ( dd2 ). le . rgamsq ) . or . ( dabs ( dd2 ). ge . gamsq ) ) if ( dflag . eq . zero ) then dh11 = one dh22 = one dflag = - one else dh21 = - one dh12 = one dflag = - one endif if ( dabs ( dd2 ). le . rgamsq ) then dd2 = dd2 * gam ** 2 dh21 = dh21 / gam dh22 = dh22 / gam else dd2 = dd2 / gam ** 2 dh21 = dh21 * gam dh22 = dh22 * gam endif enddo endif endif if ( dflag . lt . zero ) then dparam ( 2 ) = dh11 dparam ( 3 ) = dh21 dparam ( 4 ) = dh12 dparam ( 5 ) = dh22 elseif ( dflag . eq . zero ) then dparam ( 3 ) = dh21 dparam ( 4 ) = dh12 else dparam ( 2 ) = dh11 dparam ( 5 ) = dh22 endif dparam ( 1 ) = dflag end subroutine drotmg !> !!##NAME !!    dsbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dsbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: incx,incy,k,lda,n !!       character,intent(in)           :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),x(*) !!       double precision,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  DSBMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric band matrix, with k super-diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the band matrix A is being supplied as !!            follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   being supplied. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   being supplied. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of super-diagonals of the !!            matrix A. K must satisfy 0 .le. K. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the symmetric matrix, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer the upper !!            triangular part of a symmetric band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the symmetric matrix, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer the lower !!            triangular part of a symmetric band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. !! !!  Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DSBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( kplus1 , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( kplus1 , j ) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( 1 , j ) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( 1 , j ) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsbmv !> !!##NAME !!    dscal(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] scales a vector by a constant. !! !!##SYNOPSIS !! !!     subroutine dscal(n,da,dx,incx) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: da !!       integer,intent(in)             :: incx,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: dx(*) !!       .. !! !!##DEFINITION !! !!     DSCAL scales a vector by a constant. !!     uses unrolled loops for increment equal to 1. !! !!##OPTIONS !!   N !!           number of elements in input vector(s) !!   DA !!           On entry, DA specifies the scalar alpha. !!   DX !!           array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !!           storage spacing between elements of DX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dscal ( n , da , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) enddo if ( n . lt . 5 ) return endif mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) enddo endif end subroutine dscal !> !!##NAME !!    dsdot(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     double precision function dsdot(n,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in) :: sx(*),sy(*) !!       .. !! !! !!##DEFINITION !! !!  Compute the inner product of two vectors with extended !!  precision accumulation and result. !! !!  Returns D.P. dot product accumulated in D.P., for S.P. SX and SY !!  DSDOT = sum for I = 0 to N-1 of SX(LX+I*INCX) * SY(LY+I*INCY), !!  where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !!  defined in a similar way using INCY. !! !!##OPTIONS !! !!  N       number of elements in input vector(s) !!  SX      array, dimension(N) !!          single precision vector with N elements !!  INCX    storage spacing between elements of SX !!  SY      array, dimension(N) !!          single precision vector with N elements !!  INCY    storage spacing between elements of SY !! !!##RETURN !! !!  DSDOT   dot product (zero if N.LE.0) !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!     Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !!     Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) !! !!  REFERENCES !! !!   C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !!   Krogh, Basic linear algebra subprograms for Fortran !!   usage, Algorithm No. 539, Transactions on Mathematical !!   Software 5, 3 (September 1979), pp. 308-323. !! !!   REVISION HISTORY !! !!      1979-10-01  DATE WRITTEN !!      1989-08-31  Modified array declarations. (WRB) !!      1989-08-31  REVISION DATE from Version 3.2 !!      1989-12-14  Prologue converted to Version 4.0 format. (BAB) !!      1992-03-10  Corrected definition of LX in DESCRIPTION. (WRB) !!      1992-05-01  Reformatted the REFERENCES section. (WRB) !!      1907-01-18  Reformat to LAPACK style (JL) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure double precision function dsdot ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. ! !  Authors: !  ======== !  Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !  Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) !  ===================================================================== ! !     .. Local Scalars .. integer i , kx , ky , ns !     .. !     .. Intrinsic Functions .. intrinsic dble !     .. dsdot = 0.0d0 if ( n . le . 0 ) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! !     Code for equal, positive, non-unit increments. ! ns = n * incx do i = 1 , ns , incx dsdot = dsdot + dble ( sx ( i )) * dble ( sy ( i )) enddo else ! !     Code for unequal or nonpositive increments. ! kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy do i = 1 , n dsdot = dsdot + dble ( sx ( kx )) * dble ( sy ( ky )) kx = kx + incx ky = ky + incy enddo endif end function dsdot !> !!##NAME !!    dspmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dspmv(uplo,n,alpha,ap,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: incx,incy,n !!       character,intent(in)           :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: ap(*),x(*) !!       double precision,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  DSPMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   AP !! !!           AP is DOUBLE PRECISION array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DSPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * ap ( kk ) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * ap ( kk ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif ! end subroutine dspmv !> !!##NAME !!    dspr2(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dspr2(uplo,n,alpha,x,incx,y,incy,ap) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: incx,incy,n !!       character,intent(in)            :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: ap(*) !!       double precision,intent(in)    :: x(*),y(*) !!       .. !! !!##DEFINITION !!  DSPR2 performs the symmetric rank 2 operation !! !!     A := alpha*x*y**T + alpha*y*x**T + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an !!  n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  AP !! !!           AP is DOUBLE PRECISION array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: ap ( * ) double precision , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DSPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif ! end subroutine dspr2 !> !!##NAME !!    dspr(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dspr(uplo,n,alpha,x,incx,ap) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: incx,n !!       character,intent(in)           :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: ap(*) !!       double precision,intent(in)    :: x(*) !!       .. !! !!##DESCRIPTION !! !!  DSPR performs the symmetric rank 1 operation !! !!     A := alpha*x*x**T + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  AP !! !!           AP is DOUBLE PRECISION array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with  UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dspr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: ap ( * ) double precision , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'DSPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif ! end subroutine dspr !> !!##NAME !!    dswap(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] interchanges two vectors. !! !!##SYNOPSIS !! !!     subroutine dswap(n,dx,incx,dy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: dx(*),dy(*) !!       .. !! !!##DEFINITION !! !!     DSWAP interchanges two vectors. !!     uses unrolled loops for increments equal to 1. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!  DY !! !!           DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of DY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dswap ( n , dx , incx , dy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: dx ( * ), dy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dtemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! ! !       clean-up loop ! m = mod ( n , 3 ) if ( m . ne . 0 ) then do i = 1 , m dtemp = dx ( i ) dx ( i ) = dy ( i ) dy ( i ) = dtemp enddo if ( n . lt . 3 ) return endif mp1 = m + 1 do i = mp1 , n , 3 dtemp = dx ( i ) dx ( i ) = dy ( i ) dy ( i ) = dtemp dtemp = dx ( i + 1 ) dx ( i + 1 ) = dy ( i + 1 ) dy ( i + 1 ) = dtemp dtemp = dx ( i + 2 ) dx ( i + 2 ) = dy ( i + 2 ) dy ( i + 2 ) = dtemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dx ( ix ) dx ( ix ) = dy ( iy ) dy ( iy ) = dtemp ix = ix + incx iy = iy + incy enddo endif end subroutine dswap !> !!##NAME !!    dsymm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: lda,ldb,ldc,m,n !!       character,intent(in)           :: side,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),b(ldb,*) !!       double precision,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  DSYMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is a symmetric matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the symmetric matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the symmetric matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   symmetric matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   symmetric matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !! !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is DOUBLE PRECISION array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is DOUBLE PRECISION array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'DSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif ! end subroutine dsymm !> !!##NAME !!    dsymv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dsymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: incx,incy,lda,n !!       character,intent(in)           :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),x(*) !!       double precision,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  DSYMV performs the matrix-vector  operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), x ( * ) double precision , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'DSYMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( j , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( j , j ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( j , j ) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( j , j ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsymv !> !!##NAME !!    dsyr2(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dsyr2(uplo,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: incx,incy,lda,n !!       character,intent(in)           :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout) :: a(lda,*) !!       double precision,intent(in)    :: x(*),y(*) !!       .. !! !!##DEFINITION !! !!  DSYR2 performs the symmetric rank 2 operation !! !!     A := alpha*x*y**T + alpha*y*x**T + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an n !!  by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: a ( lda , * ) double precision , intent ( in ) :: x ( * ), y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = 1 , j a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = j , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif endif ! end subroutine dsyr2 !> !!##NAME !!    dsyr2k(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: k,lda,ldb,ldc,n !!       character,intent(in)           :: trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*),b(ldb,*) !!       double precision,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  DSYR2K performs one of the symmetric rank 2k operations !! !!     C := alpha*A*B**T + alpha*B*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*B + alpha*B**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A and B are n by k matrices in the first case and k by n !!  matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !!                                         beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !!                                         beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !!                                         beta*C. !! !!   N !! !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'T' or 't' or 'C' or 'c', K specifies the number !!            of rows of the matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the  calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is DOUBLE PRECISION array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ), b ( ldb , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif ! end subroutine dsyr2k !> !!##NAME !!    dsyr(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dsyr(uplo,n,alpha,x,incx,a,lda) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)       :: alpha !!       integer,intent(in)                :: incx,lda,n !!       character,intent(in)              :: uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(inout)    :: a(lda,*) !!       double precision,intent(in)       :: x(*) !!       .. !! !!##DEFINITION !! !!  DSYR performs the symmetric rank 1 operation !! !!     A := alpha*x*x**T + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  \\ingroup double_blas_level2 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsyr ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. double precision , intent ( inout ) :: a ( lda , * ) double precision , intent ( in ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DSYR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( 1 : j , j ) = a ( 1 : j , j ) + x ( 1 : j ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( j : n , j ) = a ( j : n , j ) + x ( j : n ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif endif ! end subroutine dsyr !> !!##NAME !!    dsyrk(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha,beta !!       integer,intent(in)             :: k,lda,ldc,n !!       character,intent(in)           :: trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  DSYRK performs one of the symmetric rank k operations !! !!     C := alpha*A*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A is an n by k matrix in the first case and a k by n matrix !!  in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrix A, and on entry with !!            TRANS = 'T' or 't' or 'C' or 'c', K specifies the number !!            of rows of the matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is DOUBLE PRECISION array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  \\ingroup double_blas_level3 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dsyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 else if ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 else if ( n . lt . 0 ) then info = 3 else if ( k . lt . 0 ) then info = 4 else if ( lda . lt . max ( 1 , nrowa )) then info = 7 else if ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'DSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero else if ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero else if ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + temp * a ( j : n , l ) endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine dsyrk !> !!##NAME !!    dtbmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dtbmv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,k,lda,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTBMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular band matrix, with ( k + 1 ) diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  \\ingroup double_blas_level2 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif ! end subroutine dtbmv !> !!##NAME !!    dtbsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dtbsv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,k,lda,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTBSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular band matrix, with ( k + 1 ) !!  diagonals. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  \\ingroup double_blas_level2 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'DTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T)*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif ! end subroutine dtbsv !> !!##NAME !!    dtpmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dtpmv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: ap(*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTPMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is DOUBLE PRECISION array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  \\ingroup double_blas_level2 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk - 1 do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk + 1 do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif ! end subroutine dtpmv !> !!##NAME !!    dtpsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dtpsv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: ap(*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTPSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix, supplied in packed form. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is DOUBLE PRECISION array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: ap ( * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'DTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif ! end subroutine dtpsv !> !!##NAME !!    dtrmm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dtrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: lda,ldb,m,n !!       character,intent(in)           :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  DTRMM performs one of the matrix-matrix operations !! !!     B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !! !!  where alpha is a scalar, B is an m by n matrix, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) multiplies B from !!            the left or right as follows: !! !!               SIDE = 'L' or 'l'   B := alpha*op( A )*B. !! !!               SIDE = 'R' or 'r'   B := alpha*B*op( A ). !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**T. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!            A is DOUBLE PRECISION array, dimension ( LDA, k ), where k is m !!            when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is DOUBLE PRECISION array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B, and on exit is overwritten by the !!            transformed matrix. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif ! end subroutine dtrmm !> !!##NAME !!    dtrmv(3f) - [BLAS:DOUBLE_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine dtrmv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,lda,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTRMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'DTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif ! end subroutine dtrmv !> !!##NAME !!    dtrsm(3f) - [BLAS:DOUBLE_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine dtrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)    :: alpha !!       integer,intent(in)             :: lda,ldb,m,n !!       character,intent(in)           :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  DTRSM solves one of the matrix equations !! !!     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !! !!  where alpha is a scalar, X and B are m by n matrices, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T. !! !!  The matrix X is overwritten on B. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) appears on the left !!            or right of X as follows: !! !!               SIDE = 'L' or 'l'   op( A )*X = alpha*B. !! !!               SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**T. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, k ), !! !!            where k is m when SIDE = 'L' or 'l' !!              and k is n when SIDE = 'R' or 'r'. !! !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !! !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !! !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !!            Before entry, the leading m by n part of the array B must !!            contain the right-hand side matrix B, and on exit is !!            overwritten by the solution matrix X. !! !!   LDB !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. double precision temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'DTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif ! end subroutine dtrsm !> !!##NAME !!    dtrsv(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine dtrsv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)             :: incx,lda,n !!       character,intent(in)           :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       double precision,intent(in)    :: a(lda,*) !!       double precision,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  DTRSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is DOUBLE PRECISION array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is DOUBLE PRECISION array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine dtrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. double precision , intent ( in ) :: a ( lda , * ) double precision , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. double precision zero parameter ( zero = 0.0d+0 ) !     .. !     .. Local Scalars .. double precision temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !     .. !     .. External Subroutines .. !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'DTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine dtrsv !> !!##NAME !!    dzasum(3f) - [BLAS:DOUBLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     double precision function dzasum(n,zx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(inout) :: zx(*) !!       .. !! !!##DEFINITION !! !!     DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !!     returns a double precision result. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== double precision function dzasum ( n , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision stemp integer i , nincx !     .. !     .. External Functions ..  DOUBLE PRECISION DCABS1 !     .. dzasum = 0.0d0 stemp = 0.0d0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n stemp = stemp + dcabs1 ( zx ( i )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + dcabs1 ( zx ( i )) enddo endif dzasum = stemp end function dzasum !> !!##NAME !!    dznrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     double precision function dznrm2(n,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx, n !!       .. !! !!##DEFINITION !! !!  DZNRM2 returns the euclidean norm of a vector via the function !!  name, so that !! !!     DZNRM2 := sqrt( x**H*x ) !! !!##OPTIONS !! !!   N !!          number of elements in input vector(s) !!   X !!          array, dimension (N) complex vector with N elements !!   INCX !!           INCX is INTEGER, storage spacing between elements of X !! !!             If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n !!             If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n !!             If INCX = 0, x isn't a vector so there is no need to call !! !!           this subroutine. If you call it anyway, it will count x(1) !!           in the vector norm N times. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  date:August 2016 !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!   Blue, James L. (1978) !!   A Portable Fortran Program to Find the Euclidean Norm of a Vector !!   ACM Trans Math Softw 4:15--23 !!   https://doi.org/10.1145/355769.355771 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure function dznrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.d0 ) real ( wp ) :: dznrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. complex ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! dznrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( real ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ax = abs ( aimag ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif dznrm2 = scl * sqrt ( sumsq ) end function dznrm2 !> !!##NAME !!    icamax(3f) -- [BLAS:AUX_BLAS] Return index of maximum \"absolute value\" in CX. !! !!##SYNOPSIS !! !!     integer function icamax(n,cx,incx) !! !!       .. scalar arguments .. !!       integer,intent(in) :: incx,n !!       .. !!       .. array arguments .. !!       complex,intent(in) :: cx(*) !!       .. !! !!##DEFINITION !! !!     ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)| !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   CX !! !!           CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of CX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure integer function icamax ( n , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( in ) :: cx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real smax integer i , ix !     .. !     .. External Functions ..  REAL SCABS1 !     .. icamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return icamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! smax = scabs1 ( cx ( 1 )) do i = 2 , n if ( scabs1 ( cx ( i )). gt . smax ) then icamax = i smax = scabs1 ( cx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 smax = scabs1 ( cx ( 1 )) ix = ix + incx do i = 2 , n if ( scabs1 ( cx ( ix )). gt . smax ) then icamax = i smax = scabs1 ( cx ( ix )) endif ix = ix + incx enddo endif end function icamax !> !!##NAME !!    idamax(3f) - [BLAS:AUX_BLAS] !! !!##SYNOPSIS !! !!     integer function idamax(n,dx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)          :: incx,n !!       .. !!       .. Array Arguments .. !!       double precision,intent(in) :: dx(*) !!       .. !! !!##DEFINITION !! !!     IDAMAX finds the index of the first element having maximum absolute value. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DX !! !!           DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of DX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure integer function idamax ( n , dx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. double precision , intent ( in ) :: dx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. double precision dmax integer i , ix !     .. !     .. Intrinsic Functions .. intrinsic dabs !     .. idamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return idamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! dmax = dabs ( dx ( 1 )) do i = 2 , n if ( dabs ( dx ( i )). gt . dmax ) then idamax = i dmax = dabs ( dx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 dmax = dabs ( dx ( 1 )) ix = ix + incx do i = 2 , n if ( dabs ( dx ( ix )). gt . dmax ) then idamax = i dmax = dabs ( dx ( ix )) endif ix = ix + incx enddo endif end function idamax !> !!##NAME !!    isamax(3f) - [BLAS:AUX_BLAS] Return index of maximum absolute value in SX. !! !!##SYNOPSIS !! !!     integer function isamax(n,sx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,n !!       .. !!       .. Array Arguments .. !!       real,intent(in) :: sx(*) !!       .. !! !!##DEFINITION !! !!     ISAMAX finds the index of the first element having maximum absolute value. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== integer function isamax ( n , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real smax integer i , ix !     .. !     .. Intrinsic Functions .. intrinsic abs !     .. isamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return isamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! smax = abs ( sx ( 1 )) do i = 2 , n if ( abs ( sx ( i )). gt . smax ) then isamax = i smax = abs ( sx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 smax = abs ( sx ( 1 )) ix = ix + incx do i = 2 , n if ( abs ( sx ( ix )). gt . smax ) then isamax = i smax = abs ( sx ( ix )) endif ix = ix + incx enddo endif end function isamax !> !!##NAME !!    izamax(3f) - [BLAS:AUX_BLAS] !! !!##SYNOPSIS !! !!     integer function izamax(n,zx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)              :: incx,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in) :: zx(*) !!       .. !! !!##DEFINITION !! !!     IZAMAX finds the index of the first element having maximum |Re(.)| !!     + |Im(.)| !! !!##OPTIONS !! !!  N       number of elements in input vector(s) !!  ZX      array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!  INCX    storage spacing between elements of ZX !! !!##RETURNS !!  IZAMAX  index of the first element having maximum !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 1/15/85. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure integer function izamax ( n , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. double precision dmax integer i , ix !     .. !     .. External Functions ..  DOUBLE PRECISION DCABS1 !     .. izamax = 0 if ( n . lt . 1 . or . incx . le . 0 ) return izamax = 1 if ( n . eq . 1 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! dmax = dcabs1 ( zx ( 1 )) do i = 2 , n if ( dcabs1 ( zx ( i )). gt . dmax ) then izamax = i dmax = dcabs1 ( zx ( i )) endif enddo else ! !        code for increment not equal to 1 ! ix = 1 dmax = dcabs1 ( zx ( 1 )) ix = ix + incx do i = 2 , n if ( dcabs1 ( zx ( ix )). gt . dmax ) then izamax = i dmax = dcabs1 ( zx ( ix )) endif ix = ix + incx enddo endif end function izamax !> !!##NAME !!    lsame(3f) - [BLAS:AUX_BLAS] compare two letters ignoring case !! !!##SYNOPSIS !! !!     logical function lsame(ca,cb) !! !!       .. Scalar Arguments .. !!       character(len=1),intent(in) :: ca,cb !!       .. !! !!##DEFINITION !! !!  LSAME returns .TRUE. if CA is the same letter as CB regardless of !!  case. !! !!##OPTIONS !! !!   CA !! !!           CA is CHARACTER*1 !! !!   CB !! !!           CB is CHARACTER*1 !!           CA and CB specify the single characters to be compared. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure logical function lsame ( ca , cb ) implicit none !  -- Reference BLAS level1 routine (version 3.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 !     .. Scalar Arguments .. character ( len = 1 ), intent ( in ) :: ca , cb !     .. ! ===================================================================== !     .. Intrinsic Functions .. intrinsic iachar !     .. !     .. Local Scalars .. integer :: inta , intb !     .. !     Test if the characters are equal lsame = ca . eq . cb if ( lsame ) return !     Now test for equivalence after converting uppercase to lowercase !     if characters are alphameric inta = ichar ( ca ) intb = ichar ( cb ) if ( inta . ge . 97 . and . inta . le . 122 ) inta = inta - 32 if ( intb . ge . 97 . and . intb . le . 122 ) intb = intb - 32 lsame = inta . eq . intb end function lsame !> !!##NAME !!    sasum(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SASUM:=sum of absolute values of SX. !! !!##SYNOPSIS !! !!     real function sasum(n,sx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,n !!       .. !!       .. Array Arguments .. !!       real,intent(in) :: sx(*) !!       .. !! !!##DEFINITION !! !!     SASUM takes the sum of the absolute values. !!     uses unrolled loops for increment equal to one. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure real function sasum ( n , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic abs , mod !     .. sasum = 0.0e0 stemp = 0.0e0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 6 ) if ( m . ne . 0 ) then do i = 1 , m stemp = stemp + abs ( sx ( i )) enddo if ( n . lt . 6 ) then sasum = stemp return endif endif mp1 = m + 1 do i = mp1 , n , 6 stemp = stemp + abs ( sx ( i )) + abs ( sx ( i + 1 )) + abs ( sx ( i + 2 )) + abs ( sx ( i + 3 )) + abs ( sx ( i + 4 )) + abs ( sx ( i + 5 )) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + abs ( sx ( i )) enddo endif sasum = stemp end function sasum !> !!##NAME !!    saxpy(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SY:=SY+SA*SX (constant times a vector plus a vector) !! !!##SYNOPSIS !! !!     subroutine saxpy(n,sa,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)     :: sa !!       integer,intent(in)  :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in)     :: sx(*) !!       real,intent(inout)  :: sy(*) !!       .. !! !!##DEFINITION !! !!     SAXPY constant times a vector plus a vector. !!     uses unrolled loops for increments equal to one. !! !!##OPTIONS !!   N !!          number of elements in input vector(s) !!   SA !!          On entry, SA specifies the scalar alpha. !!   SX !!          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX !!          storage spacing between elements of SX !!   SY !!          SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY !!          storage spacing between elements of SY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine saxpy ( n , sa , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) real , intent ( inout ) :: sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( sa . eq . 0.0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 4 ) if ( m . ne . 0 ) then do i = 1 , m sy ( i ) = sy ( i ) + sa * sx ( i ) enddo endif if ( n . lt . 4 ) return mp1 = m + 1 do i = mp1 , n , 4 sy ( i ) = sy ( i ) + sa * sx ( i ) sy ( i + 1 ) = sy ( i + 1 ) + sa * sx ( i + 1 ) sy ( i + 2 ) = sy ( i + 2 ) + sa * sx ( i + 2 ) sy ( i + 3 ) = sy ( i + 3 ) + sa * sx ( i + 3 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n sy ( iy ) = sy ( iy ) + sa * sx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine saxpy !> !!##NAME !!    scabs1(3f) - [BLAS:SINGLE_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     elemental real function scabs1(z) !! !!       .. Scalar Arguments .. !!       complex,intent(in) ::  z !!       .. !! !!##DEFINITION !! !!  SCABS1 computes |Re(.)| + |Im(.)| of a complex number !! !!##OPTIONS !! !!   Z !! !!           Z is COMPLEX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure elemental real function scabs1 ( z ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex , intent ( in ) :: z !     .. !  ===================================================================== !     .. Intrinsic Functions .. intrinsic abs , aimag , real !     .. scabs1 = abs ( real ( z )) + abs ( aimag ( z )) end function scabs1 !> !!##NAME !!    scasum(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SCASUM:=SUM(I=1 to N) ABS(REAL(CX(I)))+ABS(AIMAG(CX(I))). !! !!##SYNOPSIS !! !!     real function scasum(n,cx,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)    :: incx,n !!       .. !!       .. Array Arguments .. !!       complex,intent(inout) :: cx(*) !!       .. !! !!##DEFINITION !! !!     SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and !!     returns a single precision result. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  CX !! !!           CX is COMPLEX array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== real function scasum ( n , cx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex , intent ( inout ) :: cx ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. real stemp integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic abs , aimag , real !     .. scasum = 0.0e0 stemp = 0.0e0 if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n stemp = stemp + abs ( real ( cx ( i ))) + abs ( aimag ( cx ( i ))) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx stemp = stemp + abs ( real ( cx ( i ))) + abs ( aimag ( cx ( i ))) enddo endif scasum = stemp end function scasum !> !!##NAME !!    scnrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SCNRM2:= square root of sum of magnitudes of entries of CX. !! !!##SYNOPSIS !! !!     real function scnrm2(n,x,incx) !! !!      .. !!      .. Scalar Arguments .. !!      integer,intent(in) :: incx, n !!      .. !!      .. Array Arguments .. !!      complex(wp),intent(in) :: x(*) !!      .. !! !!##DEFINITION !! !!  SCNRM2 returns the euclidean norm of a vector via the function !!  name, so that !! !!     SCNRM2 := sqrt( x**H*x ) !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   X !! !!           X is COMPLEX array, dimension (N) !!          complex vector with N elements !! !!   INCX !! !!           INCX is INTEGER, storage spacing between elements of X !!           If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n !!           If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n !!           If INCX = 0, x isn't a vector so there is no need to call !!           this subroutine. If you call it anyway, it will count x(1) !!           in the vector norm N times. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  date:August 2016 !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!   Blue, James L. (1978) !!   A Portable Fortran Program to Find the Euclidean Norm of a Vector !!   ACM Trans Math Softw 4:15--23 !!   https://doi.org/10.1145/355769.355771 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure function scnrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.e0 ) real ( wp ) :: scnrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. complex ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! scnrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( real ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ax = abs ( aimag ( x ( ix ))) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif scnrm2 = scl * sqrt ( sumsq ) end function scnrm2 !> !!##NAME !!    scopy(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SY:=SX !! !!##SYNOPSIS !! !!     subroutine scopy(n,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in)  :: sx(*) !!       real,intent(out) :: sy(*) !!       .. !! !!##DEFINITION !! !!     SCOPY copies a vector, x, to a vector, y. !!     uses unrolled loops for increments equal to 1. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!   SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of SY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine scopy ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ) real , intent ( out ) :: sy ( * ) !     .. !  ===================================================================== !     .. Local Scalars .. integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 7 ) if ( m . ne . 0 ) then do i = 1 , m sy ( i ) = sx ( i ) enddo if ( n . lt . 7 ) return endif mp1 = m + 1 do i = mp1 , n , 7 sy ( i ) = sx ( i ) sy ( i + 1 ) = sx ( i + 1 ) sy ( i + 2 ) = sx ( i + 2 ) sy ( i + 3 ) = sx ( i + 3 ) sy ( i + 4 ) = sx ( i + 4 ) sy ( i + 5 ) = sx ( i + 5 ) sy ( i + 6 ) = sx ( i + 6 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n sy ( iy ) = sx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine scopy !> !!##NAME !!    sdot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SDOT := SUM SX * SY (vector dot product) !! !!##SYNOPSIS !! !!     real function sdot(n,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in) :: sx(*),sy(*) !!       .. !! !!##DEFINITION !! !!     SDOT forms the dot product of two vectors. !!     uses unrolled loops for increments equal to one. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!   SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of SY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure real function sdot ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. stemp = 0.0e0 sdot = 0.0e0 if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m stemp = stemp + sx ( i ) * sy ( i ) enddo if ( n . lt . 5 ) then sdot = stemp return endif endif mp1 = m + 1 do i = mp1 , n , 5 stemp = stemp + sx ( i ) * sy ( i ) + sx ( i + 1 ) * sy ( i + 1 ) + sx ( i + 2 ) * sy ( i + 2 ) + sx ( i + 3 ) * sy ( i + 3 ) + sx ( i + 4 ) * sy ( i + 4 ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = stemp + sx ( ix ) * sy ( iy ) ix = ix + incx iy = iy + incy enddo endif sdot = stemp end function sdot !> !!##NAME !!    sdsdot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Compute the inner !!    product of two vectors with extended precision accumulation. !! SDSDOT := SUM SX * SY (accumulated double precision, returned single) !! !!##SYNOPSIS !! !!     real function sdsdot(n,sb,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in) :: sb !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in) :: sx(*),sy(*) !!       .. !! !!##DEFINITION !! !!    Compute the inner product of two vectors with extended !!    precision accumulation. !! !!    Returns S.P. result with dot product accumulated in D.P. !!    SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I*INCX)*SY(LY+I*INCY), !!    where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is !!    defined in a similar way using INCY. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!           number of elements in input vector(s) !! !!   SB !! !!           SB is REAL !!           single precision scalar to be added to inner product !! !!   SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!           single precision vector with N elements !! !!   INCX !! !!           INCX is INTEGER !!           storage spacing between elements of SX !! !!   SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!           single precision vector with N elements !! !!   INCY !! !!           INCY is INTEGER !!           storage spacing between elements of SY !! !!##AUTHORS !! !! + Lawson, C. L., (JPL), Hanson, R. J., (SNLA), !! + Kincaid, D. R., (U. of Texas), Krogh, F. T., (JPL) !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!     REFERENCES !! !!     C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. !!     Krogh, Basic linear algebra subprograms for Fortran !!     usage, Algorithm No. 539, Transactions on Mathematical !!     Software 5, 3 (September 1979), pp. 308-323. !! !!     REVISION HISTORY (YYMMDD) !! !!     791001  DATE WRITTEN !!     890531  Changed all specific intrinsics to generic.  (WRB) !!     890831  Modified array declarations.  (WRB) !!     890831  REVISION DATE from Version 3.2 !!     891214  Prologue converted to Version 4.0 format.  (BAB) !!     920310  Corrected definition of LX in DESCRIPTION.  (WRB) !!     920501  Reformatted the REFERENCES section.  (WRB) !!     070118  Reformat to LAPACK coding style !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure real function sdsdot ( n , sb , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sb integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sx ( * ), sy ( * ) !     .. !     .. Local Scalars .. double precision dsdot integer i , kx , ky , ns !     .. !     .. Intrinsic Functions .. intrinsic dble !     .. dsdot = sb if ( n . le . 0 ) then sdsdot = real ( dsdot ) return endif if ( incx . eq . incy . and . incx . gt . 0 ) then ! !     Code for equal and positive increments. ! ns = n * incx do i = 1 , ns , incx dsdot = dsdot + dble ( sx ( i )) * dble ( sy ( i )) enddo else ! !     Code for unequal or nonpositive increments. ! kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy do i = 1 , n dsdot = dsdot + dble ( sx ( kx )) * dble ( sy ( ky )) kx = kx + incx ky = ky + incy enddo endif sdsdot = real ( dsdot ) end function sdsdot !> !!##NAME !!    sgbmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] !! SY:=alpha*A*SX+beta*SY, A a band matrix. !! !!##SYNOPSIS !! !!     subroutine sgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)             :: alpha,beta !!       integer,intent(in)          :: incx,incy,kl,ku,lda,m,n !!       character(len=1),intent(in) :: trans !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: a(lda,*),x(*) !!       real,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  SGBMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n band matrix, with kl sub-diagonals and ku super-diagonals. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   KL !! !!           KL is INTEGER !!            On entry, KL specifies the number of sub-diagonals of the !!            matrix A. KL must satisfy 0 .le. KL. !! !!   KU !! !!           KU is INTEGER !!            On entry, KU specifies the number of super-diagonals of the !!            matrix A. KU must satisfy 0 .le. KU. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry, the leading ( kl + ku + 1 ) by n part of the !!            array A must contain the matrix of coefficients, supplied !!            column by column, with the leading diagonal of the matrix in !!            row ( ku + 1 ) of the array, the first super-diagonal !!            starting at position 2 in row ku, the first sub-diagonal !!            starting at position 1 in row ( ku + 2 ), and so on. !!            Elements in the array A that do not correspond to elements !!            in the band matrix (such as the top left ku by ku triangle) !!            are not referenced. !!            The following program segment will transfer a band matrix !!            from conventional full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     K = KU + 1 - J !!                     DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !!                        A( K + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( kl + ku + 1 ). !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character ( len = 1 ), intent ( in ) :: trans !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'SGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif end subroutine sgbmv !> !!##NAME !!    sgemm(3f) - [BLAS:SINGLE_BLAS_LEVEL3] !! C:=alpha*A*B+beta*C, A, B, C rectangular. !! !!##SYNOPSIS !! !!     subroutine sgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: k,lda,ldb,ldc,m,n !!       character,intent(in) :: transa,transb !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: a(lda,*),b(ldb,*) !!       real,intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  SGEMM performs one of the matrix-matrix operations !! !!     C := alpha*op( A )*op( B ) + beta*C, !! !!  where op( X ) is one of !! !!     op( X ) = X   or   op( X ) = X**T, !! !!  alpha and beta are scalars, and A, B and C are matrices, with op( A ) !!  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. !! !!##OPTIONS !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n',  op( A ) = A. !! !!               TRANSA = 'T' or 't',  op( A ) = A**T. !! !!               TRANSA = 'C' or 'c',  op( A ) = A**T. !! !!   TRANSB !! !!           TRANSB is CHARACTER*1 !!            On entry, TRANSB specifies the form of op( B ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSB = 'N' or 'n',  op( B ) = B. !! !!               TRANSB = 'T' or 't',  op( B ) = B**T. !! !!               TRANSB = 'C' or 'c',  op( B ) = B**T. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix !!            op( A ) and of the matrix C. M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix !!            op( B ) and the number of columns of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of columns of the matrix !!            op( A ) and the number of rows of the matrix op( B ). K must !!            be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, ka ), where ka is !!            k when TRANSA = 'N' or 'n', and is m otherwise. !! !!            Before entry with TRANSA = 'N' or 'n', the leading m by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by m part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANSA = 'N' or 'n' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, k ). !! !!   B !! !!           B is REAL array, dimension ( LDB, kb ), where kb is !!            n when TRANSB = 'N' or 'n', and is k otherwise. !! !!            Before entry with TRANSB = 'N' or 'n', the leading k by n !!            part of the array B must contain the matrix B, otherwise !!            the leading n by k part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANSB = 'N' or 'n' then !!            LDB must be at least max( 1, k ), otherwise LDB must be at !!            least max( 1, n ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is REAL array, dimension ( LDC, N ) !! !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !! !!            On exit, the array C is overwritten by the m by n matrix !!            ( alpha*op( A )*op( B ) + beta*C ). !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , l , nrowa , nrowb logical nota , notb !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     transposed and set  NROWA and NROWB  as the number of rows of  A !     and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . lsame ( transa , 'C' )) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . lsame ( transb , 'C' )) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'SGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And if  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( nota ) then ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( j , l ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine sgemm !> !!##NAME !!    sgemv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] !! SY:=alpha*A*SX+beta*SY, A a rectangular matrix. !! !!##SYNOPSIS !! !!     subroutine sgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: incx,incy,lda,m,n !!       character,intent(in) :: trans !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: a(lda,*),x(*) !!       real,intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  SGEMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n matrix. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry with BETA non-zero, the incremented array Y !!            must contain the vector y. On exit, Y is overwritten by the !!            updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'SGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif end subroutine sgemv !> !!##NAME !!    sger(3f) - [BLAS:SINGLE_BLAS_LEVEL2] !! A:=A+alpha*SX*TRANSPOSE(SY), rank 1 update, A a rectangular matrix. !! !!##SYNOPSIS !! !!     subroutine sger(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       real,intent(in)    :: alpha !!       integer,intent(in) :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: x(*),y(*) !!       real,intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  SGER performs the rank 1 operation !! !!     A := alpha*x*y**T + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the m !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. On exit, A is !!            overwritten by the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sger ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SGER  ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine sger !> !!##NAME !!    snrm2(3f) - [BLAS:SINGLE_BLAS_LEVEL1] !! SNRM2 := square root of sum of SX(I)**2 !! !!##SYNOPSIS !! !!     real function snrm2(n,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx, n !!       .. !!       .. Array Arguments .. !!       real(wp),intent(in) :: x(*) !!       .. !! !!##DEFINITION !! !!  SNRM2 returns the euclidean norm of a vector via the function !!  name, so that !! !!     SNRM2 := sqrt( x'*x ). !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   X !! !!           X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER, storage spacing between elements of X !!           If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n !!           If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n !!           If INCX = 0, x isn't a vector so there is no need to call !!           this subroutine. If you call it anyway, it will count x(1) !!           in the vector norm N times. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  date:August 2016 !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!   Blue, James L. (1978) !!   A Portable Fortran Program to Find the Euclidean Norm of a Vector !!   ACM Trans Math Softw 4:15--23 !!   https://doi.org/10.1145/355769.355771 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== function snrm2 ( n , x , incx ) integer , parameter :: wp = kind ( 1.e0 ) real ( wp ) :: snrm2 ! !  -- Reference BLAS level1 routine (version 3.9.1) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     March 2021 ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: maxn = huge ( 0.0_wp ) !  .. !  .. Blue's scaling constants .. real ( wp ), parameter :: tsml = real ( radix ( 0._wp ), wp ) ** ceiling ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp ) real ( wp ), parameter :: tbig = real ( radix ( 0._wp ), wp ) ** floor ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp ) real ( wp ), parameter :: ssml = real ( radix ( 0._wp ), wp ) ** ( - floor ( ( minexponent ( 0._wp ) - 1 ) * 0.5_wp )) real ( wp ), parameter :: sbig = real ( radix ( 0._wp ), wp ) ** ( - ceiling ( ( maxexponent ( 0._wp ) - digits ( 0._wp ) + 1 ) * 0.5_wp )) !  .. !  .. Scalar Arguments .. integer , intent ( in ) :: incx , n !  .. !  .. Array Arguments .. real ( wp ), intent ( in ) :: x ( * ) !  .. !  .. Local Scalars .. integer :: i , ix logical :: notbig real ( wp ) :: abig , amed , asml , ax , scl , sumsq , ymax , ymin ! !  Quick return if possible ! snrm2 = zero if ( n <= 0 ) return ! scl = one sumsq = zero ! !  Compute the sum of squares in 3 accumulators: !     abig -- sums of squares scaled down to avoid overflow !     asml -- sums of squares scaled up to avoid underflow !     amed -- sums of squares that do not require scaling !  The thresholds and multipliers are !     tbig -- values bigger than this are scaled down by sbig !     tsml -- values smaller than this are scaled up by ssml ! notbig = . true . asml = zero amed = zero abig = zero ix = 1 if ( incx < 0 ) ix = 1 - ( n - 1 ) * incx do i = 1 , n ax = abs ( x ( ix )) if ( ax > tbig ) then abig = abig + ( ax * sbig ) ** 2 notbig = . false . elseif ( ax < tsml ) then if ( notbig ) asml = asml + ( ax * ssml ) ** 2 else amed = amed + ax ** 2 endif ix = ix + incx enddo ! !  Combine abig and amed or amed and asml if more than one !  accumulator was used. ! if ( abig > zero ) then ! !     Combine abig and amed if abig > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then abig = abig + ( amed * sbig ) * sbig endif scl = one / sbig sumsq = abig elseif ( asml > zero ) then ! !     Combine amed and asml if asml > 0. ! if ( ( amed > zero ) . or . ( amed > maxn ) . or . ( amed /= amed ) ) then amed = sqrt ( amed ) asml = sqrt ( asml ) / ssml if ( asml > amed ) then ymin = amed ymax = asml else ymin = asml ymax = amed endif scl = one sumsq = ymax ** 2 * ( one + ( ymin / ymax ) ** 2 ) else scl = one / ssml sumsq = asml endif else ! !     Otherwise all values are mid-range ! scl = one sumsq = amed endif snrm2 = scl * sqrt ( sumsq ) end function snrm2 !> !!##NAME !!    srot(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply Given's rotation. !! !!##SYNOPSIS !! !!     subroutine srot(n,sx,incx,sy,incy,c,s) !! !!       .. Scalar Arguments .. !!       real,intent(in)    :: c,s !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(inout) :: sx(*),sy(*) !!       .. !! !!##DEFINITION !! !!     applies a plane rotation. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!  SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of SY !! !!   C !! !!           C is REAL !! !!   S !! !!           S is REAL !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine srot ( n , sx , incx , sy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: c , s integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! do i = 1 , n stemp = c * sx ( i ) + s * sy ( i ) sy ( i ) = c * sy ( i ) - s * sx ( i ) sx ( i ) = stemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = c * sx ( ix ) + s * sy ( iy ) sy ( iy ) = c * sy ( iy ) - s * sx ( ix ) sx ( ix ) = stemp ix = ix + incx iy = iy + incy enddo endif end subroutine srot !> !!##NAME !!    srotg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate Given's rotation. !! !!##SYNOPSIS !! !! !!   subroutine srotg( a, b, c, s ) !! !!    .. Scalar Arguments .. !!    real(wp),intent(inout) :: a, b !!    real(wp),intent(out)   :: c, s !!    .. !!    .. Local Scalars .. !!    real(wp) :: anorm, bnorm, scl, sigma, r, z !!    .. !! !!##DEFINITION !!   SROTG constructs a plane rotation !! !!      [  c  s ] [ a ] = [ r ] !!      [ -s  c ] [ b ]   [ 0 ] !! !!   satisfying c**2 + s**2 = 1. !! !!  The computation uses the formulas !! !!     sigma = sgn(a)    if |a| >  |b| !!           = sgn(b)    if |b| >= |a| !!     r = sigma*sqrt( a**2 + b**2 ) !!     c = 1; s = 0      if r = 0 !!     c = a/r; s = b/r  if r != 0 !! !!  The subroutine also computes !! !!     z = s    if |a| > |b|, !!       = 1/c  if |b| >= |a| and c != 0 !!       = 1    if c = 0 !! !!  This allows c and s to be reconstructed from z as follows: !! !!     If z = 1, set c = 0, s = 1. !!     If |z| < 1, set c = sqrt(1 - z**2) and s = z. !!     If |z| > 1, set c = 1/z and s = sqrt( 1 - c**2). !! !!##OPTIONS !! !!  A !! !!           A is REAL !!           On entry, the scalar a. !!           On exit, the scalar r. !! !!  B !! !!           B is REAL !!           On entry, the scalar b. !!           On exit, the scalar z. !! !!   C !! !!           C is REAL !!           The scalar c. !! !!   S !! !!           S is REAL !!           The scalar s. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine srotg ( a , b , c , s ) integer , parameter :: wp = kind ( 1.e0 ) ! !  -- Reference BLAS level1 routine -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp !  .. !  .. Scaling constants .. real ( wp ), parameter :: safmin = real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) real ( wp ), parameter :: safmax = real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) !  .. !  .. Scalar Arguments .. real ( wp ), intent ( inout ) :: a , b real ( wp ), intent ( out ) :: c , s !  .. !  .. Local Scalars .. real ( wp ) :: anorm , bnorm , scl , sigma , r , z !  .. !  .. Intrinsics intrinsic :: abs , sqrt , max , sign , min anorm = abs ( a ) bnorm = abs ( b ) if ( bnorm == zero ) then c = one s = zero b = zero elseif ( anorm == zero ) then c = zero s = one a = b b = one else scl = min ( safmax , max ( safmin , anorm , bnorm ) ) if ( anorm > bnorm ) then sigma = sign ( one , a ) else sigma = sign ( one , b ) endif r = sigma * ( scl * sqrt (( a / scl ) ** 2 + ( b / scl ) ** 2 ) ) c = a / r s = b / r if ( anorm > bnorm ) then z = s elseif ( c /= zero ) then z = one / c else z = one endif a = r b = z endif end subroutine !> !!##NAME !!    srotm(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Apply a modified Given's rotation. !! !!##SYNOPSIS !! !!     subroutine srotm(n,sx,incx,sy,incy,sparam) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: sparam(5) !!       real,intent(inout) :: sx(*),sy(*) !!       .. !! !!##DEFINITION !! !!     APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX !! !!     (SX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN !!     (SX**T) !! !!     SX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE !!     LX = (-INCX)*N, AND SIMILARLY FOR SY USING USING LY AND INCY. !!     WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS.. !! !!        SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !! !!          (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !!        H=(          )    (          )    (          )    (          ) !!          (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !! !!     SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!  SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of SY !! !!   SPARAM !! !!           SPARAM is REAL array, dimension (5) !!      SPARAM(1)=SFLAG !!      SPARAM(2)=SH11 !!      SPARAM(3)=SH21 !!      SPARAM(4)=SH12 !!      SPARAM(5)=SH22 !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine srotm ( n , sx , incx , sy , incy , sparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( in ) :: sparam ( 5 ) real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real sflag , sh11 , sh12 , sh21 , sh22 , w , z real , parameter :: zero = 0.0e0 real , parameter :: two = 2.0e0 integer i , kx , ky , nsteps !     .. ! sflag = sparam ( 1 ) if ( n . le . 0 . or . ( sflag + two . eq . zero )) return if ( incx . eq . incy . and . incx . gt . 0 ) then ! nsteps = n * incx if ( sflag . lt . zero ) then sh11 = sparam ( 2 ) sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) sh22 = sparam ( 5 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w * sh11 + z * sh12 sy ( i ) = w * sh21 + z * sh22 enddo elseif ( sflag . eq . zero ) then sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w + z * sh12 sy ( i ) = w * sh21 + z enddo else sh11 = sparam ( 2 ) sh22 = sparam ( 5 ) do i = 1 , nsteps , incx w = sx ( i ) z = sy ( i ) sx ( i ) = w * sh11 + z sy ( i ) = - w + sh22 * z enddo endif else kx = 1 ky = 1 if ( incx . lt . 0 ) kx = 1 + ( 1 - n ) * incx if ( incy . lt . 0 ) ky = 1 + ( 1 - n ) * incy ! if ( sflag . lt . zero ) then sh11 = sparam ( 2 ) sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) sh22 = sparam ( 5 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w * sh11 + z * sh12 sy ( ky ) = w * sh21 + z * sh22 kx = kx + incx ky = ky + incy enddo elseif ( sflag . eq . zero ) then sh12 = sparam ( 4 ) sh21 = sparam ( 3 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w + z * sh12 sy ( ky ) = w * sh21 + z kx = kx + incx ky = ky + incy enddo else sh11 = sparam ( 2 ) sh22 = sparam ( 5 ) do i = 1 , n w = sx ( kx ) z = sy ( ky ) sx ( kx ) = w * sh11 + z sy ( ky ) = - w + sh22 * z kx = kx + incx ky = ky + incy enddo endif endif end subroutine srotm !> !!##NAME !!    srotmg(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Generate a modified Given's rotation. !! !!##SYNOPSIS !! !!     subroutine srotmg(sd1,sd2,sx1,sy1,sparam) !! !!       .. Scalar Arguments .. !!       real,intent(inout) :: sd1,sd2,sx1 !!       real,intent(in)    :: sy1 !!       .. !!       .. Array Arguments .. !!       real,intent(out)   :: sparam(5) !!       .. !! !!##DEFINITION !! !!     Construct the modified Givens Transformation Matrix H which zeros !!     the second component of the 2-vector !! !!      (sqrt(sd1)*sx1,sqrt(sd2)*>sy2)**t. !! !!     with sparam(1)=sflag, H has one of the following forms.. !! !!        SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0 !! !!          (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0) !!        H=(          )    (          )    (          )    (          ) !!          (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0). !! !!     locations 2-4 of SPARAM contain SH11,SH21,SH12, and SH22 !!     respectively. (values of 1.e0, -1.e0, or 0.e0 implied by the value !!     of SPARAM(1) are not stored in SPARAM.) !! !!     the values of GAMSQ and RGAMSQ set in the data statement may be !!     inexact. This is OK as they are only used for testing the size of !!     SD1 and SD2. All actual scaling of data is done using GAM. !! !!##OPTIONS !! !!  SD1 !! !!           SD1 is REAL !! !!  SD2 !! !!           SD2 is REAL !! !!  SX1 !! !!           SX1 is REAL !! !!   SY1 !! !!           SY1 is REAL !! !!   SPARAM !! !!           SPARAM is REAL array, dimension (5) !!      SPARAM(1)=SFLAG !!      SPARAM(2)=SH11 !!      SPARAM(3)=SH21 !!      SPARAM(4)=SH12 !!      SPARAM(5)=SH22 !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine srotmg ( sd1 , sd2 , sx1 , sy1 , sparam ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( inout ) :: sd1 , sd2 , sx1 real , intent ( in ) :: sy1 !     .. !     .. Array Arguments .. real , intent ( out ) :: sparam ( 5 ) !     .. !  ===================================================================== ! !     .. Local Scalars .. real sflag , sh11 , sh12 , sh21 , sh22 , sp1 , sp2 , sq1 , sq2 , stemp , su !     .. !     .. Intrinsic Functions .. intrinsic abs !     .. !     .. Data statements .. real , parameter :: zero = 0.0e0 real , parameter :: one = 1.0e0 real , parameter :: two = 2.0e0 ! real , parameter :: gam = 409 6.e0 real , parameter :: gamsq = 1.67772e7 real , parameter :: rgamsq = 5.96046e-8 !     .. if ( sd1 . lt . zero ) then !        GO ZERO-H-D-AND-SX1.. sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero else !        CASE-SD1-NONNEGATIVE sp2 = sd2 * sy1 if ( sp2 . eq . zero ) then sflag = - two sparam ( 1 ) = sflag return endif !        REGULAR-CASE.. sp1 = sd1 * sx1 sq2 = sp2 * sy1 sq1 = sp1 * sx1 ! if ( abs ( sq1 ). gt . abs ( sq2 )) then sh21 = - sy1 / sx1 sh12 = sp2 / sp1 ! su = one - sh12 * sh21 ! if ( su . gt . zero ) then sflag = zero sd1 = sd1 / su sd2 = sd2 / su sx1 = sx1 * su else !            This code path if here for safety. We do not expect this !            condition to ever hold except in edge cases with rounding !            errors. See DOI: 10.1145/355841.355847 sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero endif else if ( sq2 . lt . zero ) then !              GO ZERO-H-D-AND-SX1.. sflag = - one sh11 = zero sh12 = zero sh21 = zero sh22 = zero ! sd1 = zero sd2 = zero sx1 = zero else sflag = one sh11 = sp1 / sp2 sh22 = sx1 / sy1 su = one + sh11 * sh22 stemp = sd2 / su sd2 = sd1 / su sd1 = stemp sx1 = sy1 * su endif endif !     PROCEDURE..SCALE-CHECK if ( sd1 . ne . zero ) then do while (( sd1 . le . rgamsq ) . or . ( sd1 . ge . gamsq )) if ( sflag . eq . zero ) then sh11 = one sh22 = one sflag = - one else sh21 = - one sh12 = one sflag = - one endif if ( sd1 . le . rgamsq ) then sd1 = sd1 * gam ** 2 sx1 = sx1 / gam sh11 = sh11 / gam sh12 = sh12 / gam else sd1 = sd1 / gam ** 2 sx1 = sx1 * gam sh11 = sh11 * gam sh12 = sh12 * gam endif enddo endif if ( sd2 . ne . zero ) then do while ( ( abs ( sd2 ). le . rgamsq ) . or . ( abs ( sd2 ). ge . gamsq ) ) if ( sflag . eq . zero ) then sh11 = one sh22 = one sflag = - one else sh21 = - one sh12 = one sflag = - one endif if ( abs ( sd2 ). le . rgamsq ) then sd2 = sd2 * gam ** 2 sh21 = sh21 / gam sh22 = sh22 / gam else sd2 = sd2 / gam ** 2 sh21 = sh21 * gam sh22 = sh22 * gam endif enddo endif endif if ( sflag . lt . zero ) then sparam ( 2 ) = sh11 sparam ( 3 ) = sh21 sparam ( 4 ) = sh12 sparam ( 5 ) = sh22 elseif ( sflag . eq . zero ) then sparam ( 3 ) = sh21 sparam ( 4 ) = sh12 else sparam ( 2 ) = sh11 sparam ( 5 ) = sh22 endif sparam ( 1 ) = sflag end subroutine srotmg !> !!##NAME !!    ssbmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SY:=alpha*A*SX+beta*SY, A a symmetric band matrix. !! !!##SYNOPSIS !! !!     subroutine ssbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: incx,incy,k,lda,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*),x(*) !!       real,intent(inout)   :: y(*) !!       .. !! !!##DEFINITION !! !!  SSBMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric band matrix, with k super-diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the band matrix A is being supplied as !!            follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   being supplied. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   being supplied. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of super-diagonals of the !!            matrix A. K must satisfy 0 .le. K. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the symmetric matrix, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer the upper !!            triangular part of a symmetric band matrix from conventional !!            full matrix storage to band storage: !! !!               >    DO 20, J = 1, N !!               >       M = K + 1 - J !!               >       DO 10, I = MAX( 1, J - K ), J !!               >          A( M + I, J ) = matrix( I, J ) !!               > 10    CONTINUE !!               > 20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the symmetric matrix, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer the lower !!            triangular part of a symmetric band matrix from conventional !!            full matrix storage to band storage: !! !!               >    DO 20, J = 1, N !!               >       M = 1 - J !!               >       DO 10, I = J, MIN( N, J + K ) !!               >          A( M + I, J ) = matrix( I, J ) !!               > 10    CONTINUE !!               > 20 CONTINUE !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. !! !!  Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'SSBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( kplus1 , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( kplus1 , j ) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( 1 , j ) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( 1 , j ) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + a ( l + i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssbmv !> !!##NAME !!    sscal(3f) - [BLAS:SINGLE_BLAS_LEVEL1] SX:=SA*SX. !! !!##SYNOPSIS !! !!     subroutine sscal(n,sa,sx,incx) !! !!       .. Scalar Arguments .. !!       real,intent(in)    :: sa !!       integer,intent(in) :: incx,n !!       .. !!       .. Array Arguments .. !!       real,intent(inout) :: sx(*) !!       .. !! !!##DEFINITION !! !!     SSCAL scales a vector by a constant. !!     uses unrolled loops for increment equal to 1. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   SA !! !!           SA is REAL !!            On entry, SA specifies the scalar alpha. !! !!  SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sscal ( n , sa , sx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. real , intent ( in ) :: sa integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , m , mp1 , nincx !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! ! !        clean-up loop ! m = mod ( n , 5 ) if ( m . ne . 0 ) then do i = 1 , m sx ( i ) = sa * sx ( i ) enddo if ( n . lt . 5 ) return endif mp1 = m + 1 do i = mp1 , n , 5 sx ( i ) = sa * sx ( i ) sx ( i + 1 ) = sa * sx ( i + 1 ) sx ( i + 2 ) = sa * sx ( i + 2 ) sx ( i + 3 ) = sa * sx ( i + 3 ) sx ( i + 4 ) = sa * sx ( i + 4 ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx sx ( i ) = sa * sx ( i ) enddo endif end subroutine sscal !> !!##NAME !!    sspmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SY:=alpha*A*SX+beta*SY, A a packed symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine sspmv(uplo,n,alpha,ap,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: incx,incy,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: ap(*),x(*) !!       real,intent(inout)   :: y(*) !!       .. !! !!##DEFINITION !! !!  SSPMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   AP !! !!           AP is REAL array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sspmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SSPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * ap ( kk + j - 1 ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * ap ( kk ) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * ap ( kk ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + ap ( k ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif end subroutine sspmv !> !!##NAME !!    sspr2(3f) - [BLAS:SINGLE_BLAS_LEVEL2] A:=A+alpha*SX*TRANSPOSE(SY)+alpha*SY*TRANSPOSE(SX), A packed symmetric. !! !!##SYNOPSIS !! !!     subroutine sspr2(uplo,n,alpha,x,incx,y,incy,ap) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: incx,incy,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: x(*),y(*) !!       real,intent(inout)   :: ap(*) !!       .. !! !!##DEFINITION !! !!  SSPR2 performs the symmetric rank 2 operation !! !!     A := alpha*x*y**T + alpha*y*x**T + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an !!  n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  AP !! !!           AP is REAL array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sspr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'SSPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif end subroutine sspr2 !> !!##NAME !!    sspr(3f) - [BLAS:SINGLE_BLAS_LEVEL2] A:=A+alpha*SX*TRANSPOSE(SX), A a packed symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine sspr(uplo,n,alpha,x,incx,ap) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: incx,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: x(*) !!       real,intent(inout) :: ap(*) !!       .. !! !!##DEFINITION !! !!  SSPR performs the symmetric rank 1 operation !! !!     A := alpha*x*x**T + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n symmetric matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  AP !! !!           AP is REAL array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the symmetric matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sspr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ) real , intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'SSPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = 1 , j ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do k = kk , kk + j - 1 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) k = kk do i = j , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do k = kk , kk + n - j ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif end subroutine sspr !> !!##NAME !!    sswap(3f) - [BLAS:SINGLE_BLAS_LEVEL1] Interchange vectors SX and SY. !! !!##SYNOPSIS !! !!     subroutine sswap(n,sx,incx,sy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       real,intent(inout) :: sx(*),sy(*) !!       .. !! !!##DEFINITION !! !!     SSWAP interchanges two vectors. !!     uses unrolled loops for increments equal to 1. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  SX !! !!           SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of SX !! !!  SY !! !!           SY is REAL array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of SY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine sswap ( n , sx , incx , sy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. real , intent ( inout ) :: sx ( * ), sy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. real stemp integer i , ix , iy , m , mp1 !     .. !     .. Intrinsic Functions .. intrinsic mod !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 ! ! !       clean-up loop ! m = mod ( n , 3 ) if ( m . ne . 0 ) then do i = 1 , m stemp = sx ( i ) sx ( i ) = sy ( i ) sy ( i ) = stemp enddo if ( n . lt . 3 ) return endif mp1 = m + 1 do i = mp1 , n , 3 stemp = sx ( i ) sx ( i ) = sy ( i ) sy ( i ) = stemp stemp = sx ( i + 1 ) sx ( i + 1 ) = sy ( i + 1 ) sy ( i + 1 ) = stemp stemp = sx ( i + 2 ) sx ( i + 2 ) = sy ( i + 2 ) sy ( i + 2 ) = stemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n stemp = sx ( ix ) sx ( ix ) = sy ( iy ) sy ( iy ) = stemp ix = ix + incx iy = iy + incy enddo endif end subroutine sswap !> !!##NAME !!    ssymm(3f) - [BLAS:SINGLE_BLAS_LEVEL3] C:=alpha*A*B+beta*C, A symmetric, B, C rectangular. !! !!##SYNOPSIS !! !!     subroutine ssymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: lda,ldb,ldc,m,n !!       character,intent(in) :: side,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*),b(ldb,*) !!       real,intent(inout)   :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  SSYMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is a symmetric matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the symmetric matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the symmetric matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   symmetric matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   symmetric matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is REAL array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is REAL array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. real , parameter :: one = 1.0e+0 , zero = 0.0e+0 !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'SSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then do i = 1 , m c ( i , j ) = temp1 * b ( i , j ) enddo else do i = 1 , m c ( i , j ) = beta * c ( i , j ) + temp1 * b ( i , j ) enddo endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif do i = 1 , m c ( i , j ) = c ( i , j ) + temp1 * b ( i , k ) enddo enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif do i = 1 , m c ( i , j ) = c ( i , j ) + temp1 * b ( i , k ) enddo enddo enddo endif end subroutine ssymm !> !!##NAME !!    ssymv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SY:=alpha*A*SX+beta*SY, A a symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine ssymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: incx,incy,lda,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*),x(*) !!       real,intent(inout)   :: y(*) !!       .. !! !!##DEFINITION !! !!  SSYMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssymv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), x ( * ) real , intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'SSYMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * a ( j , j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * a ( j , j ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * a ( j , j ) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * a ( j , j ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + a ( i , j ) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssymv !> !!##NAME !!    ssyr2(3f) - [BLAS:SINGLE_BLAS_LEVEL2] A:=A+alpha*SX*TRANSPOSE(SY)+alpha*SY*TRANSPOSE(SX), A a symmetric !! !!##SYNOPSIS !! !!     subroutine ssyr2(uplo,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: incx,incy,lda,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: x(*),y(*) !!       real,intent(inout)   :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  SSYR2 performs the symmetric rank 2 operation !! !!     A := alpha*x*y**T + alpha*y*x**T + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an n !!  by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssyr2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ), y ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = 1 , j a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = kx iy = ky do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * y ( j ) temp2 = alpha * x ( j ) do i = j , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * y ( jy ) temp2 = alpha * x ( jx ) ix = jx iy = jy do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo endif jx = jx + incx jy = jy + incy enddo endif endif end subroutine ssyr2 !> !!##NAME !!    ssyr2k(3f) - [BLAS:SINGLE_BLAS_LEVEL3] C:=alpha*A*TRANSPOSE(B)+alpha*B*TRANSPOSE(A)+beta*C, C symmetric. !! !!##SYNOPSIS !! !!     subroutine ssyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: k,lda,ldb,ldc,n !!       character,intent(in) :: trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*),b(ldb,*) !!       real,intent(inout)   :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  SSYR2K performs one of the symmetric rank 2k operations !! !!     C := alpha*A*B**T + alpha*B*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*B + alpha*B**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A and B are n by k matrices in the first case and k by n !!  matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + !!                                         beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + !!                                         beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + !!                                         beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'T' or 't' or 'C' or 'c', K specifies the number !!            of rows of the matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is REAL array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is REAL array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ), b ( ldb , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) do i = 1 , j c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + a ( j : n , l ) * temp1 + b ( j : n , l ) * temp2 endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif end subroutine ssyr2k !> !!##NAME !!    ssyr(3f) - [BLAS:SINGLE_BLAS_LEVEL2] A:=A+alpha*SX*TRANSPOSE(SX), A a symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine ssyr(uplo,n,alpha,x,incx,a,lda) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: incx,lda,n !!       character,intent(in) :: uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: x(*) !!       real,intent(inout)   :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  SSYR performs the symmetric rank 1 operation !! !!     A := alpha*x*x**T + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n symmetric matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssyr ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: x ( * ) real , intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions ..  LOGICAL LSAME !     .. !     .. External Subroutines ..  EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'SSYR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( 1 : j , j ) = a ( 1 : j , j ) + x ( 1 : j ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = kx do i = 1 , j a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * x ( j ) a ( j : n , j ) = a ( j : n , j ) + x ( j : n ) * temp endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * x ( jx ) ix = jx do i = j , n a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jx = jx + incx enddo endif endif end subroutine ssyr !> !!##NAME !!    ssyrk(3f) - [BLAS:SINGLE_BLAS_LEVEL3] C:=alpha*A*TRANSPOSE(A)+beta*C, C symmetric. !! !!##SYNOPSIS !! !!     subroutine ssyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha,beta !!       integer,intent(in)   :: k,lda,ldc,n !!       character,intent(in) :: trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*) !!       real,intent(inout)   :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  SSYRK performs one of the symmetric rank k operations !! !!     C := alpha*A*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A is an n by k matrix in the first case and a k by n matrix !!  in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns  of the  matrix A, and on entry with !!            TRANS = 'T' or 't' or 'C' or 'c', K specifies the number !!            of rows of the matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is REAL array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is REAL !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is REAL array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ssyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'SSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) do i = j , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine ssyrk !> !!##NAME !!    stbmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=A*SX, A a triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine stbmv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,k,lda,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*) !!       real,intent(inout)   :: x(*) !!       .. !! !!##DEFINITION !! !!  STBMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular band matrix, with ( k + 1 ) diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine stbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'STBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine stbmv !> !!##NAME !!    stbsv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=INVERSE(A)*SX, A a triangular band matrix. !! !!##SYNOPSIS !! !!     subroutine stbsv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,k,lda,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*) !!       real,intent(inout)   :: x(*) !!       .. !! !!##DEFINITION !! !!  STBSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular band matrix, with ( k + 1 ) !!  diagonals. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine stbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kplus1 , kx , l logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'STBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T)*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif end subroutine stbsv !> !!##NAME !!    stpmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=A*SX, A a packed symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine stpmv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: ap(*) !!       real,intent(inout)   :: x(*) !!       .. !! !!##DEFINITION !! !!  STPMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is REAL array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine stpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real , parameter :: zero = 0.0e+0 !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'STPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk - 1 do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * ap ( kk ) k = kk + 1 do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif end subroutine stpmv !> !!##NAME !!    stpsv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=INVERSE(A)*SX, A a packed symmetric matrix. !! !!##SYNOPSIS !! !!     subroutine stpsv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: ap(*) !!       real,intent(inout)   :: x(*) !!       .. !! !!##DEFINITION !! !!  STPSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix, supplied in packed form. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is REAL array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine stpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: ap ( * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , k , kk , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'STPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif end subroutine stpsv !> !!##NAME !!    strmm(3f) - [BLAS:SINGLE_BLAS_LEVEL3] B:=A*B or B:=B*A, A triangular, B rectangular. !! !!##SYNOPSIS !! !!     subroutine strmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: lda,ldb,m,n !!       character,intent(in) :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*) !!       real,intent(inout)   :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  STRMM performs one of the matrix-matrix operations !! !!     B := alpha*op( A )*B,   or   B := alpha*B*op( A ), !! !!  where alpha is a scalar, B is an m by n matrix, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) multiplies B from !!            the left or right as follows: !! !!               SIDE = 'L' or 'l'   B := alpha*op( A )*B. !! !!               SIDE = 'R' or 'r'   B := alpha*B*op( A ). !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**T. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is REAL array, dimension ( LDA, k ), where k is m !!            when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is REAL array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B, and on exit is overwritten by the !!            transformed matrix. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine strmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'STRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then b ( 1 : m , 1 : n ) = zero return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = alpha * a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) temp = temp * a ( k , k ) if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif end subroutine strmm !> !!##NAME !!    strmv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=A*SX, A a triangular matrix. !! !!##SYNOPSIS !! !!     subroutine strmv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,lda,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: a(lda,*) !!       real,intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  STRMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x, !! !!  where x is an n element vector and  A is an n by n unit, or non-unit, !!  upper or lower triangular matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**T*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine strmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. real , parameter :: zero = 0.0e+0 !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'STRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) x ( 1 : j - 1 ) = x ( 1 : j - 1 ) + temp * a ( 1 : j - 1 , j ) if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine strmv !> !!##NAME !!    strsm(3f) - [BLAS:SINGLE_BLAS_LEVEL3] B:=INVERSE(A)*C or B:=C*INVERSE(A), B, C rectangular, A triangular. !! !!##SYNOPSIS !! !!     subroutine strsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       real,intent(in)      :: alpha !!       integer,intent(in)   :: lda,ldb,m,n !!       character,intent(in) :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)    :: a(lda,*) !!       real,intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  STRSM solves one of the matrix equations !! !!     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !! !!  where alpha is a scalar, X and B are m by n matrices, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T. !! !!  The matrix X is overwritten on B. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) appears on the left !!            or right of X as follows: !! !!               SIDE = 'L' or 'l'   op( A )*X = alpha*B. !! !!               SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**T. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is REAL !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is REAL array, dimension ( LDA, k ), !!            where k is m when SIDE = 'L' or 'l' !!              and k is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is REAL array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the right-hand side matrix B, and on exit is !!            overwritten by the solution matrix X. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine strsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. real , intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. real temp integer i , info , j , k , nrowa logical lside , nounit , upper !     .. !     .. Parameters .. real one , zero parameter ( one = 1.0e+0 , zero = 0.0e+0 ) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'STRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n b ( 1 : m , j ) = zero enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then b ( 1 : m , j ) = alpha * b ( 1 : m , j ) endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then b ( 1 : m , j ) = b ( 1 : m , j ) - a ( k , j ) * b ( 1 : m , k ) endif enddo if ( nounit ) then temp = one / a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo else do k = 1 , n if ( nounit ) then temp = one / a ( k , k ) b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then temp = a ( j , k ) b ( 1 : m , j ) = b ( 1 : m , j ) - temp * b ( 1 : m , k ) endif enddo if ( alpha . ne . one ) then b ( 1 : m , k ) = alpha * b ( 1 : m , k ) endif enddo endif endif endif end subroutine strsm !> !!##NAME !!    strsv(3f) - [BLAS:SINGLE_BLAS_LEVEL2] SX:=INVERSE(A)*SX, A a triangular matrix. !! !!##SYNOPSIS !! !!     subroutine strsv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)   :: incx,lda,n !!       character,intent(in) :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       real,intent(in)      :: a(lda,*) !!       real,intent(inout)   :: x(*) !!       .. !! !!##DEFINITION !! !!  STRSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**T*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is REAL array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is REAL array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine strsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. real , intent ( in ) :: a ( lda , * ) real , intent ( inout ) :: x ( * ) !     .. !  ===================================================================== ! !     .. Parameters .. real zero parameter ( zero = 0.0e+0 ) !     .. !     .. Local Scalars .. real temp integer i , info , ix , j , jx , kx logical nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'STRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine strsv !> !!##NAME !!    zaxpy(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] ZY := ZY+ZA*ZX !!    complex constant times a complex vector plus a complex vector. !! !!##SYNOPSIS !! !!     subroutine zaxpy(n,za,zx,incx,zy,incy) !! !!       ! .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: za !!       integer,intent(in)                 :: incx,incy,n !!       ! .. !!       ! .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: zx(*) !!       complex(kind=real64),intent(inout) :: zy(*) !!       ! .. !! !!##DEFINITION !! !!     ZAXPY constant times a vector plus a vector. !! !!         ZY := ZY+ZA*ZX !! !!##OPTIONS !! !!   N      number of elements in input vector(s) !!   ZA     On entry, ZA specifies the scalar alpha. !!   ZX     ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !!   INCX   storage spacing between elements of ZX !!   ZY     ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !!   INCY   storage spacing between elements of ZY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zaxpy ( n , za , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: za integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) complex ( kind = real64 ), intent ( inout ) :: zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy !     .. !     .. External Functions .. !      double precision dcabs1 !      external dcabs1 !     .. if ( n . le . 0 ) return if ( dcabs1 ( za ). eq . 0.0d0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n zy ( i ) = zy ( i ) + za * zx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n zy ( iy ) = zy ( iy ) + za * zx ( ix ) ix = ix + incx iy = iy + incy enddo endif ! end subroutine zaxpy !> !!##NAME !!    zcopy(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine zcopy(n,zx,incx,zy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in)               :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)  :: ZX(*) !!       complex(kind=real64),intent(out) :: ZY(*) !!       .. !! !!##DEFINITION !! !!     ZCOPY copies a vector, x, to a vector, y. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!   ZY !! !!           ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of ZY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, linpack, 4/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zcopy ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ) complex ( kind = real64 ), intent ( out ) :: zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n zy ( i ) = zx ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n zy ( iy ) = zx ( ix ) ix = ix + incx iy = iy + incy enddo endif end subroutine zcopy !> !!##NAME !!    zdotc(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     complex(kind=real64) function zdotc(n,zx,incx,zy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in) :: zx(*),zy(*) !!       .. !! !!##DEFINITION !! !!  ZDOTC forms the dot product of two complex vectors !!       ZDOTC = X&#94;H * Y !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!   ZY !! !!           ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of ZY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure complex ( kind = real64 ) function zdotc ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ), zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ( kind = real64 ) :: ztemp integer i , ix , iy !     .. !     .. Intrinsic Functions .. intrinsic dconjg !     .. ztemp = ( 0.0d0 , 0.0d0 ) zdotc = ( 0.0d0 , 0.0d0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ztemp = ztemp + dconjg ( zx ( i )) * zy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ztemp = ztemp + dconjg ( zx ( ix )) * zy ( iy ) ix = ix + incx iy = iy + incy enddo endif zdotc = ztemp end function zdotc !> !!##NAME !!    zdotu(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     complex(kind=real64) function zdotu(n,zx,incx,zy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in) :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in) :: zx(*),zy(*) !!       .. !! !!##DEFINITION !! !!  ZDOTU forms the dot product of two complex vectors !!       ZDOTU = X&#94;T * Y !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!   ZY !! !!           ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of ZY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== pure complex ( kind = real64 ) function zdotu ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: zx ( * ), zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ( kind = real64 ) :: ztemp integer i , ix , iy !     .. ztemp = ( 0.0d0 , 0.0d0 ) zdotu = ( 0.0d0 , 0.0d0 ) if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ztemp = ztemp + zx ( i ) * zy ( i ) enddo else ! !        code for unequal increments or equal increments !          not equal to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ztemp = ztemp + zx ( ix ) * zy ( iy ) ix = ix + incx iy = iy + incy enddo endif zdotu = ztemp end function zdotu !> !!##NAME !!    zdrot(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine zdrot( n, zx, incx, zy, incy, c, s ) !! !!       .. Scalar Arguments .. !!       integer,intent(in)          :: incx, incy, n !!       double precision,intent(in) :: c, s !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(inout) :: zx( * ), zy( * ) !!       .. !! !!##DEFINITION !! !!  Applies a plane rotation, where the cos and sin (c and s) are real !!  and the vectors cx and cy are complex. !!  jack dongarra, linpack, 3/11/78. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the vectors cx and cy. !!            N must be at least zero. !! !!  ZX !! !!           ZX is complex(kind=real64) array, dimension at least !!            ( 1 + ( N - 1 )*abs( INCX ) ). !!            Before entry, the incremented array ZX must contain the n !!            element vector cx. On exit, ZX is overwritten by the updated !!            vector cx. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            ZX. INCX must not be zero. !! !!  ZY !! !!           ZY is complex(kind=real64) array, dimension at least !!            ( 1 + ( N - 1 )*abs( INCY ) ). !!            Before entry, the incremented array ZY must contain the n !!            element vector cy. On exit, ZY is overwritten by the updated !!            vector cy. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            ZY. INCY must not be zero. !! !!   C !! !!           C is DOUBLE PRECISION !!            On entry, C specifies the cosine, cos. !! !!   S !! !!           S is DOUBLE PRECISION !!            On entry, S specifies the sine, sin. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zdrot ( n , zx , incx , zy , incy , c , s ) implicit none ! !  -- Reference BLAS level1 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n double precision , intent ( in ) :: c , s !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ), zy ( * ) !     .. ! ! ===================================================================== ! !     .. Local Scalars .. integer i , ix , iy complex ( kind = real64 ) :: ctemp !     .. !     .. Executable Statements .. ! if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !        code for both increments equal to 1 ! do i = 1 , n ctemp = c * zx ( i ) + s * zy ( i ) zy ( i ) = c * zy ( i ) - s * zx ( i ) zx ( i ) = ctemp enddo else ! !        code for unequal increments or equal increments not equal !          to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ctemp = c * zx ( ix ) + s * zy ( iy ) zy ( iy ) = c * zy ( iy ) - s * zx ( ix ) zx ( ix ) = ctemp ix = ix + incx iy = iy + incy enddo endif end !> !!##NAME !!    zdscal(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine zdscal(n,da,zx,incx) !! !!       .. Scalar Arguments .. !!       double precision,intent(in) :: da !!       integer,intent(in) :: incx,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(inout) :: zx(*) !!       .. !! !!##DEFINITION !! !!     ZDSCAL scales a vector by a constant. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   DA !! !!           DA is DOUBLE PRECISION !!            On entry, DA specifies the scalar alpha. !! !!  ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zdscal ( n , da , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: da integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. !     .. Intrinsic Functions .. intrinsic dcmplx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n zx ( i ) = dcmplx ( da , 0.0d0 ) * zx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx zx ( i ) = dcmplx ( da , 0.0d0 ) * zx ( i ) enddo endif end subroutine zdscal !> !!##NAME !!    zgbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: incx,incy,kl,ku,lda,m,n !!       character,intent(in)               :: trans !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),x(*) !!       complex(kind=real64),intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  ZGBMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !! !!     y := alpha*A**H*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n band matrix, with kl sub-diagonals and ku super-diagonals. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   KL !! !!           KL is INTEGER !!            On entry, KL specifies the number of sub-diagonals of the !!            matrix A. KL must satisfy 0 .le. KL. !! !!   KU !! !!           KU is INTEGER !!            On entry, KU specifies the number of super-diagonals of the !!            matrix A. KU must satisfy 0 .le. KU. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry, the leading ( kl + ku + 1 ) by n part of the !!            array A must contain the matrix of coefficients, supplied !!            column by column, with the leading diagonal of the matrix in !!            row ( ku + 1 ) of the array, the first super-diagonal !!            starting at position 2 in row ku, the first sub-diagonal !!            starting at position 1 in row ( ku + 2 ), and so on. !!            Elements in the array A that do not correspond to elements !!            in the band matrix (such as the top left ku by ku triangle) !!            are not referenced. !!            The following program segment will transfer a band matrix !!            from conventional full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     K = KU + 1 - J !!                     DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL ) !!                        A( K + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( kl + ku + 1 ). !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zgbmv ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , kl , ku , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , iy , j , jx , jy , k , kup1 , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( kl . lt . 0 ) then info = 4 elseif ( ku . lt . 0 ) then info = 5 elseif ( lda . lt . ( kl + ku + 1 )) then info = 8 elseif ( incx . eq . 0 ) then info = 10 elseif ( incy . eq . 0 ) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'ZGBMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the band part of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : leny ) = zero else y ( 1 : leny ) = beta * y ( 1 : leny ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kup1 = ku + 1 if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( i ) = y ( i ) + temp * a ( k + i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky k = kup1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) y ( iy ) = y ( iy ) + temp * a ( k + i , j ) iy = iy + incy enddo jx = jx + incx if ( j . gt . ku ) ky = ky + incy enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( i ) enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + dconjg ( a ( k + i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx k = kup1 - j if ( noconj ) then do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + a ( k + i , j ) * x ( ix ) ix = ix + incx enddo else do i = max ( 1 , j - ku ), min ( m , j + kl ) temp = temp + dconjg ( a ( k + i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy if ( j . gt . ku ) kx = kx + incx enddo endif endif ! end subroutine zgbmv !> !!##NAME !!    zgemm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: k,lda,ldb,ldc,m,n !!       character,intent(in)               :: transa,transb !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZGEMM performs one of the matrix-matrix operations !! !!     C := alpha*op( A )*op( B ) + beta*C, !! !!  where op( X ) is one of !! !!     op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H, !! !!  alpha and beta are scalars, and A, B and C are matrices, with op( A ) !!  an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. !! !!##OPTIONS !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n',  op( A ) = A. !! !!               TRANSA = 'T' or 't',  op( A ) = A**T. !! !!               TRANSA = 'C' or 'c',  op( A ) = A**H. !! !!   TRANSB !! !!           TRANSB is CHARACTER*1 !!            On entry, TRANSB specifies the form of op( B ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSB = 'N' or 'n',  op( B ) = B. !! !!               TRANSB = 'T' or 't',  op( B ) = B**T. !! !!               TRANSB = 'C' or 'c',  op( B ) = B**H. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix !!            op( A ) and of the matrix C. M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix !!            op( B ) and the number of columns of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of columns of the matrix !!            op( A ) and the number of rows of the matrix op( B ). K must !!            be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            k when TRANSA = 'N' or 'n', and is m otherwise. !!            Before entry with TRANSA = 'N' or 'n', the leading m by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by m part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANSA = 'N' or 'n' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, k ). !! !!   B !! !!           B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is !!            n when TRANSB = 'N' or 'n', and is k otherwise. !!            Before entry with TRANSB = 'N' or 'n', the leading k by n !!            part of the array B must contain the matrix B, otherwise !!            the leading n by k part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANSB = 'N' or 'n' then !!            LDB must be at least max( 1, k ), otherwise LDB must be at !!            least max( 1, n ). !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n matrix !!            ( alpha*op( A )*op( B ) + beta*C ). !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , m , n character , intent ( in ) :: transa , transb !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , l , nrowa , nrowb logical conja , conjb , nota , notb !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not !     conjugated or transposed, set  CONJA and CONJB  as true if  A  and !     B  respectively are to be  transposed but  not conjugated  and set !     NROWA and NROWB  as the number of rows  of  A  and  B  respectively. ! nota = lsame ( transa , 'N' ) notb = lsame ( transb , 'N' ) conja = lsame ( transa , 'C' ) conjb = lsame ( transb , 'C' ) if ( nota ) then nrowa = m else nrowa = k endif if ( notb ) then nrowb = k else nrowb = n endif ! !     Test the input parameters. ! info = 0 if ((. not . nota ) . and . (. not . conja ) . and . (. not . lsame ( transa , 'T' ))) then info = 1 elseif ((. not . notb ) . and . (. not . conjb ) . and . (. not . lsame ( transb , 'T' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , nrowa )) then info = 8 elseif ( ldb . lt . max ( 1 , nrowb )) then info = 10 elseif ( ldc . lt . max ( 1 , m )) then info = 13 endif if ( info . ne . 0 ) then call xerbla ( 'ZGEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : m , j ) = zero enddo else do j = 1 , n c ( 1 : m , j ) = beta * c ( 1 : m , j ) enddo endif return endif ! !     Start the operations. ! if ( notb ) then if ( nota ) then ! !           Form  C := alpha*A*B + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( l , j ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo elseif ( conja ) then ! !           Form  C := alpha*A**H*B + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif elseif ( nota ) then if ( conjb ) then ! !           Form  C := alpha*A*B**H + beta*C. ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * dconjg ( b ( j , l )) do i = 1 , m c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo enddo enddo else ! !           Form  C := alpha*A*B**T + beta*C ! do j = 1 , n if ( beta . eq . zero ) then c ( 1 : m , j ) = zero elseif ( beta . ne . one ) then c ( 1 : m , j ) = beta * c ( 1 : m , j ) endif do l = 1 , k temp = alpha * b ( j , l ) c ( 1 : m , j ) = c ( 1 : m , j ) + temp * a ( 1 : m , l ) enddo enddo endif elseif ( conja ) then if ( conjb ) then ! !           Form  C := alpha*A**H*B**H + beta*C. ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * dconjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**H*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif else if ( conjb ) then ! !           Form  C := alpha*A**T*B**H + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * dconjg ( b ( j , l )) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else ! !           Form  C := alpha*A**T*B**T + beta*C ! do j = 1 , n do i = 1 , m temp = zero do l = 1 , k temp = temp + a ( l , i ) * b ( j , l ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif ! end subroutine zgemm !> !!##NAME !!    zgemv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: incx,incy,lda,m,n !!       character,intent(in)               :: trans !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),x(*) !!       complex(kind=real64),intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  ZGEMV performs one of the matrix-vector operations !! !!     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or !! !!     y := alpha*A**H*x + beta*y, !! !!  where alpha and beta are scalars, x and y are vectors and A is an !!  m by n matrix. !! !!##OPTIONS !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. !! !!               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y. !! !!               TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' !!            and at least !!            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. !!            Before entry with BETA non-zero, the incremented array Y !!            must contain the vector y. On exit, Y is overwritten by the !!            updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , m , n character , intent ( in ) :: trans !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , iy , j , jx , jy , kx , ky , lenx , leny logical noconj !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 1 elseif ( m . lt . 0 ) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( lda . lt . max ( 1 , m )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZGEMV ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! noconj = lsame ( trans , 'T' ) ! !     Set  LENX  and  LENY, the lengths of the vectors x and y, and set !     up the start points in  X  and  Y. ! if ( lsame ( trans , 'N' )) then lenx = n leny = m else lenx = m leny = n endif if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( lenx - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( leny - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then do i = 1 , leny y ( i ) = zero enddo else do i = 1 , leny y ( i ) = beta * y ( i ) enddo endif else iy = ky if ( beta . eq . zero ) then do i = 1 , leny y ( iy ) = zero iy = iy + incy enddo else do i = 1 , leny y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( trans , 'N' )) then ! !        Form  y := alpha*A*x + y. ! jx = kx if ( incy . eq . 1 ) then do j = 1 , n temp = alpha * x ( jx ) do i = 1 , m y ( i ) = y ( i ) + temp * a ( i , j ) enddo jx = jx + incx enddo else do j = 1 , n temp = alpha * x ( jx ) iy = ky do i = 1 , m y ( iy ) = y ( iy ) + temp * a ( i , j ) iy = iy + incy enddo jx = jx + incx enddo endif else ! !        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y. ! jy = ky if ( incx . eq . 1 ) then do j = 1 , n temp = zero if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( i ) enddo else do i = 1 , m temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo else do j = 1 , n temp = zero ix = kx if ( noconj ) then do i = 1 , m temp = temp + a ( i , j ) * x ( ix ) ix = ix + incx enddo else do i = 1 , m temp = temp + dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo endif y ( jy ) = y ( jy ) + alpha * temp jy = jy + incy enddo endif endif ! end subroutine zgemv !> !!##NAME !!    zgerc(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zgerc(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*),y(*) !!       complex(kind=real64),intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  ZGERC performs the rank 1 operation !! !!     A := alpha*x*y**H + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix A. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( m - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the m !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry, the leading m by n part of the array A must !!            contain the matrix of coefficients. On exit, A is !!            overwritten by the updated matrix. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zgerc ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZGERC ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * dconjg ( y ( jy )) a ( 1 : m , j ) = a ( 1 : m , j ) + x ( 1 : m ) * temp endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * dconjg ( y ( jy )) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine zgerc !> !!##NAME !!    zgeru(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zgeru(m,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: incx,incy,lda,m,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*),y(*) !!       complex(kind=real64),intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  ZGERU performs the rank 1 operation !! !!     A := alpha*x*y**T + A, !! !!  where alpha is a scalar, x is an m element vector, y is an n element !!  vector and A is an m by n matrix. !! !!##OPTIONS !! !!     M   On entry, M specifies the number of rows of the matrix A. !!         M must be at least zero. !! !!     N   On entry, N specifies the number of columns of the matrix A. !!         N must be at least zero. !! !!     ALPHA  On entry, ALPHA specifies the scalar alpha. !! !!     X   array, dimension at least !! !!         ( 1 + ( m - 1 )*abs( INCX ) ). !! !!         Before entry, the incremented array X must contain the m !!         element vector x. !! !!     INCX  On entry, INCX specifies the increment for the elements of !!           X. INCX must not be zero. !! !!     Y  array, dimension at least !! !!         ( 1 + ( n - 1 )*abs( INCY ) ). !! !!        Before entry, the incremented array Y must contain the n !!        element vector y. !! !!     INCY  On entry, INCY specifies the increment for the elements of !!           Y. INCY must not be zero. !! !!     A    array, dimension ( LDA, N ) !!          Before entry, the leading m by n part of the array A must !!          contain the matrix of coefficients. On exit, A is !!          overwritten by the updated matrix. !! !!     LDA  On entry, LDA specifies the first dimension of A as declared !!          in the calling (sub) program. LDA must be at least !!          max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zgeru ( m , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , m , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jy , kx !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. ! !     Test the input parameters. ! info = 0 if ( m . lt . 0 ) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , m )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZGERU ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( incy . gt . 0 ) then jy = 1 else jy = 1 - ( n - 1 ) * incy endif if ( incx . eq . 1 ) then do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) do i = 1 , m a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo endif jy = jy + incy enddo else if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( m - 1 ) * incx endif do j = 1 , n if ( y ( jy ). ne . zero ) then temp = alpha * y ( jy ) ix = kx do i = 1 , m a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo endif jy = jy + incy enddo endif end subroutine zgeru !> !!##NAME !!    zhbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zhbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: incx,incy,k,lda,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),x(*) !!       complex(kind=real64),intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  ZHBMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian band matrix, with k super-diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the band matrix A is being supplied as !!            follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   being supplied. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   being supplied. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry, K specifies the number of super-diagonals of the !!            matrix A. K must satisfy 0 .le. K. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the hermitian matrix, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer the upper !!            triangular part of a hermitian band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the hermitian matrix, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer the lower !!            triangular part of a hermitian band matrix from conventional !!            full matrix storage to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the !!            vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. !! !!  Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the !!            vector y. On exit, Y is overwritten by the updated vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhbmv ( uplo , n , k , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , k , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kplus1 , kx , ky , l !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( k . lt . 0 ) then info = 3 elseif ( lda . lt . ( k + 1 )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 elseif ( incy . eq . 0 ) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZHBMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array A !     are accessed sequentially with one pass through A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when upper triangle of A is stored. ! kplus1 = k + 1 if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * dble ( a ( kplus1 , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky l = kplus1 - j do i = max ( 1 , j - k ), j - 1 y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( a ( kplus1 , j )) + alpha * temp2 jx = jx + incx jy = jy + incy if ( j . gt . k ) then kx = kx + incx ky = ky + incy endif enddo endif else ! !        Form  y  when lower triangle of A is stored. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( a ( 1 , j )) l = 1 - j do i = j + 1 , min ( n , j + k ) y ( i ) = y ( i ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( a ( 1 , j )) l = 1 - j ix = jx iy = jy do i = j + 1 , min ( n , j + k ) ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( l + i , j ) temp2 = temp2 + dconjg ( a ( l + i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine zhbmv !> !!##NAME !!    zhemm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zhemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: lda,ldb,ldc,m,n !!       character,intent(in)               :: side,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZHEMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is an hermitian matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the hermitian matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the hermitian matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   hermitian matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   hermitian matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the hermitian matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the hermitian matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the hermitian !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the hermitian matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the hermitian matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the hermitian !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is complex(kind=real64) array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhemm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZHEMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * dconjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * dble ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * dble ( a ( i , i )) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * dconjg ( a ( k , i )) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * dble ( a ( i , i )) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * dble ( a ( i , i )) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * dble ( a ( j , j )) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * dconjg ( a ( j , k )) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * dconjg ( a ( j , k )) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif end subroutine zhemm !> !!##NAME !!    zhemv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zhemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: incx,incy,lda,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),x(*) !!       complex(kind=real64),intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  ZHEMV performs the matrix-vector  operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhemv ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !      logical lsame !      external lsame !     .. !     .. External Subroutines .. !      external xerbla !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( lda . lt . max ( 1 , n )) then info = 5 elseif ( incx . eq . 0 ) then info = 7 elseif ( incy . eq . 0 ) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZHEMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return if ( lsame ( uplo , 'U' )) then ! !        Form  y  when A is stored in upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + temp1 * dble ( a ( j , j )) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do i = 1 , j - 1 y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( a ( j , j )) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif else ! !        Form  y  when A is stored in lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( a ( j , j )) do i = j + 1 , n y ( i ) = y ( i ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( i ) enddo y ( j ) = y ( j ) + alpha * temp2 enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( a ( j , j )) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * a ( i , j ) temp2 = temp2 + dconjg ( a ( i , j )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy enddo endif endif end subroutine zhemv !> !!##NAME !!    zher2(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zher2(uplo,n,alpha,x,incx,y,incy,a,lda) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: incx,incy,lda,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*),y(*) !!       complex(kind=real64),intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  ZHER2 performs the hermitian rank 2 operation !! !!     A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an n !!  by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zher2 ( uplo , n , alpha , x , incx , y , incy , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 elseif ( lda . lt . max ( 1 , n )) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) a ( 1 : j - 1 , j ) = a ( 1 : j - 1 , j ) + x ( 1 : j - 1 ) * temp1 + y ( 1 : j - 1 ) * temp2 a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) else a ( j , j ) = dble ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ix = kx iy = ky do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif else ! !        Form  A  when A is stored in the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp1 + y ( i ) * temp2 enddo else a ( j , j ) = dble ( a ( j , j )) endif enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do i = j + 1 , n ix = ix + incx iy = iy + incy a ( i , j ) = a ( i , j ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx jy = jy + incy enddo endif endif end subroutine zher2 !> !!##NAME !!    zher2k(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       double precision,intent(in)        :: beta !!       integer ,intent(in)                ::k,lda,ldb,ldc,n !!       character,intent(in)               :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZHER2K performs one of the hermitian rank 2k operations !! !!     C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C, !! !!  or !! !!     C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C, !! !!  where alpha and beta are scalars with beta real, C is an n by n !!  hermitian matrix and A and B are n by k matrices in the first case !!  and k by n matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'    C := alpha*A*B**H          + !!                                          conjg( alpha )*B*A**H + !!                                          beta*C. !! !!               TRANS = 'C' or 'c'    C := alpha*A**H*B          + !!                                          conjg( alpha )*B**H*A + !!                                          beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'C' or 'c', K specifies the number of rows of the !!            matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) . !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !!            Unchanged on exit. !! !!   BETA !! !!           BETA is DOUBLE PRECISION . !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!   -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !!      Ed Anderson, Cray Research Inc. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zher2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha double precision , intent ( in ) :: beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one parameter ( one = 1.0d+0 ) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . dble ( zero )) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j - 1 , j ) = beta * c ( 1 : j - 1 , j ) c ( j , j ) = beta * dble ( c ( j , j )) enddo endif else if ( beta . eq . dble ( zero )) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * dble ( c ( j , j )) c ( j + 1 : n , j ) = beta * c ( j + 1 : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + !                   C. ! if ( upper ) then do j = 1 , n if ( beta . eq . dble ( zero )) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j - 1 , j ) = beta * c ( 1 : j - 1 , j ) c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * dconjg ( b ( j , l )) temp2 = dconjg ( alpha * a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = dble ( c ( j , j )) + dble ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo else do j = 1 , n if ( beta . eq . dble ( zero )) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j + 1 : n , j ) = beta * c ( j + 1 : n , j ) c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * dconjg ( b ( j , l )) temp2 = dconjg ( alpha * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + a ( i , l ) * temp1 + b ( i , l ) * temp2 enddo c ( j , j ) = dble ( c ( j , j )) + dble ( a ( j , l ) * temp1 + b ( j , l ) * temp2 ) endif enddo enddo endif else ! !        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + !                   C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + dconjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + dconjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . dble ( zero )) then c ( j , j ) = dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) else c ( j , j ) = beta * dble ( c ( j , j )) + dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) endif else if ( beta . eq . dble ( zero )) then c ( i , j ) = alpha * temp1 + dconjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + dconjg ( alpha ) * temp2 endif endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + dconjg ( a ( l , i )) * b ( l , j ) temp2 = temp2 + dconjg ( b ( l , i )) * a ( l , j ) enddo if ( i . eq . j ) then if ( beta . eq . dble ( zero )) then c ( j , j ) = dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) else c ( j , j ) = beta * dble ( c ( j , j )) + dble ( alpha * temp1 + dconjg ( alpha ) * temp2 ) endif else if ( beta . eq . dble ( zero )) then c ( i , j ) = alpha * temp1 + dconjg ( alpha ) * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + dconjg ( alpha ) * temp2 endif endif enddo enddo endif endif end subroutine zher2k !> !!##NAME !!    zher(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zher(uplo,n,alpha,x,incx,a,lda) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)        :: alpha !!       integer ,intent(in)                :: incx,lda,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*) !!       complex(kind=real64),intent(inout) :: a(lda,*) !!       .. !! !!##DEFINITION !! !!  ZHER performs the hermitian rank 1 operation !! !!     A := alpha*x*x**H + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n hermitian matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array A is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of A !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of A !!                                   is to be referenced. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of A is not referenced. On exit, the !!            upper triangular part of the array A is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of A is not referenced. On exit, the !!            lower triangular part of the array A is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zher ( uplo , n , alpha , x , incx , a , lda ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ) complex ( kind = real64 ), intent ( inout ) :: a ( lda , * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( lda . lt . max ( 1 , n )) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZHER  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . dble ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through the triangular part !     of A. ! if ( lsame ( uplo , 'U' )) then ! !        Form  A  when A is stored in upper triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( j ) * temp ) else a ( j , j ) = dble ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ix = kx do i = 1 , j - 1 a ( i , j ) = a ( i , j ) + x ( ix ) * temp ix = ix + incx enddo a ( j , j ) = dble ( a ( j , j )) + dble ( x ( jx ) * temp ) else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx enddo endif else ! !        Form  A  when A is stored in lower triangle. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) a ( j , j ) = dble ( a ( j , j )) + dble ( temp * x ( j )) do i = j + 1 , n a ( i , j ) = a ( i , j ) + x ( i ) * temp enddo else a ( j , j ) = dble ( a ( j , j )) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) a ( j , j ) = dble ( a ( j , j )) + dble ( temp * x ( jx )) ix = jx do i = j + 1 , n ix = ix + incx a ( i , j ) = a ( i , j ) + x ( ix ) * temp enddo else a ( j , j ) = dble ( a ( j , j )) endif jx = jx + incx enddo endif endif end subroutine zher !> !!##NAME !!    zherk(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       double precision,intent(in)        :: alpha,beta !!       integer,intent(in)                 :: k,lda,ldc,n !!       character,intent(in)               :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZHERK performs one of the hermitian rank k operations !! !!     C := alpha*A*A**H + beta*C, !! !!  or !! !!     C := alpha*A**H*A + beta*C, !! !!  where alpha and beta are real scalars, C is an n by n hermitian !!  matrix and A is an n by k matrix in the first case and a k by n !!  matrix in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C. !! !!               TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrix A, and on entry with !!            TRANS = 'C' or 'c', K specifies the number of rows of the !!            matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION . !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is DOUBLE PRECISION. !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the hermitian matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the hermitian matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!   -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1. !!      Ed Anderson, Cray Research Inc. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zherk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dcmplx , dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp double precision rtemp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. double precision one , zero parameter ( one = 1.0d+0 , zero = 0.0d+0 ) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'C' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZHERK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * dble ( c ( j , j )) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j , j ) = beta * dble ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**H + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then do i = 1 , j - 1 c ( i , j ) = beta * c ( i , j ) enddo c ( j , j ) = beta * dble ( c ( j , j )) else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . dcmplx ( zero )) then temp = alpha * dconjg ( a ( j , l )) do i = 1 , j - 1 c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo c ( j , j ) = dble ( c ( j , j )) + dble ( temp * a ( i , l )) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j , j ) = beta * dble ( c ( j , j )) do i = j + 1 , n c ( i , j ) = beta * c ( i , j ) enddo else c ( j , j ) = dble ( c ( j , j )) endif do l = 1 , k if ( a ( j , l ). ne . dcmplx ( zero )) then temp = alpha * dconjg ( a ( j , l )) c ( j , j ) = dble ( c ( j , j )) + dble ( temp * a ( j , l )) do i = j + 1 , n c ( i , j ) = c ( i , j ) + temp * a ( i , l ) enddo endif enddo enddo endif else ! !        Form  C := alpha*A**H*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j - 1 temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo rtemp = zero do l = 1 , k rtemp = rtemp + dconjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * dble ( c ( j , j )) endif enddo else do j = 1 , n rtemp = zero do l = 1 , k rtemp = rtemp + dconjg ( a ( l , j )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( j , j ) = alpha * rtemp else c ( j , j ) = alpha * rtemp + beta * dble ( c ( j , j )) endif do i = j + 1 , n temp = zero do l = 1 , k temp = temp + dconjg ( a ( l , i )) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine zherk !> !!##NAME !!    zhpmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zhpmv(uplo,n,alpha,ap,x,incx,beta,y,incy) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: incx,incy,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: ap(*),x(*) !!       complex(kind=real64),intent(inout) :: y(*) !!       .. !! !!##DEFINITION !! !!  ZHPMV performs the matrix-vector operation !! !!     y := alpha*A*x + beta*y, !! !!  where alpha and beta are scalars, x and y are n element vectors and !!  A is an n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   AP !! !!           AP is complex(kind=real64) array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. !!            Note that the imaginary parts of the diagonal elements need !!            not be set and are assumed to be zero. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then Y need not be set on input. !! !!  Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. On exit, Y is overwritten by the updated !!            vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhpmv ( uplo , n , alpha , ap , x , incx , beta , y , incy ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ), x ( * ) complex ( kind = real64 ), intent ( inout ) :: y ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 6 elseif ( incy . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPMV ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     Set up the start points in  X  and  Y. ! if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! !     First form  y := beta*y. ! if ( beta . ne . one ) then if ( incy . eq . 1 ) then if ( beta . eq . zero ) then y ( 1 : n ) = zero else y ( 1 : n ) = beta * y ( 1 : n ) endif else iy = ky if ( beta . eq . zero ) then do i = 1 , n y ( iy ) = zero iy = iy + incy enddo else do i = 1 , n y ( iy ) = beta * y ( iy ) iy = iy + incy enddo endif endif endif if ( alpha . eq . zero ) return kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  y  when AP contains the upper triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero k = kk do i = 1 , j - 1 y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + temp1 * dble ( ap ( kk + j - 1 )) + alpha * temp2 kk = kk + j enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero ix = kx iy = ky do k = kk , kk + j - 2 y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( ix ) ix = ix + incx iy = iy + incy enddo y ( jy ) = y ( jy ) + temp1 * dble ( ap ( kk + j - 1 )) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  y  when AP contains the lower triangle. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n temp1 = alpha * x ( j ) temp2 = zero y ( j ) = y ( j ) + temp1 * dble ( ap ( kk )) k = kk + 1 do i = j + 1 , n y ( i ) = y ( i ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo y ( j ) = y ( j ) + alpha * temp2 kk = kk + ( n - j + 1 ) enddo else jx = kx jy = ky do j = 1 , n temp1 = alpha * x ( jx ) temp2 = zero y ( jy ) = y ( jy ) + temp1 * dble ( ap ( kk )) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy y ( iy ) = y ( iy ) + temp1 * ap ( k ) temp2 = temp2 + dconjg ( ap ( k )) * x ( ix ) enddo y ( jy ) = y ( jy ) + alpha * temp2 jx = jx + incx jy = jy + incy kk = kk + ( n - j + 1 ) enddo endif endif end subroutine zhpmv !> !!##NAME !!    zhpr2(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zhpr2(uplo,n,alpha,x,incx,y,incy,ap) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: incx,incy,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*),y(*) !!       complex(kind=real64),intent(inout) :: ap(*) !!       .. !! !!##DEFINITION !! !!  ZHPR2 performs the hermitian rank 2 operation !! !!     A := alpha*x*y**H + conjg( alpha )*y*x**H + A, !! !!  where alpha is a scalar, x and y are n element vectors and A is an !!  n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!   Y !! !!           Y is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCY ) ). !!            Before entry, the incremented array Y must contain the n !!            element vector y. !! !!   INCY !! !!           INCY is INTEGER !!            On entry, INCY specifies the increment for the elements of !!            Y. INCY must not be zero. !! !!  AP !! !!           AP is complex(kind=real64) array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhpr2 ( uplo , n , alpha , x , incx , y , incy , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: incx , incy , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ), y ( * ) complex ( kind = real64 ), intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , ix , iy , j , jx , jy , k , kk , kx , ky !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 elseif ( incy . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPR2 ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . zero )) return ! !     Set up the start points in X and Y if the increments are not both !     unity. ! if (( incx . ne . 1 ) . or . ( incy . ne . 1 )) then if ( incx . gt . 0 ) then kx = 1 else kx = 1 - ( n - 1 ) * incx endif if ( incy . gt . 0 ) then ky = 1 else ky = 1 - ( n - 1 ) * incy endif jx = kx jy = ky endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif kk = kk + j enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ix = kx iy = ky do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 ix = ix + incx iy = iy + incy enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif jx = jx + incx jy = jy + incy kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if (( incx . eq . 1 ) . and . ( incy . eq . 1 )) then do j = 1 , n if (( x ( j ). ne . zero ) . or . ( y ( j ). ne . zero )) then temp1 = alpha * dconjg ( y ( j )) temp2 = dconjg ( alpha * x ( j )) ap ( kk ) = dble ( ap ( kk )) + dble ( x ( j ) * temp1 + y ( j ) * temp2 ) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp1 + y ( i ) * temp2 k = k + 1 enddo else ap ( kk ) = dble ( ap ( kk )) endif kk = kk + n - j + 1 enddo else do j = 1 , n if (( x ( jx ). ne . zero ) . or . ( y ( jy ). ne . zero )) then temp1 = alpha * dconjg ( y ( jy )) temp2 = dconjg ( alpha * x ( jx )) ap ( kk ) = dble ( ap ( kk )) + dble ( x ( jx ) * temp1 + y ( jy ) * temp2 ) ix = jx iy = jy do k = kk + 1 , kk + n - j ix = ix + incx iy = iy + incy ap ( k ) = ap ( k ) + x ( ix ) * temp1 + y ( iy ) * temp2 enddo else ap ( kk ) = dble ( ap ( kk )) endif jx = jx + incx jy = jy + incy kk = kk + n - j + 1 enddo endif endif end subroutine zhpr2 !> !!##NAME !!    zhpr(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine zhpr(uplo,n,alpha,x,incx,ap) !! !!       .. Scalar Arguments .. !!       double precision ,intent(in)       :: alpha !!       integer ,intent(in)                :: incx,n !!       character,intent(in)               :: uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: x(*) !!       complex(kind=real64),intent(inout) :: ap(*) !!       .. !! !!##DEFINITION !! !!  ZHPR performs the hermitian rank 1 operation !! !!     A := alpha*x*x**H + A, !! !!  where alpha is a real scalar, x is an n element vector and A is an !!  n by n hermitian matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the matrix A is supplied in the packed !!            array AP as follows: !! !!               UPLO = 'U' or 'u'   The upper triangular part of A is !!                                   supplied in AP. !! !!               UPLO = 'L' or 'l'   The lower triangular part of A is !!                                   supplied in AP. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is DOUBLE PRECISION. !!            On entry, ALPHA specifies the scalar alpha. !! !!   X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!  AP !! !!           AP is complex(kind=real64) array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) !!            and a( 2, 2 ) respectively, and so on. On exit, the array !!            AP is overwritten by the upper triangular part of the !!            updated matrix. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular part of the hermitian matrix !!            packed sequentially, column by column, so that AP( 1 ) !!            contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) !!            and a( 3, 1 ) respectively, and so on. On exit, the array !!            AP is overwritten by the lower triangular part of the !!            updated matrix. !!            Note that the imaginary parts of the diagonal elements need !!            not be set, they are assumed to be zero, and on exit they !!            are set to zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zhpr ( uplo , n , alpha , x , incx , ap ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. double precision , intent ( in ) :: alpha integer , intent ( in ) :: incx , n character , intent ( in ) :: uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: x ( * ) complex ( kind = real64 ), intent ( inout ) :: ap ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dble , dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif ( n . lt . 0 ) then info = 2 elseif ( incx . eq . 0 ) then info = 5 endif if ( info . ne . 0 ) then call xerbla ( 'ZHPR  ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ( alpha . eq . dble ( zero ))) return ! !     Set the start point in X if the increment is not unity. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of the array AP !     are accessed sequentially with one pass through AP. ! kk = 1 if ( lsame ( uplo , 'U' )) then ! !        Form  A  when upper triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) k = kk do i = 1 , j - 1 ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( j ) * temp ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ix = kx do k = kk , kk + j - 2 ap ( k ) = ap ( k ) + x ( ix ) * temp ix = ix + incx enddo ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) + dble ( x ( jx ) * temp ) else ap ( kk + j - 1 ) = dble ( ap ( kk + j - 1 )) endif jx = jx + incx kk = kk + j enddo endif else ! !        Form  A  when lower triangle is stored in AP. ! if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = alpha * dconjg ( x ( j )) ap ( kk ) = dble ( ap ( kk )) + dble ( temp * x ( j )) k = kk + 1 do i = j + 1 , n ap ( k ) = ap ( k ) + x ( i ) * temp k = k + 1 enddo else ap ( kk ) = dble ( ap ( kk )) endif kk = kk + n - j + 1 enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = alpha * dconjg ( x ( jx )) ap ( kk ) = dble ( ap ( kk )) + dble ( temp * x ( jx )) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx ap ( k ) = ap ( k ) + x ( ix ) * temp enddo else ap ( kk ) = dble ( ap ( kk )) endif jx = jx + incx kk = kk + n - j + 1 enddo endif endif end subroutine zhpr !> !!##NAME !!    zrotg(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] constructs a plane rotation !! !!##SYNOPSIS !! !!     subroutine zrotg( a, b, c, s ) !! !!       .. Scalar Arguments .. !!       real(wp),intent(out)      :: c !!       complex(wp),intent(in)    :: b !!       complex(wp),intent(out)   :: s !!       complex(wp),intent(inout) :: a !!       .. !! !!##DEFINITION !!   ZROTG constructs a plane rotation !! !!      [  c         s ] [ a ] = [ r ] !!      [ -conjg(s)  c ] [ b ]   [ 0 ] !! !!   where c is real, s ic complex, and c**2 + conjg(s)*s = 1. !! !!  The computation uses the formulas !! !!     |x| = sqrt( Re(x)**2 + Im(x)**2 ) !!     sgn(x) = x / |x|  if x /= 0 !!            = 1        if x  = 0 !!     c = |a| / sqrt(|a|**2 + |b|**2) !!     s = sgn(a) * conjg(b) / sqrt(|a|**2 + |b|**2) !! !!  When a and b are real and r /= 0, the formulas simplify to !! !!     r = sgn(a)*sqrt(|a|**2 + |b|**2) !!     c = a / r !!     s = b / r !! !!  the same as in ZROTG when |a| > |b|. When |b| >= |a|, the !!  sign of c and s will be different from those computed by ZROTG !!  if the signs of a and b are not the same. !! !!##OPTIONS !! !!  A !! !!           A is DOUBLE COMPLEX !!           On entry, the scalar a. !!           On exit, the scalar r. !! !!   B !! !!           B is DOUBLE COMPLEX !!           The scalar b. !! !!   C !! !!           C is DOUBLE PRECISION !!           The scalar c. !! !!   S !! !!           S is DOUBLE PRECISION !!           The scalar s. !! !!##AUTHORS !! !! + Edward Anderson, Lockheed Martin !! !!  \\par Contributors: !! !!  Weslley Pereira, University of Colorado Denver, USA !! !!  FURTHER DETAILS !! !!   Anderson E. (2017) !!   Algorithm 978: Safe Scaling in the Level 1 BLAS !!   ACM Trans Math Softw 44:1--28 !!   https://doi.org/10.1145/3061665 !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zrotg ( a , b , c , s ) integer , parameter :: wp = kind ( 1.d0 ) ! !  -- Reference BLAS level1 routine -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- ! !  .. Constants .. real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp complex ( wp ), parameter :: czero = 0.0_wp !  .. !  .. Scaling constants .. real ( wp ), parameter :: safmin = real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) real ( wp ), parameter :: safmax = real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) real ( wp ), parameter :: rtmin = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( minexponent ( 0._wp ) - 1 , 1 - maxexponent ( 0._wp ) ) / epsilon ( 0._wp ) ) real ( wp ), parameter :: rtmax = sqrt ( real ( radix ( 0._wp ), wp ) ** max ( 1 - minexponent ( 0._wp ), maxexponent ( 0._wp ) - 1 ) * epsilon ( 0._wp ) ) !  .. !  .. Scalar Arguments .. real ( wp ), intent ( out ) :: c complex ( wp ), intent ( in ) :: b complex ( wp ), intent ( out ) :: s complex ( wp ), intent ( inout ) :: a !  .. !  .. Local Scalars .. real ( wp ) :: d , f1 , f2 , g1 , g2 , h2 , p , u , uu , v , vv , w complex ( wp ) :: f , fs , g , gs , r , t !  .. !  .. Intrinsic Functions .. intrinsic :: abs , aimag , conjg , max , min , real , sqrt !  .. !  .. Statement Functions .. real ( wp ) :: abssq !  .. !  .. Statement Function definitions .. abssq ( t ) = real ( t ) ** 2 + aimag ( t ) ** 2 !  .. !  .. Executable Statements .. ! f = a g = b if ( g == czero ) then c = one s = czero r = f elseif ( f == czero ) then c = zero g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! g2 = abssq ( g ) d = sqrt ( g2 ) s = conjg ( g ) / d r = d else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) d = sqrt ( g2 ) s = conjg ( gs ) / d r = d * u endif else f1 = max ( abs ( real ( f )), abs ( aimag ( f )) ) g1 = max ( abs ( real ( g )), abs ( aimag ( g )) ) if ( f1 > rtmin . and . f1 < rtmax . and . & g1 > rtmin . and . g1 < rtmax ) then ! !        Use unscaled algorithm ! f2 = abssq ( f ) g2 = abssq ( g ) h2 = f2 + g2 if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = f2 * p s = conjg ( g ) * ( f * p ) r = f * ( h2 * p ) else ! !        Use scaled algorithm ! u = min ( safmax , max ( safmin , f1 , g1 ) ) uu = one / u gs = g * uu g2 = abssq ( gs ) if ( f1 * uu < rtmin ) then ! !           f is not well-scaled when scaled by g1. !           Use a different scaling for f. ! v = min ( safmax , max ( safmin , f1 ) ) vv = one / v w = v * uu fs = f * vv f2 = abssq ( fs ) h2 = f2 * w ** 2 + g2 else ! !           Otherwise use the same scaling for f and g. ! w = one fs = f * uu f2 = abssq ( fs ) h2 = f2 + g2 endif if ( f2 > rtmin . and . h2 < rtmax ) then d = sqrt ( f2 * h2 ) else d = sqrt ( f2 ) * sqrt ( h2 ) endif p = 1 / d c = ( f2 * p ) * w s = conjg ( gs ) * ( fs * p ) r = ( fs * ( h2 * p ) ) * u endif endif a = r return end subroutine !> !!##NAME !!    zscal(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine zscal(n,za,zx,incx) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: za !!       integer,intent(in)                 :: incx,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(inout) :: zx(*) !!       .. !! !!##DEFINITION !! !!     ZSCAL scales a vector by a constant. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!   ZA !! !!           ZA is complex(kind=real64) !!            On entry, ZA specifies the scalar alpha. !! !!  ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 3/93 to return if incx .le. 0. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zscal ( n , za , zx , incx ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: za integer , intent ( in ) :: incx , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. integer i , nincx !     .. if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) then ! !        code for increment equal to 1 ! do i = 1 , n zx ( i ) = za * zx ( i ) enddo else ! !        code for increment not equal to 1 ! nincx = n * incx do i = 1 , nincx , incx zx ( i ) = za * zx ( i ) enddo endif end subroutine zscal !> !!##NAME !!    zswap(3f) - [BLAS:COMPLEX16_BLAS_LEVEL1] !! !!##SYNOPSIS !! !!     subroutine zswap(n,zx,incx,zy,incy) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,incy,n !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(inout) :: zx(*),zy(*) !!       .. !! !!##DEFINITION !! !!     ZSWAP interchanges two vectors. !! !!##OPTIONS !! !!   N !! !!           N is INTEGER !!          number of elements in input vector(s) !! !!  ZX !! !!           ZX is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCX ) ) !! !!   INCX !! !!           INCX is INTEGER !!          storage spacing between elements of ZX !! !!  ZY !! !!           ZY is complex(kind=real64) array, dimension ( 1 + ( N - 1 )*abs( INCY ) ) !! !!   INCY !! !!           INCY is INTEGER !!          storage spacing between elements of ZY !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:November 2017 !! !!  FURTHER DETAILS !! !!      jack dongarra, 3/11/78. !!      modified 12/3/93, array(1) declarations changed to array(*) !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zswap ( n , zx , incx , zy , incy ) implicit none ! !  -- Reference BLAS level1 routine (version 3.8.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     November 2017 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , incy , n !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( inout ) :: zx ( * ), zy ( * ) !     .. ! !  ===================================================================== ! !     .. Local Scalars .. complex ( kind = real64 ) :: ztemp integer i , ix , iy !     .. if ( n . le . 0 ) return if ( incx . eq . 1 . and . incy . eq . 1 ) then ! !       code for both increments equal to 1 do i = 1 , n ztemp = zx ( i ) zx ( i ) = zy ( i ) zy ( i ) = ztemp enddo else ! !       code for unequal increments or equal increments not equal !         to 1 ! ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n ztemp = zx ( ix ) zx ( ix ) = zy ( iy ) zy ( iy ) = ztemp ix = ix + incx iy = iy + incy enddo endif end subroutine zswap !> !!##NAME !!    zsymm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: lda,ldb,ldc,m,n !!       character,intent(in)               :: side,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZSYMM performs one of the matrix-matrix operations !! !!     C := alpha*A*B + beta*C, !! !!  or !! !!     C := alpha*B*A + beta*C, !! !!  where alpha and beta are scalars, A is a symmetric matrix and B and !!  C are m by n matrices. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether the symmetric matrix A !!            appears on the left or right in the operation as follows: !! !!               SIDE = 'L' or 'l'   C := alpha*A*B + beta*C, !! !!               SIDE = 'R' or 'r'   C := alpha*B*A + beta*C, !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the symmetric matrix A is to be !!            referenced as follows: !! !!               UPLO = 'U' or 'u'   Only the upper triangular part of the !!                                   symmetric matrix is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the lower triangular part of the !!                                   symmetric matrix is to be referenced. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of the matrix C. !!            M must be at least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of the matrix C. !!            N must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            m when SIDE = 'L' or 'l' and is n otherwise. !!            Before entry with SIDE = 'L' or 'l', the m by m part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading m by m upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading m by m lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !!            Before entry with SIDE = 'R' or 'r', the n by n part of !!            the array A must contain the symmetric matrix, such that !!            when UPLO = 'U' or 'u', the leading n by n upper triangular !!            part of the array A must contain the upper triangular part !!            of the symmetric matrix and the strictly lower triangular !!            part of A is not referenced, and when UPLO = 'L' or 'l', !!            the leading n by n lower triangular part of the array A !!            must contain the lower triangular part of the symmetric !!            matrix and the strictly upper triangular part of A is not !!            referenced. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), otherwise LDA must be at !!            least max( 1, n ). !! !!   B !! !!           B is complex(kind=real64) array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. When BETA is !!            supplied as zero then C need not be set on input. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry, the leading m by n part of the array C must !!            contain the matrix C, except when beta is zero, in which !!            case C need not be set on entry. !!            On exit, the array C is overwritten by the m by n updated !!            matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zsymm ( side , uplo , m , n , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: lda , ldb , ldc , m , n character , intent ( in ) :: side , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , k , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Set NROWA as the number of rows of A. ! if ( lsame ( side , 'L' )) then nrowa = m else nrowa = n endif upper = lsame ( uplo , 'U' ) ! !     Test the input parameters. ! info = 0 if ((. not . lsame ( side , 'L' )) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ( m . lt . 0 ) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , m )) then info = 9 elseif ( ldc . lt . max ( 1 , m )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYMM ' , info ) return endif ! !     Quick return if possible. ! if (( m . eq . 0 ) . or . ( n . eq . 0 ) . or . (( alpha . eq . zero ). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( beta . eq . zero ) then c ( 1 : m , 1 : n ) = zero else c ( 1 : m , 1 : n ) = beta * c ( 1 : m , 1 : n ) endif return endif ! !     Start the operations. ! if ( lsame ( side , 'L' )) then ! !        Form  C := alpha*A*B + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , m temp1 = alpha * b ( i , j ) temp2 = zero do k = 1 , i - 1 c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp1 = alpha * b ( i , j ) temp2 = zero do k = i + 1 , m c ( k , j ) = c ( k , j ) + temp1 * a ( k , i ) temp2 = temp2 + b ( k , j ) * a ( k , i ) enddo if ( beta . eq . zero ) then c ( i , j ) = temp1 * a ( i , i ) + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + temp1 * a ( i , i ) + alpha * temp2 endif enddo enddo endif else ! !        Form  C := alpha*B*A + beta*C. ! do j = 1 , n temp1 = alpha * a ( j , j ) if ( beta . eq . zero ) then c ( 1 : m , j ) = temp1 * b ( 1 : m , j ) else c ( 1 : m , j ) = beta * c ( 1 : m , j ) + temp1 * b ( 1 : m , j ) endif do k = 1 , j - 1 if ( upper ) then temp1 = alpha * a ( k , j ) else temp1 = alpha * a ( j , k ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo do k = j + 1 , n if ( upper ) then temp1 = alpha * a ( j , k ) else temp1 = alpha * a ( k , j ) endif c ( 1 : m , j ) = c ( 1 : m , j ) + temp1 * b ( 1 : m , k ) enddo enddo endif end subroutine zsymm !> !!##NAME !!    zsyr2k(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha,beta !!       integer,intent(in)                 :: k,lda,ldb,ldc,n !!       character,intent(in)               :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*),b(ldb,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZSYR2K performs one of the symmetric rank 2k operations !! !!     C := alpha*A*B**T + alpha*B*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*B + alpha*B**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A and B are n by k matrices in the first case and k by n !!  matrices in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'    C := alpha*A*B**T + alpha*B*A**T + !!                                          beta*C. !! !!               TRANS = 'T' or 't'    C := alpha*A**T*B + alpha*B**T*A + !!                                          beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrices A and B, and on entry with !!            TRANS = 'T' or 't', K specifies the number of rows of the !!            matrices A and B. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   B !! !!           B is complex(kind=real64) array, dimension ( LDB, kb ), where kb is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array B must contain the matrix B, otherwise !!            the leading k by n part of the array B must contain the !!            matrix B. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDB must be at least max( 1, n ), otherwise LDB must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zsyr2k ( uplo , trans , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha , beta integer , intent ( in ) :: k , lda , ldb , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp1 , temp2 integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldb . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldc . lt . max ( 1 , n )) then info = 12 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYR2K' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*B**T + alpha*B*A**T + C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + a ( 1 : j , l ) * temp1 + b ( 1 : j , l ) * temp2 endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if (( a ( j , l ). ne . zero ) . or . ( b ( j , l ). ne . zero )) then temp1 = alpha * b ( j , l ) temp2 = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + a ( j : n , l ) * temp1 + b ( j : n , l ) * temp2 endif enddo enddo endif else ! !        Form  C := alpha*A**T*B + alpha*B**T*A + C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo else do j = 1 , n do i = j , n temp1 = zero temp2 = zero do l = 1 , k temp1 = temp1 + a ( l , i ) * b ( l , j ) temp2 = temp2 + b ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp1 + alpha * temp2 else c ( i , j ) = beta * c ( i , j ) + alpha * temp1 + alpha * temp2 endif enddo enddo endif endif end subroutine zsyr2k !> !!##NAME !!    zsyrk(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine zsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(inout) :: alpha,beta !!       integer,intent(in)                 :: k,lda,ldc,n !!       character,intent(in)               :: trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: c(ldc,*) !!       .. !! !!##DEFINITION !! !!  ZSYRK performs one of the symmetric rank k operations !! !!     C := alpha*A*A**T + beta*C, !! !!  or !! !!     C := alpha*A**T*A + beta*C, !! !!  where alpha and beta are scalars, C is an n by n symmetric matrix !!  and A is an n by k matrix in the first case and a k by n matrix !!  in the second case. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the upper or lower !!            triangular part of the array C is to be referenced as !!            follows: !! !!               UPLO = 'U' or 'u'   Only the  upper triangular part of  C !!                                   is to be referenced. !! !!               UPLO = 'L' or 'l'   Only the  lower triangular part of  C !!                                   is to be referenced. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C. !! !!               TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix C. N must be !!            at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with TRANS = 'N' or 'n', K specifies the number !!            of columns of the matrix A, and on entry with !!            TRANS = 'T' or 't', K specifies the number of rows of the !!            matrix A. K must be at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, ka ), where ka is !!            k when TRANS = 'N' or 'n', and is n otherwise. !!            Before entry with TRANS = 'N' or 'n', the leading n by k !!            part of the array A must contain the matrix A, otherwise !!            the leading k by n part of the array A must contain the !!            matrix A. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When TRANS = 'N' or 'n' !!            then LDA must be at least max( 1, n ), otherwise LDA must !!            be at least max( 1, k ). !! !!   BETA !! !!           BETA is complex(kind=real64) !!            On entry, BETA specifies the scalar beta. !! !!  C !! !!           C is complex(kind=real64) array, dimension ( LDC, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array C must contain the upper !!            triangular part of the symmetric matrix and the strictly !!            lower triangular part of C is not referenced. On exit, the !!            upper triangular part of the array C is overwritten by the !!            upper triangular part of the updated matrix. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array C must contain the lower !!            triangular part of the symmetric matrix and the strictly !!            upper triangular part of C is not referenced. On exit, the !!            lower triangular part of the array C is overwritten by the !!            lower triangular part of the updated matrix. !! !!   LDC !! !!           LDC is INTEGER !!            On entry, LDC specifies the first dimension of C as declared !!            in the calling (sub) program. LDC must be at least !!            max( 1, n ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine zsyrk ( uplo , trans , n , k , alpha , a , lda , beta , c , ldc ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( inout ) :: alpha , beta integer , intent ( in ) :: k , lda , ldc , n character , intent ( in ) :: trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: c ( ldc , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , l , nrowa logical upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! if ( lsame ( trans , 'N' )) then nrowa = n else nrowa = k endif upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 1 elseif ((. not . lsame ( trans , 'N' )) . and . (. not . lsame ( trans , 'T' ))) then info = 2 elseif ( n . lt . 0 ) then info = 3 elseif ( k . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , nrowa )) then info = 7 elseif ( ldc . lt . max ( 1 , n )) then info = 10 endif if ( info . ne . 0 ) then call xerbla ( 'ZSYRK ' , info ) return endif ! !     Quick return if possible. ! if (( n . eq . 0 ) . or . ((( alpha . eq . zero ). or . ( k . eq . 0 )). and . ( beta . eq . one ))) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then if ( upper ) then if ( beta . eq . zero ) then do j = 1 , n c ( 1 : j , j ) = zero enddo else do j = 1 , n c ( 1 : j , j ) = beta * c ( 1 : j , j ) enddo endif else if ( beta . eq . zero ) then do j = 1 , n c ( j : n , j ) = zero enddo else do j = 1 , n c ( j : n , j ) = beta * c ( j : n , j ) enddo endif endif return endif ! !     Start the operations. ! if ( lsame ( trans , 'N' )) then ! !        Form  C := alpha*A*A**T + beta*C. ! if ( upper ) then do j = 1 , n if ( beta . eq . zero ) then c ( 1 : j , j ) = zero elseif ( beta . ne . one ) then c ( 1 : j , j ) = beta * c ( 1 : j , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( 1 : j , j ) = c ( 1 : j , j ) + temp * a ( 1 : j , l ) endif enddo enddo else do j = 1 , n if ( beta . eq . zero ) then c ( j : n , j ) = zero elseif ( beta . ne . one ) then c ( j : n , j ) = beta * c ( j : n , j ) endif do l = 1 , k if ( a ( j , l ). ne . zero ) then temp = alpha * a ( j , l ) c ( j : n , j ) = c ( j : n , j ) + temp * a ( j : n , l ) endif enddo enddo endif else ! !        Form  C := alpha*A**T*A + beta*C. ! if ( upper ) then do j = 1 , n do i = 1 , j temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo else do j = 1 , n do i = j , n temp = zero do l = 1 , k temp = temp + a ( l , i ) * a ( l , j ) enddo if ( beta . eq . zero ) then c ( i , j ) = alpha * temp else c ( i , j ) = alpha * temp + beta * c ( i , j ) endif enddo enddo endif endif end subroutine zsyrk !> !!##NAME !!    ztbmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztbmv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,k,lda,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTBMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular band matrix, with ( k + 1 ) diagonals. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ). !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztbmv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZTBMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX   too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !         Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( kplus1 , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = kplus1 - j do i = max ( 1 , j - k ), j - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( kplus1 , j ) endif jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( l + i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( 1 , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx l = 1 - j do i = min ( n , j + k ), j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( l + i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( 1 , j ) endif jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + dconjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) kx = kx - incx ix = kx l = kplus1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( kplus1 , j ) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + a ( l + i , j ) * x ( ix ) ix = ix - incx enddo else if ( nounit ) temp = temp * dconjg ( a ( kplus1 , j )) do i = j - 1 , max ( 1 , j - k ), - 1 temp = temp + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + dconjg ( a ( l + i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) kx = kx + incx ix = kx l = 1 - j if ( noconj ) then if ( nounit ) temp = temp * a ( 1 , j ) do i = j + 1 , min ( n , j + k ) temp = temp + a ( l + i , j ) * x ( ix ) ix = ix + incx enddo else if ( nounit ) temp = temp * dconjg ( a ( 1 , j )) do i = j + 1 , min ( n , j + k ) temp = temp + dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine ztbmv !> !!##NAME !!    ztbsv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztbsv(uplo,trans,diag,n,k,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,k,lda,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTBSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular band matrix, with ( k + 1 ) !!  diagonals. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   K !! !!           K is INTEGER !!            On entry with UPLO = 'U' or 'u', K specifies the number of !!            super-diagonals of the matrix A. !!            On entry with UPLO = 'L' or 'l', K specifies the number of !!            sub-diagonals of the matrix A. !!            K must satisfy 0 .le. K. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) !!            by n part of the array A must contain the upper triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row !!            ( k + 1 ) of the array, the first super-diagonal starting at !!            position 2 in row k, and so on. The top left k by k triangle !!            of the array A is not referenced. !!            The following program segment will transfer an upper !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = K + 1 - J !!                     DO 10, I = MAX( 1, J - K ), J !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) !!            by n part of the array A must contain the lower triangular !!            band part of the matrix of coefficients, supplied column by !!            column, with the leading diagonal of the matrix in row 1 of !!            the array, the first sub-diagonal starting at position 1 in !!            row 2, and so on. The bottom right k by k triangle of the !!            array A is not referenced. !!            The following program segment will transfer a lower !!            triangular band matrix from conventional full matrix storage !!            to band storage: !! !!                  DO 20, J = 1, N !!                     M = 1 - J !!                     DO 10, I = J, MIN( N, J + K ) !!                        A( M + I, J ) = matrix( I, J ) !!               10    CONTINUE !!               20 CONTINUE !! !!            Note that when DIAG = 'U' or 'u' the elements of the array A !!            corresponding to the diagonal elements of the matrix are not !!            referenced, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            ( k + 1 ). !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztbsv ( uplo , trans , diag , n , k , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , k , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kplus1 , kx , l logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max , min !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( k . lt . 0 ) then info = 5 elseif ( lda . lt . ( k + 1 )) then info = 7 elseif ( incx . eq . 0 ) then info = 9 endif if ( info . ne . 0 ) then call xerbla ( 'ZTBSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed by sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then l = kplus1 - j if ( nounit ) x ( j ) = x ( j ) / a ( kplus1 , j ) temp = x ( j ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 kx = kx - incx if ( x ( jx ). ne . zero ) then ix = kx l = kplus1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( kplus1 , j ) temp = x ( jx ) do i = j - 1 , max ( 1 , j - k ), - 1 x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix - incx enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then l = 1 - j if ( nounit ) x ( j ) = x ( j ) / a ( 1 , j ) temp = x ( j ) do i = j + 1 , min ( n , j + k ) x ( i ) = x ( i ) - temp * a ( l + i , j ) enddo endif enddo else jx = kx do j = 1 , n kx = kx + incx if ( x ( jx ). ne . zero ) then ix = kx l = 1 - j if ( nounit ) x ( jx ) = x ( jx ) / a ( 1 , j ) temp = x ( jx ) do i = j + 1 , min ( n , j + k ) x ( ix ) = x ( ix ) - temp * a ( l + i , j ) ix = ix + incx enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kplus1 = k + 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( kplus1 , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx l = kplus1 - j if ( noconj ) then do i = max ( 1 , j - k ), j - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( kplus1 , j ) else do i = max ( 1 , j - k ), j - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( a ( kplus1 , j )) endif x ( jx ) = temp jx = jx + incx if ( j . gt . k ) kx = kx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( 1 , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx l = 1 - j if ( noconj ) then do i = min ( n , j + k ), j + 1 , - 1 temp = temp - a ( l + i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( 1 , j ) else do i = min ( n , j + k ), j + 1 , - 1 temp = temp - dconjg ( a ( l + i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( a ( 1 , j )) endif x ( jx ) = temp jx = jx - incx if (( n - j ). ge . k ) kx = kx - incx enddo endif endif endif end subroutine ztbsv !> !!##NAME !!    ztpmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztpmv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: ap(*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTPMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix, supplied in packed form. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is complex(kind=real64) array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztpmv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZTPMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x:= A*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = 1 , j - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k + 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk + j - 1 ) endif kk = kk + j enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk + j - 2 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk + j - 1 ) endif jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) k = kk do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * ap ( k ) k = k - 1 enddo if ( nounit ) x ( j ) = x ( j ) * ap ( kk - n + j ) endif kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do k = kk , kk - ( n - ( j + 1 )), - 1 x ( ix ) = x ( ix ) + temp * ap ( k ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * ap ( kk - n + j ) endif jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk - 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j - 1 , 1 , - 1 temp = temp + ap ( k ) * x ( i ) k = k - 1 enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do i = j - 1 , 1 , - 1 temp = temp + dconjg ( ap ( k )) * x ( i ) k = k - 1 enddo endif x ( j ) = temp kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx temp = temp + dconjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk + 1 if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do i = j + 1 , n temp = temp + ap ( k ) * x ( i ) k = k + 1 enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do i = j + 1 , n temp = temp + dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo endif x ( j ) = temp kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * ap ( kk ) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + ap ( k ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( ap ( kk )) do k = kk + 1 , kk + n - j ix = ix + incx temp = temp + dconjg ( ap ( k )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif endif end subroutine ztpmv !> !!##NAME !!    ztpsv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztpsv(uplo,trans,diag,n,ap,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: ap(*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTPSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix, supplied in packed form. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   AP !! !!           AP is complex(kind=real64) array, dimension at least !!            ( ( n*( n + 1 ) )/2 ). !!            Before entry with UPLO = 'U' or 'u', the array AP must !!            contain the upper triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 ) !!            respectively, and so on. !!            Before entry with UPLO = 'L' or 'l', the array AP must !!            contain the lower triangular matrix packed sequentially, !!            column by column, so that AP( 1 ) contains a( 1, 1 ), !!            AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 ) !!            respectively, and so on. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced, but are assumed to be unity. !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztpsv ( uplo , trans , diag , n , ap , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: ap ( * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , k , kk , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( incx . eq . 0 ) then info = 7 endif if ( info . ne . 0 ) then call xerbla ( 'ZTPSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of AP are !     accessed sequentially with one pass through AP. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk - 1 do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * ap ( k ) k = k - 1 enddo endif kk = kk - j enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk - 1 , kk - j + 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx - incx kk = kk - j enddo endif else kk = 1 if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / ap ( kk ) temp = x ( j ) k = kk + 1 do i = j + 1 , n x ( i ) = x ( i ) - temp * ap ( k ) k = k + 1 enddo endif kk = kk + ( n - j + 1 ) enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / ap ( kk ) temp = x ( jx ) ix = jx do k = kk + 1 , kk + n - j ix = ix + incx x ( ix ) = x ( ix ) - temp * ap ( k ) enddo endif jx = jx + incx kk = kk + ( n - j + 1 ) enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then kk = 1 if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) k = kk if ( noconj ) then do i = 1 , j - 1 temp = temp - ap ( k ) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do i = 1 , j - 1 temp = temp - dconjg ( ap ( k )) * x ( i ) k = k + 1 enddo if ( nounit ) temp = temp / dconjg ( ap ( kk + j - 1 )) endif x ( j ) = temp kk = kk + j enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk + j - 2 temp = temp - ap ( k ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / ap ( kk + j - 1 ) else do k = kk , kk + j - 2 temp = temp - dconjg ( ap ( k )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( ap ( kk + j - 1 )) endif x ( jx ) = temp jx = jx + incx kk = kk + j enddo endif else kk = ( n * ( n + 1 )) / 2 if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) k = kk if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - ap ( k ) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( ap ( k )) * x ( i ) k = k - 1 enddo if ( nounit ) temp = temp / dconjg ( ap ( kk - n + j )) endif x ( j ) = temp kk = kk - ( n - j + 1 ) enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 temp = x ( jx ) ix = kx if ( noconj ) then do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - ap ( k ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / ap ( kk - n + j ) else do k = kk , kk - ( n - ( j + 1 )), - 1 temp = temp - dconjg ( ap ( k )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( ap ( kk - n + j )) endif x ( jx ) = temp jx = jx - incx kk = kk - ( n - j + 1 ) enddo endif endif endif end subroutine ztpsv !> !!##NAME !!    ztrmm(3f) - [BLAS:COMPLEX16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine ztrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: lda,ldb,m,n !!       character,intent(in)               :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  ZTRMM performs one of the matrix-matrix operations !! !!     B := alpha*op( A )*B,   or   B := alpha*B*op( A ) !! !!  where alpha is a scalar, B is an m by n matrix, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) multiplies B from !!            the left or right as follows: !! !!               SIDE = 'L' or 'l'   B := alpha*op( A )*B. !! !!               SIDE = 'R' or 'r'   B := alpha*B*op( A ). !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**H. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, k ), where k is m !!            when SIDE = 'L' or 'l' and is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is complex(kind=real64) array, dimension ( LDB, N ). !!            Before entry, the leading m by n part of the array B must !!            contain the matrix B, and on exit is overwritten by the !!            transformed matrix. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztrmm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRMM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n do i = 1 , m b ( i , j ) = zero enddo enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*A*B. ! if ( upper ) then do j = 1 , n do k = 1 , m if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo if ( nounit ) temp = temp * a ( k , k ) b ( k , j ) = temp endif enddo enddo else do j = 1 , n do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then temp = alpha * b ( k , j ) b ( k , j ) = temp if ( nounit ) b ( k , j ) = b ( k , j ) * a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) + temp * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*A**T*B   or   B := alpha*A**H*B. ! if ( upper ) then do j = 1 , n do i = m , 1 , - 1 temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = 1 , i - 1 temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * dconjg ( a ( i , i )) do k = 1 , i - 1 temp = temp + dconjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo else do j = 1 , n do i = 1 , m temp = b ( i , j ) if ( noconj ) then if ( nounit ) temp = temp * a ( i , i ) do k = i + 1 , m temp = temp + a ( k , i ) * b ( k , j ) enddo else if ( nounit ) temp = temp * dconjg ( a ( i , i )) do k = i + 1 , m temp = temp + dconjg ( a ( k , i )) * b ( k , j ) enddo endif b ( i , j ) = alpha * temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*A. ! if ( upper ) then do j = n , 1 , - 1 temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo else do j = 1 , n temp = alpha if ( nounit ) temp = temp * a ( j , j ) b ( 1 : m , j ) = temp * b ( 1 : m , j ) do k = j + 1 , n if ( a ( k , j ). ne . zero ) then temp = alpha * a ( k , j ) b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo enddo endif else ! !           Form  B := alpha*B*A**T   or   B := alpha*B*A**H. ! if ( upper ) then do k = 1 , n do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * dconjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * dconjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo else do k = n , 1 , - 1 do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = alpha * a ( j , k ) else temp = alpha * dconjg ( a ( j , k )) endif b ( 1 : m , j ) = b ( 1 : m , j ) + temp * b ( 1 : m , k ) endif enddo temp = alpha if ( nounit ) then if ( noconj ) then temp = temp * a ( k , k ) else temp = temp * dconjg ( a ( k , k )) endif endif if ( temp . ne . one ) then b ( 1 : m , k ) = temp * b ( 1 : m , k ) endif enddo endif endif endif end subroutine ztrmm !> !!##NAME !!    ztrmv(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztrmv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,lda,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTRMV performs one of the matrix-vector operations !! !!     x := A*x,   or   x := A**T*x,   or   x := A**H*x, !! !!  where x is an n element vector and A is an n by n unit, or non-unit, !!  upper or lower triangular matrix. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !! !!           TRANS is CHARACTER*1 !!            On entry, TRANS specifies the operation to be performed as !!            follows: !! !!               TRANS = 'N' or 'n'   x := A*x. !! !!               TRANS = 'T' or 't'   x := A**T*x. !! !!               TRANS = 'C' or 'c'   x := A**H*x. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, N ). !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element vector x. On exit, X is overwritten with the !!            transformed vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !!   The vector and matrix arguments are not referenced when N = 0, or M = 0 !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztrmv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRMV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := A*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then temp = x ( j ) do i = 1 , j - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = 1 , j - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix + incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then temp = x ( j ) do i = n , j + 1 , - 1 x ( i ) = x ( i ) + temp * a ( i , j ) enddo if ( nounit ) x ( j ) = x ( j ) * a ( j , j ) endif enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then temp = x ( jx ) ix = kx do i = n , j + 1 , - 1 x ( ix ) = x ( ix ) + temp * a ( i , j ) ix = ix - incx enddo if ( nounit ) x ( jx ) = x ( jx ) * a ( j , j ) endif jx = jx - incx enddo endif endif else ! !        Form  x := A**T*x  or  x := A**H*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j - 1 , 1 , - 1 temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j - 1 , 1 , - 1 ix = ix - incx temp = temp + dconjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n temp = temp + a ( i , j ) * x ( i ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j + 1 , n temp = temp + dconjg ( a ( i , j )) * x ( i ) enddo endif x ( j ) = temp enddo else jx = kx do j = 1 , n temp = x ( jx ) ix = jx if ( noconj ) then if ( nounit ) temp = temp * a ( j , j ) do i = j + 1 , n ix = ix + incx temp = temp + a ( i , j ) * x ( ix ) enddo else if ( nounit ) temp = temp * dconjg ( a ( j , j )) do i = j + 1 , n ix = ix + incx temp = temp + dconjg ( a ( i , j )) * x ( ix ) enddo endif x ( jx ) = temp jx = jx + incx enddo endif endif endif end subroutine ztrmv !> !!##NAME !!    ztrsm(3f) - [BLAS:COMPLEX_16_BLAS_LEVEL3] !! !!##SYNOPSIS !! !!     subroutine ztrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb) !! !!       .. Scalar Arguments .. !!       complex(kind=real64),intent(in)    :: alpha !!       integer,intent(in)                 :: lda,ldb,m,n !!       character,intent(in)               :: diag,side,transa,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: b(ldb,*) !!       .. !! !!##DEFINITION !! !!  ZTRSM solves one of the matrix equations !! !!     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, !! !!  where alpha is a scalar, X and B are m by n matrices, A is a unit, or !!  non-unit, upper or lower triangular matrix and op( A ) is one of !! !!     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H. !! !!  The matrix X is overwritten on B. !! !!##OPTIONS !! !!   SIDE !! !!           SIDE is CHARACTER*1 !!            On entry, SIDE specifies whether op( A ) appears on the left !!            or right of X as follows: !! !!               SIDE = 'L' or 'l'   op( A )*X = alpha*B. !! !!               SIDE = 'R' or 'r'   X*op( A ) = alpha*B. !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix A is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANSA !! !!           TRANSA is CHARACTER*1 !!            On entry, TRANSA specifies the form of op( A ) to be used in !!            the matrix multiplication as follows: !! !!               TRANSA = 'N' or 'n'   op( A ) = A. !! !!               TRANSA = 'T' or 't'   op( A ) = A**T. !! !!               TRANSA = 'C' or 'c'   op( A ) = A**H. !! !!   DIAG !! !!           DIAG is CHARACTER*1 !!            On entry, DIAG specifies whether or not A is unit triangular !!            as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   M !! !!           M is INTEGER !!            On entry, M specifies the number of rows of B. M must be at !!            least zero. !! !!   N !! !!           N is INTEGER !!            On entry, N specifies the number of columns of B. N must be !!            at least zero. !! !!   ALPHA !! !!           ALPHA is complex(kind=real64) !!            On entry, ALPHA specifies the scalar alpha. When alpha is !!            zero then A is not referenced and B need not be set before !!            entry. !! !!   A !! !!           A is complex(kind=real64) array, dimension ( LDA, k ), !!            where k is m when SIDE = 'L' or 'l' !!              and k is n when SIDE = 'R' or 'r'. !!            Before entry with UPLO = 'U' or 'u', the leading k by k !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading k by k !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. When SIDE = 'L' or 'l' then !!            LDA must be at least max( 1, m ), when SIDE = 'R' or 'r' !!            then LDA must be at least max( 1, n ). !! !!  B !! !!           B is complex(kind=real64) array, dimension ( LDB, N ) !!            Before entry, the leading m by n part of the array B must !!            contain the right-hand side matrix B, and on exit is !!            overwritten by the solution matrix X. !! !!   LDB !! !!           LDB is INTEGER !!            On entry, LDB specifies the first dimension of B as declared !!            in the calling (sub) program. LDB must be at least !!            max( 1, m ). !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 3 Blas routine. !! !!   -- Written on 8-February-1989. !!      Jack Dongarra, Argonne National Laboratory. !!      Iain Duff, AERE Harwell. !!      Jeremy Du Croz, Numerical Algorithms Group Ltd. !!      Sven Hammarling, Numerical Algorithms Group Ltd. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztrsm ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) implicit none ! !  -- Reference BLAS level3 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. complex ( kind = real64 ), intent ( in ) :: alpha integer , intent ( in ) :: lda , ldb , m , n character , intent ( in ) :: diag , side , transa , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: b ( ldb , * ) !     .. ! !  ===================================================================== ! !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , j , k , nrowa logical lside , noconj , nounit , upper !     .. !     .. Parameters .. complex ( kind = real64 ) :: one parameter ( one = ( 1.0d+0 , 0.0d+0 )) complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. ! !     Test the input parameters. ! lside = lsame ( side , 'L' ) if ( lside ) then nrowa = m else nrowa = n endif noconj = lsame ( transa , 'T' ) nounit = lsame ( diag , 'N' ) upper = lsame ( uplo , 'U' ) ! info = 0 if ((. not . lside ) . and . (. not . lsame ( side , 'R' ))) then info = 1 elseif ((. not . upper ) . and . (. not . lsame ( uplo , 'L' ))) then info = 2 elseif ((. not . lsame ( transa , 'N' )) . and . (. not . lsame ( transa , 'T' )) . and . (. not . lsame ( transa , 'C' ))) then info = 3 elseif ((. not . lsame ( diag , 'U' )) . and . (. not . lsame ( diag , 'N' ))) then info = 4 elseif ( m . lt . 0 ) then info = 5 elseif ( n . lt . 0 ) then info = 6 elseif ( lda . lt . max ( 1 , nrowa )) then info = 9 elseif ( ldb . lt . max ( 1 , m )) then info = 11 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRSM ' , info ) return endif ! !     Quick return if possible. ! if ( m . eq . 0 . or . n . eq . 0 ) return ! !     And when  alpha.eq.zero. ! if ( alpha . eq . zero ) then do j = 1 , n do i = 1 , m b ( i , j ) = zero enddo enddo return endif ! !     Start the operations. ! if ( lside ) then if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*inv( A )*B. ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = m , 1 , - 1 if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = 1 , k - 1 b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo else do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = 1 , m if ( b ( k , j ). ne . zero ) then if ( nounit ) b ( k , j ) = b ( k , j ) / a ( k , k ) do i = k + 1 , m b ( i , j ) = b ( i , j ) - b ( k , j ) * a ( i , k ) enddo endif enddo enddo endif else ! !           Form  B := alpha*inv( A**T )*B !           or    B := alpha*inv( A**H )*B. ! if ( upper ) then do j = 1 , n do i = 1 , m temp = alpha * b ( i , j ) if ( noconj ) then do k = 1 , i - 1 temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = 1 , i - 1 temp = temp - dconjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / dconjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo else do j = 1 , n do i = m , 1 , - 1 temp = alpha * b ( i , j ) if ( noconj ) then do k = i + 1 , m temp = temp - a ( k , i ) * b ( k , j ) enddo if ( nounit ) temp = temp / a ( i , i ) else do k = i + 1 , m temp = temp - dconjg ( a ( k , i )) * b ( k , j ) enddo if ( nounit ) temp = temp / dconjg ( a ( i , i )) endif b ( i , j ) = temp enddo enddo endif endif else if ( lsame ( transa , 'N' )) then ! !           Form  B := alpha*B*inv( A ). ! if ( upper ) then do j = 1 , n if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = 1 , j - 1 if ( a ( k , j ). ne . zero ) then do i = 1 , m b ( i , j ) = b ( i , j ) - a ( k , j ) * b ( i , k ) enddo endif enddo if ( nounit ) then temp = one / a ( j , j ) do i = 1 , m b ( i , j ) = temp * b ( i , j ) enddo endif enddo else do j = n , 1 , - 1 if ( alpha . ne . one ) then do i = 1 , m b ( i , j ) = alpha * b ( i , j ) enddo endif do k = j + 1 , n if ( a ( k , j ). ne . zero ) then do i = 1 , m b ( i , j ) = b ( i , j ) - a ( k , j ) * b ( i , k ) enddo endif enddo if ( nounit ) then temp = one / a ( j , j ) do i = 1 , m b ( i , j ) = temp * b ( i , j ) enddo endif enddo endif else ! !           Form  B := alpha*B*inv( A**T ) !           or    B := alpha*B*inv( A**H ). ! if ( upper ) then do k = n , 1 , - 1 if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / dconjg ( a ( k , k )) endif do i = 1 , m b ( i , k ) = temp * b ( i , k ) enddo endif do j = 1 , k - 1 if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = dconjg ( a ( j , k )) endif do i = 1 , m b ( i , j ) = b ( i , j ) - temp * b ( i , k ) enddo endif enddo if ( alpha . ne . one ) then do i = 1 , m b ( i , k ) = alpha * b ( i , k ) enddo endif enddo else do k = 1 , n if ( nounit ) then if ( noconj ) then temp = one / a ( k , k ) else temp = one / dconjg ( a ( k , k )) endif do i = 1 , m b ( i , k ) = temp * b ( i , k ) enddo endif do j = k + 1 , n if ( a ( j , k ). ne . zero ) then if ( noconj ) then temp = a ( j , k ) else temp = dconjg ( a ( j , k )) endif do i = 1 , m b ( i , j ) = b ( i , j ) - temp * b ( i , k ) enddo endif enddo if ( alpha . ne . one ) then do i = 1 , m b ( i , k ) = alpha * b ( i , k ) enddo endif enddo endif endif endif end subroutine ztrsm !> !!##NAME !!    ztrsv(3f) - [BLAS:COMPLEX16_BLAS_LEVEL2] !! !!##SYNOPSIS !! !!     subroutine ztrsv(uplo,trans,diag,n,a,lda,x,incx) !! !!       .. Scalar Arguments .. !!       integer,intent(in)                 :: incx,lda,n !!       character,intent(in)               :: diag,trans,uplo !!       .. !!       .. Array Arguments .. !!       complex(kind=real64),intent(in)    :: a(lda,*) !!       complex(kind=real64),intent(inout) :: x(*) !!       .. !! !!##DEFINITION !! !!  ZTRSV solves one of the systems of equations !! !!     A*x = b,   or   A**T*x = b,   or   A**H*x = b, !! !!  where b and x are n element vectors and A is an n by n unit, or !!  non-unit, upper or lower triangular matrix. !! !!  No test for singularity or near-singularity is included in this !!  routine. Such tests must be performed before calling this routine. !! !!##OPTIONS !! !!   UPLO !! !!           UPLO is CHARACTER*1 !!            On entry, UPLO specifies whether the matrix is an upper or !!            lower triangular matrix as follows: !! !!               UPLO = 'U' or 'u'   A is an upper triangular matrix. !! !!               UPLO = 'L' or 'l'   A is a lower triangular matrix. !! !!   TRANS !!            On entry, TRANS specifies the equations to be solved as !!            follows: !! !!               TRANS = 'N' or 'n'   A*x = b. !! !!               TRANS = 'T' or 't'   A**T*x = b. !! !!               TRANS = 'C' or 'c'   A**H*x = b. !! !!   DIAG !!            On entry, DIAG specifies whether or not A is unit !!            triangular as follows: !! !!               DIAG = 'U' or 'u'   A is assumed to be unit triangular. !! !!               DIAG = 'N' or 'n'   A is not assumed to be unit !!                                   triangular. !! !!   N !!            On entry, N specifies the order of the matrix A. !!            N must be at least zero. !! !!   A !!            A is complex(kind=real64) array, dimension ( LDA, N ) !!            Before entry with UPLO = 'U' or 'u', the leading n by n !!            upper triangular part of the array A must contain the upper !!            triangular matrix and the strictly lower triangular part of !!            A is not referenced. !!            Before entry with UPLO = 'L' or 'l', the leading n by n !!            lower triangular part of the array A must contain the lower !!            triangular matrix and the strictly upper triangular part of !!            A is not referenced. !!            Note that when DIAG = 'U' or 'u', the diagonal elements of !!            A are not referenced either, but are assumed to be unity. !! !!   LDA !! !!           LDA is INTEGER !!            On entry, LDA specifies the first dimension of A as declared !!            in the calling (sub) program. LDA must be at least !!            max( 1, n ). !! !!  X !! !!           X is complex(kind=real64) array, dimension at least !!            ( 1 + ( n - 1 )*abs( INCX ) ). !!            Before entry, the incremented array X must contain the n !!            element right-hand side vector b. On exit, X is overwritten !!            with the solution vector x. !! !!   INCX !! !!           INCX is INTEGER !!            On entry, INCX specifies the increment for the elements of !!            X. INCX must not be zero. !! !!##AUTHORS !! !! + Univ. of Tennessee !! + Univ. of California Berkeley !! + Univ. of Colorado Denver !! + NAG Ltd. !! !!  date:December 2016 !! !!  FURTHER DETAILS !! !!   Level 2 Blas routine. !! !!   -- Written on 22-October-1986. !!      Jack Dongarra, Argonne National Lab. !!      Jeremy Du Croz, Nag Central Office. !!      Sven Hammarling, Nag Central Office. !!      Richard Hanson, Sandia National Labs. !! !!##SEE ALSO !!    Online html documentation available at !!    http://www.netlib.org/lapack/explore-html/ !  ===================================================================== subroutine ztrsv ( uplo , trans , diag , n , a , lda , x , incx ) implicit none ! !  -- Reference BLAS level2 routine (version 3.7.0) -- !  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- !     December 2016 ! !     .. Scalar Arguments .. integer , intent ( in ) :: incx , lda , n character , intent ( in ) :: diag , trans , uplo !     .. !     .. Array Arguments .. complex ( kind = real64 ), intent ( in ) :: a ( lda , * ) complex ( kind = real64 ), intent ( inout ) :: x ( * ) !     .. ! !  ===================================================================== ! !     .. Parameters .. complex ( kind = real64 ) :: zero parameter ( zero = ( 0.0d+0 , 0.0d+0 )) !     .. !     .. Local Scalars .. complex ( kind = real64 ) :: temp integer i , info , ix , j , jx , kx logical noconj , nounit !     .. !     .. External Functions .. !      LOGICAL LSAME !      EXTERNAL LSAME !     .. !     .. External Subroutines .. !      EXTERNAL XERBLA !     .. !     .. Intrinsic Functions .. intrinsic dconjg , max !     .. ! !     Test the input parameters. ! info = 0 if (. not . lsame ( uplo , 'U' ) . and . . not . lsame ( uplo , 'L' )) then info = 1 elseif (. not . lsame ( trans , 'N' ) . and . . not . lsame ( trans , 'T' ) . and . . not . lsame ( trans , 'C' )) then info = 2 elseif (. not . lsame ( diag , 'U' ) . and . . not . lsame ( diag , 'N' )) then info = 3 elseif ( n . lt . 0 ) then info = 4 elseif ( lda . lt . max ( 1 , n )) then info = 6 elseif ( incx . eq . 0 ) then info = 8 endif if ( info . ne . 0 ) then call xerbla ( 'ZTRSV ' , info ) return endif ! !     Quick return if possible. ! if ( n . eq . 0 ) return ! noconj = lsame ( trans , 'T' ) nounit = lsame ( diag , 'N' ) ! !     Set up the start point in X if the increment is not unity. This !     will be  ( N - 1 )*INCX  too small for descending loops. ! if ( incx . le . 0 ) then kx = 1 - ( n - 1 ) * incx elseif ( incx . ne . 1 ) then kx = 1 endif ! !     Start the operations. In this version the elements of A are !     accessed sequentially with one pass through A. ! if ( lsame ( trans , 'N' )) then ! !        Form  x := inv( A )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = n , 1 , - 1 if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j - 1 , 1 , - 1 x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx + ( n - 1 ) * incx do j = n , 1 , - 1 if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j - 1 , 1 , - 1 ix = ix - incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx - incx enddo endif else if ( incx . eq . 1 ) then do j = 1 , n if ( x ( j ). ne . zero ) then if ( nounit ) x ( j ) = x ( j ) / a ( j , j ) temp = x ( j ) do i = j + 1 , n x ( i ) = x ( i ) - temp * a ( i , j ) enddo endif enddo else jx = kx do j = 1 , n if ( x ( jx ). ne . zero ) then if ( nounit ) x ( jx ) = x ( jx ) / a ( j , j ) temp = x ( jx ) ix = jx do i = j + 1 , n ix = ix + incx x ( ix ) = x ( ix ) - temp * a ( i , j ) enddo endif jx = jx + incx enddo endif endif else ! !        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. ! if ( lsame ( uplo , 'U' )) then if ( incx . eq . 1 ) then do j = 1 , n temp = x ( j ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - dconjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( j ) = temp enddo else jx = kx do j = 1 , n ix = kx temp = x ( jx ) if ( noconj ) then do i = 1 , j - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = 1 , j - 1 temp = temp - dconjg ( a ( i , j )) * x ( ix ) ix = ix + incx enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( jx ) = temp jx = jx + incx enddo endif else if ( incx . eq . 1 ) then do j = n , 1 , - 1 temp = x ( j ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( i ) enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( a ( i , j )) * x ( i ) enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( j ) = temp enddo else kx = kx + ( n - 1 ) * incx jx = kx do j = n , 1 , - 1 ix = kx temp = x ( jx ) if ( noconj ) then do i = n , j + 1 , - 1 temp = temp - a ( i , j ) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / a ( j , j ) else do i = n , j + 1 , - 1 temp = temp - dconjg ( a ( i , j )) * x ( ix ) ix = ix - incx enddo if ( nounit ) temp = temp / dconjg ( a ( j , j )) endif x ( jx ) = temp jx = jx - incx enddo endif endif endif end subroutine ztrsv end module M_blas","tags":"","loc":"sourcefile/m_blas.f90.html"}]}